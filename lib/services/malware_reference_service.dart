import 'package:http/http.dart' as http;
import 'dart:convert';
import '../config/api_config.dart';

class MalwareReferenceService {
  static Map<String, String> _deviceTypeCache = {};
  static Map<String, String> _detectionTypeCache = {};
  static Map<String, String> _operatingSystemCache = {};
  static String? _malwareReportCategoryId;
  static String? _malwareReportTypeId;
  static bool _isInitialized = false;

  // Initialize and fetch all reference data
  static Future<void> initialize() async {
    if (_isInitialized) {
      print('âœ… Malware reference service already initialized');
      return;
    }

    print('ğŸ”„ Initializing malware reference service...');
    print('ğŸŒ Using base URL: ${ApiConfig.mainBaseUrl}');

    try {
      await Future.wait([
        _fetchDeviceTypes(),
        _fetchDetectionTypes(),
        _fetchOperatingSystems(),
        _fetchMalwareReportCategory(),
        _fetchMalwareReportType(),
      ]);
      _isInitialized = true;
      print('âœ… Malware reference data initialized');
      printCache(); // Debug: print current cache
    } catch (e) {
      print('âŒ Error initializing malware reference service: $e');
    }
  }

  // Fetch device types from backend
  static Future<void> _fetchDeviceTypes() async {
    try {
      final url = '${ApiConfig.mainBaseUrl}${ApiConfig.dropdownEndpoint}';
      print('ğŸ”„ Fetching device types from: $url');
      final response = await http.get(Uri.parse(url));

      print('ğŸ“¥ Device types response status: ${response.statusCode}');
      print('ğŸ“¥ Device types response body: ${response.body}');

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        final List<dynamic> deviceTypes = data is List
            ? data
            : (data['data'] ?? []);

        _deviceTypeCache.clear();
        for (var device in deviceTypes) {
          final name = device['name']?.toString().toLowerCase() ?? '';
          final id = device['_id']?.toString() ?? '';
          if (name.isNotEmpty && id.isNotEmpty) {
            _deviceTypeCache[name] = id;
            print('ğŸ“± Added device type: $name -> $id');
          }
        }
        print('ğŸ“± Loaded ${_deviceTypeCache.length} device types');
      } else {
        print('âŒ Failed to fetch device types. Status: ${response.statusCode}');
        print('ğŸ“± No device types available from backend');
      }
    } catch (e) {
      print('âŒ Error fetching device types: $e');
      print('ğŸ“± No device types available from backend');
    }
  }

  // Fetch detection types from backend
  static Future<void> _fetchDetectionTypes() async {
    try {
      final url = '${ApiConfig.mainBaseUrl}${ApiConfig.dropdownEndpoint}';
      print('ğŸ”„ Fetching detection types from: $url');
      final response = await http.get(Uri.parse(url));

      print('ğŸ“¥ Detection types response status: ${response.statusCode}');
      print('ğŸ“¥ Detection types response body: ${response.body}');

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        final List<dynamic> detectionTypes = data is List
            ? data
            : (data['data'] ?? []);

        _detectionTypeCache.clear();
        for (var detection in detectionTypes) {
          final name = detection['name']?.toString().toLowerCase() ?? '';
          final id = detection['_id']?.toString() ?? '';
          if (name.isNotEmpty && id.isNotEmpty) {
            _detectionTypeCache[name] = id;
            print('ğŸ” Added detection type: $name -> $id');
          }
        }
        print('ğŸ” Loaded ${_detectionTypeCache.length} detection types');
      } else {
        print(
          'âŒ Failed to fetch detection types. Status: ${response.statusCode}',
        );
        print('ğŸ” No detection types available from backend');
      }
    } catch (e) {
      print('âŒ Error fetching detection types: $e');
      print('ğŸ” No detection types available from backend');
    }
  }

  // Fetch operating systems from backend
  static Future<void> _fetchOperatingSystems() async {
    try {
      final url = '${ApiConfig.mainBaseUrl}${ApiConfig.dropdownEndpoint}';
      print('ğŸ”„ Fetching operating systems from: $url');
      final response = await http.get(Uri.parse(url));

      print('ğŸ“¥ Operating systems response status: ${response.statusCode}');
      print('ğŸ“¥ Operating systems response body: ${response.body}');

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        final List<dynamic> operatingSystems = data is List
            ? data
            : (data['data'] ?? []);

        _operatingSystemCache.clear();
        for (var os in operatingSystems) {
          final name = os['name']?.toString().toLowerCase() ?? '';
          final id = os['_id']?.toString() ?? '';
          if (name.isNotEmpty && id.isNotEmpty) {
            _operatingSystemCache[name] = id;
            print('ğŸ’» Added operating system: $name -> $id');
          }
        }
        print('ğŸ’» Loaded ${_operatingSystemCache.length} operating systems');
      } else {
        print(
          'âŒ Failed to fetch operating systems. Status: ${response.statusCode}',
        );
        print('ğŸ’» No operating systems available from backend');
      }
    } catch (e) {
      print('âŒ Error fetching operating systems: $e');
      print('ğŸ’» No operating systems available from backend');
    }
  }

  // Fetch malware report category from backend
  static Future<void> _fetchMalwareReportCategory() async {
    try {
      final url =
          '${ApiConfig.reportsBaseUrl}${ApiConfig.reportCategoryEndpoint}';
      print('ğŸ” Fetching malware report categories from: $url');
      final response = await http.get(Uri.parse(url));

      print('ğŸ“¥ Report categories response status: ${response.statusCode}');
      print('ğŸ“¥ Report categories response body: ${response.body}');

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        // Fixed: Handle direct list or 'data' key
        final List<dynamic> categories = data is List
            ? data
            : (data['data'] ?? []);

        print('ğŸ“‹ Found ${categories.length} report categories');

        // Find the malware report category
        for (var category in categories) {
          final name = category['name']?.toString() ?? '';
          final id = category['_id']?.toString() ?? '';
          print('ğŸ“‹ Checking category: $name (ID: $id)');

          if (name.toLowerCase().contains('malware')) {
            _malwareReportCategoryId = id;
            print('ğŸ¦  Found malware report category: $name (ID: $id)');
            break;
          }
        }

        if (_malwareReportCategoryId == null) {
          print('âš ï¸ Malware report category not found in backend');
          print(
            'ğŸ“‹ Available categories: ${categories.map((c) => c['name']).toList()}',
          );
        }
      } else {
        print(
          'âŒ Failed to fetch report categories. Status: ${response.statusCode}',
        );
      }
    } catch (e) {
      print('âŒ Error fetching malware report category: $e');
    }
  }

  // Fetch malware report type from backend
  static Future<void> _fetchMalwareReportType() async {
    try {
      final url = '${ApiConfig.reportsBaseUrl}${ApiConfig.reportTypeEndpoint}';
      print('ğŸ”„ Fetching malware report types from: $url');
      final response = await http.get(Uri.parse(url));

      print('ğŸ“¥ Report types response status: ${response.statusCode}');
      print('ğŸ“¥ Report types response body: ${response.body}');

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        final List<dynamic> reportTypes = data is List
            ? data
            : (data['data'] ?? []);

        print('ğŸ“‹ Found ${reportTypes.length} report types');
        print(
          'ğŸ¦  Looking for report type with categoryId: $_malwareReportCategoryId',
        );

        // Find the malware report type (first one for malware category)
        for (var reportType in reportTypes) {
          final categoryIdObj = reportType['reportCategoryId'];
          final categoryId = categoryIdObj is Map
              ? categoryIdObj['_id']?.toString() ?? ''
              : categoryIdObj?.toString() ?? '';
          final id = reportType['_id']?.toString() ?? '';
          final name = reportType['name']?.toString() ?? '';
          print(
            'ğŸ“‹ Checking report type: $name (categoryId: $categoryId, id: $id)',
          );

          if (categoryId == _malwareReportCategoryId) {
            _malwareReportTypeId = id;
            print('ğŸ¦  Found malware report type: $name (ID: $id)');
            break;
          }
        }

        if (_malwareReportTypeId == null) {
          print('âš ï¸ Malware report type not found in backend');
          print(
            'ğŸ“‹ Available report types: ${reportTypes.map((r) => '${r['name']} (categoryId: ${r['reportCategoryId']})').toList()}',
          );
        }
      } else {
        print('âŒ Failed to fetch report types. Status: ${response.statusCode}');
      }
    } catch (e) {
      print('âŒ Error fetching malware report type: $e');
    }
  }

  // Get device type ObjectId
  static String getDeviceTypeId(String deviceType) {
    final key = deviceType.toLowerCase();
    final deviceId = _deviceTypeCache[key];
    if (deviceId != null && deviceId.isNotEmpty) {
      return deviceId;
    }

    // Try to find a partial match
    for (var entry in _deviceTypeCache.entries) {
      if (key.contains(entry.key) || entry.key.contains(key)) {
        print(
          'âœ… Found partial match for device type "$deviceType" -> "${entry.key}"',
        );
        return entry.value;
      }
    }

    // No fallback - return empty string
    print('âŒ Device type "$deviceType" not found in backend cache');
    return '';
  }

  // Get detection type ObjectId
  static String getDetectionTypeId(String detectionMethod) {
    final key = detectionMethod.toLowerCase();
    final detectionId = _detectionTypeCache[key];
    if (detectionId != null && detectionId.isNotEmpty) {
      return detectionId;
    }

    // Try to find a partial match
    for (var entry in _detectionTypeCache.entries) {
      if (key.contains(entry.key) || entry.key.contains(key)) {
        print(
          'âœ… Found partial match for detection type "$detectionMethod" -> "${entry.key}"',
        );
        return entry.value;
      }
    }

    // No fallback - return empty string
    print('âŒ Detection type "$detectionMethod" not found in backend cache');
    return '';
  }

  // Get operating system ObjectId
  static String getOperatingSystemId(String os) {
    final key = os.toLowerCase();
    final osId = _operatingSystemCache[key];
    if (osId != null && osId.isNotEmpty) {
      return osId;
    }

    // Try to find a partial match
    for (var entry in _operatingSystemCache.entries) {
      if (key.contains(entry.key) || entry.key.contains(key)) {
        print('âœ… Found partial match for OS "$os" -> "${entry.key}"');
        return entry.value;
      }
    }

    // No fallback - return empty string
    print('âŒ Operating system "$os" not found in backend cache');
    return '';
  }

  // Get malware report category ObjectId
  static String getMalwareReportCategoryId() {
    if (_malwareReportCategoryId == null) {
      print('âŒ Malware report category ID not fetched from backend yet');
      return '';
    }
    return _malwareReportCategoryId!;
  }

  // Get malware report type ObjectId
  static String getMalwareReportTypeId() {
    if (_malwareReportTypeId == null) {
      print('âŒ Malware report type ID not fetched from backend yet');
      return '';
    }
    return _malwareReportTypeId!;
  }

  // Get all available device types
  static List<String> getAvailableDeviceTypes() {
    return _deviceTypeCache.keys.toList();
  }

  // Get all available detection types
  static List<String> getAvailableDetectionTypes() {
    return _detectionTypeCache.keys.toList();
  }

  // Get all available operating systems
  static List<String> getAvailableOperatingSystems() {
    return _operatingSystemCache.keys.toList();
  }

  // Refresh all reference data
  static Future<void> refresh() async {
    print('ğŸ”„ Force refreshing malware reference data...');
    _isInitialized = false;
    _deviceTypeCache.clear();
    _detectionTypeCache.clear();
    _operatingSystemCache.clear();
    _malwareReportCategoryId = null;
    _malwareReportTypeId = null;
    await initialize();
  }

  // Check if service is initialized
  static bool get isInitialized => _isInitialized;

  // Check if all required data is available
  static bool get hasAllRequiredData {
    return _isInitialized &&
        _malwareReportCategoryId != null &&
        _malwareReportCategoryId!.isNotEmpty &&
        _malwareReportTypeId != null &&
        _malwareReportTypeId!.isNotEmpty;
  }

  // Debug: print current cache
  static void printCache() {
    print('ğŸ“± Device Types Cache: $_deviceTypeCache');
    print('ğŸ” Detection Types Cache: $_detectionTypeCache');
    print('ğŸ’» Operating Systems Cache: $_operatingSystemCache');
    print('ğŸ¦  Malware Report Category ID: $_malwareReportCategoryId');
    print('ğŸ¦  Malware Report Type ID: $_malwareReportTypeId');
    print('âœ… Service initialized: $_isInitialized');
    print('âœ… Has all required data: ${hasAllRequiredData}');
  }

  // Test all API endpoints
  static Future<void> testAllEndpoints() async {
    print('ğŸ§ª Testing all malware reference endpoints...');

    final endpoints = [
      {
        'name': 'Device Types',
        'url': '${ApiConfig.reportsBaseUrl}${ApiConfig.alertLevelsEndpoint}',
      },
      {
        'name': 'Detection Types',
        'url': '${ApiConfig.reportsBaseUrl}${ApiConfig.alertLevelsEndpoint}',
      },
      {
        'name': 'Operating Systems',
        'url': '${ApiConfig.reportsBaseUrl}${ApiConfig.alertLevelsEndpoint}',
      },
      {
        'name': 'Report Categories',
        'url': '${ApiConfig.reportsBaseUrl}${ApiConfig.reportCategoryEndpoint}',
      },
      {
        'name': 'Report Types',
        'url': '${ApiConfig.reportsBaseUrl}${ApiConfig.reportTypeEndpoint}',
      },
    ];

    for (var endpoint in endpoints) {
      try {
        print('ğŸ§ª Testing ${endpoint['name']}: ${endpoint['url']}');
        final response = await http.get(Uri.parse(endpoint['url']!));
        print('ğŸ“¥ ${endpoint['name']} Status: ${response.statusCode}');
        print('ğŸ“¥ ${endpoint['name']} Body: ${response.body}');
        print('---');
      } catch (e) {
        print('âŒ Error testing ${endpoint['name']}: $e');
        print('---');
      }
    }
  }
}
