import 'package:dio/dio.dart';
import '../config/api_config.dart';
import 'dio_service.dart';

class MalwareReferenceService {
  static Map<String, String> _deviceTypeCache = {};
  static Map<String, String> _detectionTypeCache = {};
  static Map<String, String> _operatingSystemCache = {};
  static String? _malwareReportCategoryId;
  static String? _malwareReportTypeId;
  static bool _isInitialized = false;
  static final DioService _dioService = DioService();

  // Initialize and fetch all reference data
  static Future<void> initialize() async {
    if (_isInitialized) {
      return;
    }

    try {
      await Future.wait([
        _fetchDeviceTypes(),
        _fetchDetectionTypes(),
        _fetchOperatingSystems(),
        _fetchMalwareReportCategory(),
        _fetchMalwareReportType(),
      ]);
      _isInitialized = true;

      printCache(); // Debug: print current cache
    } catch (e) {}
  }

  // Fetch device types from backend
  static Future<void> _fetchDeviceTypes() async {
    try {
      final response = await _dioService.get(ApiConfig.dropdownEndpoint);

      if (response.statusCode == 200) {
        final data = response.data;
        final List<dynamic> deviceTypes = data is List
            ? data
            : (data['data'] ?? []);

        _deviceTypeCache.clear();
        for (var device in deviceTypes) {
          final name = device['name']?.toString().toLowerCase() ?? '';
          final id = device['_id']?.toString() ?? '';
          if (name.isNotEmpty && id.isNotEmpty) {
            _deviceTypeCache[name] = id;
          }
        }
      } else {}
    } catch (e) {
      if (e is DioException) {}
    }
  }

  // Fetch detection types from backend
  static Future<void> _fetchDetectionTypes() async {
    try {
      final response = await _dioService.get(ApiConfig.dropdownEndpoint);

      if (response.statusCode == 200) {
        final data = response.data;
        final List<dynamic> detectionTypes = data is List
            ? data
            : (data['data'] ?? []);

        _detectionTypeCache.clear();
        for (var detection in detectionTypes) {
          final name = detection['name']?.toString().toLowerCase() ?? '';
          final id = detection['_id']?.toString() ?? '';
          if (name.isNotEmpty && id.isNotEmpty) {
            _detectionTypeCache[name] = id;
          }
        }
      } else {
        print(
          '‚ùå Failed to fetch detection types. Status: ${response.statusCode}',
        );
      }
    } catch (e) {
      if (e is DioException) {}
    }
  }

  // Fetch operating systems from backend
  static Future<void> _fetchOperatingSystems() async {
    try {
      print(
        'üîÑ Fetching operating systems from: ${ApiConfig.dropdownEndpoint}',
      );
      final response = await _dioService.get(ApiConfig.dropdownEndpoint);

      if (response.statusCode == 200) {
        final data = response.data;
        final List<dynamic> operatingSystems = data is List
            ? data
            : (data['data'] ?? []);

        _operatingSystemCache.clear();
        for (var os in operatingSystems) {
          final name = os['name']?.toString().toLowerCase() ?? '';
          final id = os['_id']?.toString() ?? '';
          if (name.isNotEmpty && id.isNotEmpty) {
            _operatingSystemCache[name] = id;
          }
        }
      } else {
        print(
          '‚ùå Failed to fetch operating systems. Status: ${response.statusCode}',
        );
      }
    } catch (e) {
      if (e is DioException) {}
    }
  }

  // Fetch malware report category from backend
  static Future<void> _fetchMalwareReportCategory() async {
    try {
      print(
        'üîç Fetching malware report categories from: ${ApiConfig.reportCategoryEndpoint}',
      );
      final response = await _dioService.get(ApiConfig.reportCategoryEndpoint);

      if (response.statusCode == 200) {
        final data = response.data;
        // Fixed: Handle direct list or 'data' key
        final List<dynamic> categories = data is List
            ? data
            : (data['data'] ?? []);

        // Find the malware report category
        for (var category in categories) {
          final name = category['name']?.toString() ?? '';
          final id = category['_id']?.toString() ?? '';
          print('üìã Checking category: $name (ID: $id)');

          if (name.toLowerCase().contains('malware')) {
            _malwareReportCategoryId = id;
            print('ü¶† Found malware report category: $name (ID: $id)');
            break;
          }
        }

        if (_malwareReportCategoryId == null) {
          print(
            'üìã Available categories: ${categories.map((c) => c['name']).toList()}',
          );
        }
      } else {
        print(
          '‚ùå Failed to fetch report categories. Status: ${response.statusCode}',
        );
      }
    } catch (e) {
      if (e is DioException) {}
    }
  }

  // Fetch malware report type from backend
  static Future<void> _fetchMalwareReportType() async {
    try {
      print(
        'üîÑ Fetching malware report types from: ${ApiConfig.reportTypeEndpoint}',
      );
      final response = await _dioService.get(ApiConfig.reportTypeEndpoint);

      if (response.statusCode == 200) {
        final data = response.data;
        final List<dynamic> reportTypes = data is List
            ? data
            : (data['data'] ?? []);

        print(
          'ü¶† Looking for report type with categoryId: $_malwareReportCategoryId',
        );

        // Find the malware report type (first one for malware category)
        for (var reportType in reportTypes) {
          final categoryIdObj = reportType['reportCategoryId'];
          final categoryId = categoryIdObj is Map
              ? categoryIdObj['_id']?.toString() ?? ''
              : categoryIdObj?.toString() ?? '';
          final id = reportType['_id']?.toString() ?? '';
          final name = reportType['name']?.toString() ?? '';
          print(
            'üìã Checking report type: $name (categoryId: $categoryId, id: $id)',
          );

          if (categoryId == _malwareReportCategoryId) {
            _malwareReportTypeId = id;
            print('ü¶† Found malware report type: $name (ID: $id)');
            break;
          }
        }

        if (_malwareReportTypeId == null) {
          print(
            'üìã Available report types: ${reportTypes.map((r) => '${r['name']} (categoryId: ${r['reportCategoryId']})').toList()}',
          );
        }
      } else {}
    } catch (e) {
      if (e is DioException) {}
    }
  }

  // Get device type ObjectId
  static String getDeviceTypeId(String deviceType) {
    final key = deviceType.toLowerCase();
    final deviceId = _deviceTypeCache[key];
    if (deviceId != null && deviceId.isNotEmpty) {
      return deviceId;
    }

    // Try to find a partial match
    for (var entry in _deviceTypeCache.entries) {
      if (key.contains(entry.key) || entry.key.contains(key)) {
        print(
          '‚úÖ Found partial match for device type "$deviceType" -> "${entry.key}"',
        );
        return entry.value;
      }
    }

    // No fallback - return empty string

    return '';
  }

  // Get detection type ObjectId
  static String getDetectionTypeId(String detectionMethod) {
    final key = detectionMethod.toLowerCase();
    final detectionId = _detectionTypeCache[key];
    if (detectionId != null && detectionId.isNotEmpty) {
      return detectionId;
    }

    // Try to find a partial match
    for (var entry in _detectionTypeCache.entries) {
      if (key.contains(entry.key) || entry.key.contains(key)) {
        print(
          '‚úÖ Found partial match for detection type "$detectionMethod" -> "${entry.key}"',
        );
        return entry.value;
      }
    }

    // No fallback - return empty string

    return '';
  }

  // Get operating system ObjectId
  static String getOperatingSystemId(String os) {
    final key = os.toLowerCase();
    final osId = _operatingSystemCache[key];
    if (osId != null && osId.isNotEmpty) {
      return osId;
    }

    // Try to find a partial match
    for (var entry in _operatingSystemCache.entries) {
      if (key.contains(entry.key) || entry.key.contains(key)) {
        return entry.value;
      }
    }

    // No fallback - return empty string

    return '';
  }

  // Get malware report category ObjectId
  static String getMalwareReportCategoryId() {
    if (_malwareReportCategoryId == null) {
      return '';
    }
    return _malwareReportCategoryId!;
  }

  // Get malware report type ObjectId
  static String getMalwareReportTypeId() {
    if (_malwareReportTypeId == null) {
      return '';
    }
    return _malwareReportTypeId!;
  }

  // Get all available device types
  static List<String> getAvailableDeviceTypes() {
    return _deviceTypeCache.keys.toList();
  }

  // Get all available detection types
  static List<String> getAvailableDetectionTypes() {
    return _detectionTypeCache.keys.toList();
  }

  // Get all available operating systems
  static List<String> getAvailableOperatingSystems() {
    return _operatingSystemCache.keys.toList();
  }

  // Refresh all reference data
  static Future<void> refresh() async {
    _isInitialized = false;
    _deviceTypeCache.clear();
    _detectionTypeCache.clear();
    _operatingSystemCache.clear();
    _malwareReportCategoryId = null;
    _malwareReportTypeId = null;
    await initialize();
  }

  // Check if service is initialized
  static bool get isInitialized => _isInitialized;

  // Check if all required data is available
  static bool get hasAllRequiredData {
    return _isInitialized &&
        _malwareReportCategoryId != null &&
        _malwareReportCategoryId!.isNotEmpty &&
        _malwareReportTypeId != null &&
        _malwareReportTypeId!.isNotEmpty;
  }

  // Debug: print current cache
  static void printCache() {}

  // Test all API endpoints
  static Future<void> testAllEndpoints() async {
    final endpoints = [
      {'name': 'Device Types', 'url': ApiConfig.dropdownEndpoint},
      {'name': 'Detection Types', 'url': ApiConfig.dropdownEndpoint},
      {'name': 'Operating Systems', 'url': ApiConfig.dropdownEndpoint},
      {'name': 'Report Categories', 'url': ApiConfig.reportCategoryEndpoint},
      {'name': 'Report Types', 'url': ApiConfig.reportTypeEndpoint},
    ];

    for (var endpoint in endpoints) {
      try {
        final response = await _dioService.get(endpoint['url']!);
      } catch (e) {}
    }
  }
}

// import 'package:dio/dio.dart';
// import 'dart:convert';
// import '../config/api_config.dart';
// import 'dio_service.dart';

// class MalwareReferenceService {
//   static Map<String, String> _deviceTypeCache = {};
//   static Map<String, String> _detectionTypeCache = {};
//   static Map<String, String> _operatingSystemCache = {};
//   static String? _malwareReportCategoryId;
//   static String? _malwareReportTypeId;
//   static bool _isInitialized = false;
//   static final DioService _dioService = DioService();

//   // Initialize and fetch all reference data
//   static Future<void> initialize() async {
//     if (_isInitialized) {
//       print('‚úÖ Malware reference service already initialized');
//       return;
//     }

//     print('üîÑ Initializing malware reference service...');
//     print('üåê Using base URL: ${ApiConfig.mainBaseUrl}');

//     try {
//       await Future.wait([
//         _fetchDeviceTypes(),
//         _fetchDetectionTypes(),
//         _fetchOperatingSystems(),
//         _fetchMalwareReportCategory(),
//         _fetchMalwareReportType(),
//       ]);
//       _isInitialized = true;
//       print('‚úÖ Malware reference data initialized');
//       printCache(); // Debug: print current cache
//     } catch (e) {
//       print('‚ùå Error initializing malware reference service: $e');
//     }
//   }

//   // Fetch device types from backend
//   static Future<void> _fetchDeviceTypes() async {
//     try {
//       print('üîÑ Fetching device types from: ${ApiConfig.dropdownEndpoint}');
//       final response = await _dioService.get(ApiConfig.dropdownEndpoint);

//       print('üì• Device types response status: ${response.statusCode}');
//       print('üì• Device types response data: ${response.data}');

//       if (response.statusCode == 200) {
//         final data = response.data;
//         final List<dynamic> deviceTypes = data is List
//             ? data
//             : (data['data'] ?? []);

//         _deviceTypeCache.clear();
//         for (var device in deviceTypes) {
//           final name = device['name']?.toString().toLowerCase() ?? '';
//           final id = device['_id']?.toString() ?? '';
//           if (name.isNotEmpty && id.isNotEmpty) {
//             _deviceTypeCache[name] = id;
//             print('üì± Added device type: $name -> $id');
//           }
//         }
//         print('üì± Loaded ${_deviceTypeCache.length} device types');
//       } else {
//         print('‚ùå Failed to fetch device types. Status: ${response.statusCode}');
//         print('üì± No device types available from backend');
//       }
//     } catch (e) {
//       print('‚ùå Error fetching device types: $e');
//       print('üì± No device types available from backend');
//       if (e is DioException) {
//         print('üì° DioException type: ${e.type}');
//         print('üì° DioException message: ${e.message}');
//         print('üì° Response status: ${e.response?.statusCode}');
//         print('üì° Response data: ${e.response?.data}');
//       }
//     }
//   }

//   // Fetch detection types from backend
//   static Future<void> _fetchDetectionTypes() async {
//     try {
//       print('üîÑ Fetching detection types from: ${ApiConfig.dropdownEndpoint}');
//       final response = await _dioService.get(ApiConfig.dropdownEndpoint);

//       print('üì• Detection types response status: ${response.statusCode}');
//       print('üì• Detection types response data: ${response.data}');

//       if (response.statusCode == 200) {
//         final data = response.data;
//         final List<dynamic> detectionTypes = data is List
//             ? data
//             : (data['data'] ?? []);

//         _detectionTypeCache.clear();
//         for (var detection in detectionTypes) {
//           final name = detection['name']?.toString().toLowerCase() ?? '';
//           final id = detection['_id']?.toString() ?? '';
//           if (name.isNotEmpty && id.isNotEmpty) {
//             _detectionTypeCache[name] = id;
//             print('üîç Added detection type: $name -> $id');
//           }
//         }
//         print('üîç Loaded ${_detectionTypeCache.length} detection types');
//       } else {
//         print(
//           '‚ùå Failed to fetch detection types. Status: ${response.statusCode}',
//         );
//         print('üîç No detection types available from backend');
//       }
//     } catch (e) {
//       print('‚ùå Error fetching detection types: $e');
//       print('üîç No detection types available from backend');
//       if (e is DioException) {
//         print('üì° DioException type: ${e.type}');
//         print('üì° DioException message: ${e.message}');
//         print('üì° Response status: ${e.response?.statusCode}');
//         print('üì° Response data: ${e.response?.data}');
//       }
//     }
//   }

//   // Fetch operating systems from backend
//   static Future<void> _fetchOperatingSystems() async {
//     try {
//       print(
//         'üîÑ Fetching operating systems from: ${ApiConfig.dropdownEndpoint}',
//       );
//       final response = await _dioService.get(ApiConfig.dropdownEndpoint);

//       print('üì• Operating systems response status: ${response.statusCode}');
//       print('üì• Operating systems response data: ${response.data}');

//       if (response.statusCode == 200) {
//         final data = response.data;
//         final List<dynamic> operatingSystems = data is List
//             ? data
//             : (data['data'] ?? []);

//         _operatingSystemCache.clear();
//         for (var os in operatingSystems) {
//           final name = os['name']?.toString().toLowerCase() ?? '';
//           final id = os['_id']?.toString() ?? '';
//           if (name.isNotEmpty && id.isNotEmpty) {
//             _operatingSystemCache[name] = id;
//             print('üíª Added operating system: $name -> $id');
//           }
//         }
//         print('üíª Loaded ${_operatingSystemCache.length} operating systems');
//       } else {
//         print(
//           '‚ùå Failed to fetch operating systems. Status: ${response.statusCode}',
//         );
//         print('üíª No operating systems available from backend');
//       }
//     } catch (e) {
//       print('‚ùå Error fetching operating systems: $e');
//       print('üíª No operating systems available from backend');
//       if (e is DioException) {
//         print('üì° DioException type: ${e.type}');
//         print('üì° DioException message: ${e.message}');
//         print('üì° Response status: ${e.response?.statusCode}');
//         print('üì° Response data: ${e.response?.data}');
//       }
//     }
//   }

//   // Fetch malware report category from backend
//   static Future<void> _fetchMalwareReportCategory() async {
//     try {
//       print(
//         'üîç Fetching malware report categories from: ${ApiConfig.reportCategoryEndpoint}',
//       );
//       final response = await _dioService.get(ApiConfig.reportCategoryEndpoint);

//       print('üì• Report categories response status: ${response.statusCode}');
//       print('üì• Report categories response data: ${response.data}');

//       if (response.statusCode == 200) {
//         final data = response.data;
//         // Fixed: Handle direct list or 'data' key
//         final List<dynamic> categories = data is List
//             ? data
//             : (data['data'] ?? []);

//         print('üìã Found ${categories.length} report categories');

//         // Find the malware report category
//         for (var category in categories) {
//           final name = category['name']?.toString() ?? '';
//           final id = category['_id']?.toString() ?? '';
//           print('üìã Checking category: $name (ID: $id)');

//           if (name.toLowerCase().contains('malware')) {
//             _malwareReportCategoryId = id;
//             print('ü¶† Found malware report category: $name (ID: $id)');
//             break;
//           }
//         }

//         if (_malwareReportCategoryId == null) {
//           print('‚ö†Ô∏è Malware report category not found in backend');
//           print(
//             'üìã Available categories: ${categories.map((c) => c['name']).toList()}',
//           );
//         }
//       } else {
//         print(
//           '‚ùå Failed to fetch report categories. Status: ${response.statusCode}',
//         );
//       }
//     } catch (e) {
//       print('‚ùå Error fetching malware report category: $e');
//       if (e is DioException) {
//         print('üì° DioException type: ${e.type}');
//         print('üì° DioException message: ${e.message}');
//         print('üì° Response status: ${e.response?.statusCode}');
//         print('üì° Response data: ${e.response?.data}');
//       }
//     }
//   }

//   // Fetch malware report type from backend
//   static Future<void> _fetchMalwareReportType() async {
//     try {
//       print(
//         'üîÑ Fetching malware report types from: ${ApiConfig.reportTypeEndpoint}',
//       );
//       final response = await _dioService.get(ApiConfig.reportTypeEndpoint);

//       print('üì• Report types response status: ${response.statusCode}');
//       print('üì• Report types response data: ${response.data}');

//       if (response.statusCode == 200) {
//         final data = response.data;
//         final List<dynamic> reportTypes = data is List
//             ? data
//             : (data['data'] ?? []);

//         print('üìã Found ${reportTypes.length} report types');
//         print(
//           'ü¶† Looking for report type with categoryId: $_malwareReportCategoryId',
//         );

//         // Find the malware report type (first one for malware category)
//         for (var reportType in reportTypes) {
//           final categoryIdObj = reportType['reportCategoryId'];
//           final categoryId = categoryIdObj is Map
//               ? categoryIdObj['_id']?.toString() ?? ''
//               : categoryIdObj?.toString() ?? '';
//           final id = reportType['_id']?.toString() ?? '';
//           final name = reportType['name']?.toString() ?? '';
//           print(
//             'üìã Checking report type: $name (categoryId: $categoryId, id: $id)',
//           );

//           if (categoryId == _malwareReportCategoryId) {
//             _malwareReportTypeId = id;
//             print('ü¶† Found malware report type: $name (ID: $id)');
//             break;
//           }
//         }

//         if (_malwareReportTypeId == null) {
//           print('‚ö†Ô∏è Malware report type not found in backend');
//           print(
//             'üìã Available report types: ${reportTypes.map((r) => '${r['name']} (categoryId: ${r['reportCategoryId']})').toList()}',
//           );
//         }
//       } else {
//         print('‚ùå Failed to fetch report types. Status: ${response.statusCode}');
//       }
//     } catch (e) {
//       print('‚ùå Error fetching malware report type: $e');
//       if (e is DioException) {
//         print('üì° DioException type: ${e.type}');
//         print('üì° DioException message: ${e.message}');
//         print('üì° Response status: ${e.response?.statusCode}');
//         print('üì° Response data: ${e.response?.data}');
//       }
//     }
//   }

//   // Get device type ObjectId
//   static String getDeviceTypeId(String deviceType) {
//     final key = deviceType.toLowerCase();
//     final deviceId = _deviceTypeCache[key];
//     if (deviceId != null && deviceId.isNotEmpty) {
//       return deviceId;
//     }

//     // Try to find a partial match
//     for (var entry in _deviceTypeCache.entries) {
//       if (key.contains(entry.key) || entry.key.contains(key)) {
//         print(
//           '‚úÖ Found partial match for device type "$deviceType" -> "${entry.key}"',
//         );
//         return entry.value;
//       }
//     }

//     // No fallback - return empty string
//     print('‚ùå Device type "$deviceType" not found in backend cache');
//     return '';
//   }

//   // Get detection type ObjectId
//   static String getDetectionTypeId(String detectionMethod) {
//     final key = detectionMethod.toLowerCase();
//     final detectionId = _detectionTypeCache[key];
//     if (detectionId != null && detectionId.isNotEmpty) {
//       return detectionId;
//     }

//     // Try to find a partial match
//     for (var entry in _detectionTypeCache.entries) {
//       if (key.contains(entry.key) || entry.key.contains(key)) {
//         print(
//           '‚úÖ Found partial match for detection type "$detectionMethod" -> "${entry.key}"',
//         );
//         return entry.value;
//       }
//     }

//     // No fallback - return empty string
//     print('‚ùå Detection type "$detectionMethod" not found in backend cache');
//     return '';
//   }

//   // Get operating system ObjectId
//   static String getOperatingSystemId(String os) {
//     final key = os.toLowerCase();
//     final osId = _operatingSystemCache[key];
//     if (osId != null && osId.isNotEmpty) {
//       return osId;
//     }

//     // Try to find a partial match
//     for (var entry in _operatingSystemCache.entries) {
//       if (key.contains(entry.key) || entry.key.contains(key)) {
//         print('‚úÖ Found partial match for OS "$os" -> "${entry.key}"');
//         return entry.value;
//       }
//     }

//     // No fallback - return empty string
//     print('‚ùå Operating system "$os" not found in backend cache');
//     return '';
//   }

//   // Get malware report category ObjectId
//   static String getMalwareReportCategoryId() {
//     if (_malwareReportCategoryId == null) {
//       print('‚ùå Malware report category ID not fetched from backend yet');
//       return '';
//     }
//     return _malwareReportCategoryId!;
//   }

//   // Get malware report type ObjectId
//   static String getMalwareReportTypeId() {
//     if (_malwareReportTypeId == null) {
//       print('‚ùå Malware report type ID not fetched from backend yet');
//       return '';
//     }
//     return _malwareReportTypeId!;
//   }

//   // Get all available device types
//   static List<String> getAvailableDeviceTypes() {
//     return _deviceTypeCache.keys.toList();
//   }

//   // Get all available detection types
//   static List<String> getAvailableDetectionTypes() {
//     return _detectionTypeCache.keys.toList();
//   }

//   // Get all available operating systems
//   static List<String> getAvailableOperatingSystems() {
//     return _operatingSystemCache.keys.toList();
//   }

//   // Refresh all reference data
//   static Future<void> refresh() async {
//     print('üîÑ Force refreshing malware reference data...');
//     _isInitialized = false;
//     _deviceTypeCache.clear();
//     _detectionTypeCache.clear();
//     _operatingSystemCache.clear();
//     _malwareReportCategoryId = null;
//     _malwareReportTypeId = null;
//     await initialize();
//   }

//   // Check if service is initialized
//   static bool get isInitialized => _isInitialized;

//   // Check if all required data is available
//   static bool get hasAllRequiredData {
//     return _isInitialized &&
//         _malwareReportCategoryId != null &&
//         _malwareReportCategoryId!.isNotEmpty &&
//         _malwareReportTypeId != null &&
//         _malwareReportTypeId!.isNotEmpty;
//   }

//   // Debug: print current cache
//   static void printCache() {
//     print('üì± Device Types Cache: $_deviceTypeCache');
//     print('üîç Detection Types Cache: $_detectionTypeCache');
//     print('üíª Operating Systems Cache: $_operatingSystemCache');
//     print('ü¶† Malware Report Category ID: $_malwareReportCategoryId');
//     print('ü¶† Malware Report Type ID: $_malwareReportTypeId');
//     print('‚úÖ Service initialized: $_isInitialized');
//     print('‚úÖ Has all required data: ${hasAllRequiredData}');
//   }

//   // Test all API endpoints
//   static Future<void> testAllEndpoints() async {
//     print('üß™ Testing all malware reference endpoints...');

//     final endpoints = [
//       {'name': 'Device Types', 'url': ApiConfig.dropdownEndpoint},
//       {'name': 'Detection Types', 'url': ApiConfig.dropdownEndpoint},
//       {'name': 'Operating Systems', 'url': ApiConfig.dropdownEndpoint},
//       {'name': 'Report Categories', 'url': ApiConfig.reportCategoryEndpoint},
//       {'name': 'Report Types', 'url': ApiConfig.reportTypeEndpoint},
//     ];

//     for (var endpoint in endpoints) {
//       try {
//         print('üß™ Testing ${endpoint['name']}: ${endpoint['url']}');
//         final response = await _dioService.get(endpoint['url']!);
//         print('üì• ${endpoint['name']} Status: ${response.statusCode}');
//         print('üì• ${endpoint['name']} Body: ${response.data}');
//         print('---');
//       } catch (e) {
//         print('‚ùå Error testing ${endpoint['name']}: $e');
//         print('---');
//       }
//     }
//   }
// }
