import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:security_alert/provider/scam_report_provider.dart';
import 'package:security_alert/screens/menu/feedbackPage.dart';
import 'package:security_alert/screens/menu/profile_page.dart';
import 'package:security_alert/screens/menu/ratepage.dart';
import 'package:security_alert/screens/menu/shareApp.dart';
import 'package:security_alert/screens/menu/thread_database_listpage.dart';
import 'package:security_alert/screens/menu/filter_page.dart';
import 'package:security_alert/screens/scam/scam_report_service.dart';
import 'package:security_alert/screens/scam/report_scam_1.dart';
import 'package:security_alert/screens/malware/report_malware_1.dart';
import 'package:security_alert/screens/Fraud/ReportFraudStep1.dart';
import 'package:security_alert/widgets/auth_guard.dart';
import 'package:security_alert/screens/menu/theard_database.dart';

import 'package:security_alert/screens/subscriptionPage/subscription_plans_page.dart';

import 'package:security_alert/provider/auth_provider.dart';
import 'package:security_alert/provider/dashboard_provider.dart';
import 'package:security_alert/screens/SplashScreen.dart';
import 'package:security_alert/screens/dashboard_page.dart';
import 'package:security_alert/screens/login.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:hive/hive.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'dart:async';
import 'models/scam_report_model.dart'; // ✅ Make sure this file contains: part 'scam_report_model.g.dart';
import 'models/fraud_report_model.dart'; // at the top, if not already present
import 'models/malware_report_model.dart';
import 'screens/Fraud/fraud_report_service.dart';
import 'screens/malware/malware_report_service.dart';
import 'screens/scam/scam_local_service.dart';
import 'screens/scam/scam_sync_service.dart';
import 'services/report_update_service.dart';
import 'services/app_version_service.dart';
import 'services/api_service.dart';
import 'services/dio_service.dart';
import 'services/token_storage.dart';
import 'services/jwt_service.dart';
import 'services/offline_cache_service.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:security_alert/custom/offline_file_upload.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Hive.initFlutter();

  // Note: Removed automatic token clearing on startup to preserve user sessions

  Hive.registerAdapter(ScamReportModelAdapter());
  Hive.registerAdapter(FraudReportModelAdapter());
  Hive.registerAdapter(MalwareReportModelAdapter());
  // Hive.registerAdapter(ReportModelAdapter()); // Will be generated by build_runner

  // Open Hive boxes with error handling for corrupted databases

  // Manual test function for reference data
  Future<void> testReferenceData() async {
    print('🧪 Testing reference data availability...');

    try {
      final scamBox = Hive.box<ScamReportModel>('scam_reports');
      final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
      final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

      print('📊 Hive boxes opened successfully');
      print('📊 - Scam reports: ${scamBox.length}');
      print('📊 - Fraud reports: ${fraudBox.length}');
      print('📊 - Malware reports: ${malwareBox.length}');

      // Test offline cache
      await OfflineCacheService.initialize();
      final categories = OfflineCacheService.getCategories();
      final types = OfflineCacheService.getTypes();
      final methodOfContact = OfflineCacheService.getDropdown(
        'method-of-contact',
      );

      print('📋 Offline cache status:');
      print('📋 - Categories: ${categories.length}');
      print('📋 - Types: ${types.length}');
      print('📋 - Method of contact: ${methodOfContact.length}');

      if (categories.isNotEmpty) {
        print('📋 Sample category: ${categories.first['name']}');
      }
      if (types.isNotEmpty) {
        print('📋 Sample type: ${types.first['name']}');
      }
      if (methodOfContact.isNotEmpty) {
        print('📋 Sample method: ${methodOfContact.first['name']}');
      }

      // Test method of contact cache specifically
      print('📞 Testing method of contact cache specifically...');
      try {
        final methodOfContactCache = OfflineCacheService.getDropdown(
          'method-of-contact',
        );
        print(
          '📞 Method of contact cache: ${methodOfContactCache.length} items',
        );

        if (methodOfContactCache.isNotEmpty) {
          print(
            '📞 Sample method of contact: ${methodOfContactCache.first['name']}',
          );
        }
      } catch (e) {
        print('❌ Error testing method of contact cache: $e');
      }
    } catch (e) {
      print('❌ Error testing reference data: $e');
    }
  }

  // Test offline functionality
  Future<void> testOfflineMode() async {
    print('🧪 ===== OFFLINE MODE TEST =====');

    try {
      // 1. Check connectivity
      final connectivityResult = await Connectivity().checkConnectivity();
      print('🌐 Current connectivity: $connectivityResult');

      if (connectivityResult == ConnectivityResult.none) {
        print('✅ App is OFFLINE - perfect for testing');
      } else {
        print('⚠️ App is ONLINE - turn off internet to test offline mode');
      }

      // 2. Check local data
      final scamBox = Hive.box<ScamReportModel>('scam_reports');
      final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
      final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

      print('📊 Local reports:');
      print('📊 - Scam: ${scamBox.length}');
      print('📊 - Fraud: ${fraudBox.length}');
      print('📊 - Malware: ${malwareBox.length}');

      // 3. Check offline cache
      await OfflineCacheService.initialize();
      final categories = OfflineCacheService.getCategories();
      final types = OfflineCacheService.getTypes();
      final methodOfContact = OfflineCacheService.getDropdown(
        'method-of-contact',
      );

      print('📋 Offline reference data:');
      print('📋 - Categories: ${categories.length}');
      print('📋 - Types: ${types.length}');
      print('📋 - Method of contact: ${methodOfContact.length}');

      // 4. Check sync status
      final scamLocalService = ScamLocalService();
      final stats = await scamLocalService.getSyncStats();
      print('🔄 Sync status:');
      print('🔄 - Total: ${stats['total']}');
      print('🔄 - Pending: ${stats['pending']}');
      print('🔄 - Synced: ${stats['synced']}');

      // 5. Summary
      print('\n📋 ===== OFFLINE TEST SUMMARY =====');
      if (connectivityResult == ConnectivityResult.none) {
        if (categories.isNotEmpty && types.isNotEmpty) {
          print('✅ OFFLINE MODE: FULLY FUNCTIONAL');
          print('✅ Can create reports offline');
          print('✅ Can view existing reports');
          print('✅ Reference data available');
        } else {
          print('❌ OFFLINE MODE: Missing reference data');
          print('💡 Go online first to cache reference data');
        }
      } else {
        print(
          '⚠️ ONLINE MODE: Turn off internet to test offline functionality',
        );
      }
    } catch (e) {
      print('❌ Error during offline test: $e');
    }
  }

  // Cache reference data for offline use
  Future<void> cacheReferenceDataForOffline() async {
    print('🔄 ===== CACHING REFERENCE DATA FOR OFFLINE =====');

    try {
      // Check if we're online
      final connectivityResult = await Connectivity().checkConnectivity();
      if (connectivityResult == ConnectivityResult.none) {
        print('❌ Cannot cache data: No internet connection');
        return;
      }

      print('✅ Internet available, caching reference data...');

      // Initialize offline cache service
      await OfflineCacheService.initialize();

      // Cache categories
      print('📋 Caching report categories...');
      await ApiService().prewarmReferenceData();

      // Verify cache
      final categories = OfflineCacheService.getCategories();
      final types = OfflineCacheService.getTypes();
      final methodOfContact = OfflineCacheService.getDropdown(
        'method-of-contact',
      );

      print('📊 Cache verification:');
      print('📊 - Categories: ${categories.length}');
      print('📊 - Types: ${types.length}');
      print('📊 - Method of contact: ${methodOfContact.length}');

      if (categories.isNotEmpty && types.isNotEmpty) {
        print('✅ Reference data cached successfully for offline use');
        print('💡 You can now turn off internet and test offline mode');
      } else {
        print('❌ Failed to cache reference data');
        print('💡 Make sure you are logged in and have internet connection');
      }
    } catch (e) {
      print('❌ Error caching reference data: $e');
    }
  }

  // Sync offline files when back online
  Future<void> syncOfflineFiles() async {
    print('🔄 ===== SYNCING OFFLINE FILES =====');

    try {
      final connectivityResult = await Connectivity().checkConnectivity();
      if (connectivityResult == ConnectivityResult.none) {
        print('❌ Cannot sync files: No internet connection');
        return;
      }

      print('✅ Internet available, syncing offline files...');

      final syncResult = await OfflineFileUploadService.syncOfflineFiles();

      if (syncResult['success']) {
        print('✅ Offline files sync completed successfully');
        print('📊 - Synced: ${syncResult['synced']} files');
        print('📊 - Failed: ${syncResult['failed']} files');

        if (syncResult['synced'] > 0) {
          print(
            '🎉 Successfully synced ${syncResult['synced']} offline files to server!',
          );
        }
      } else {
        print('❌ Offline files sync failed: ${syncResult['message']}');
      }
    } catch (e) {
      print('❌ Error syncing offline files: $e');
    }
  }

  try {
    await Hive.openBox<ScamReportModel>('scam_reports');
  } catch (e) {
    print('🔄 Clearing scam_reports box due to schema mismatch: $e');
    await Hive.deleteBoxFromDisk('scam_reports');
    await Hive.openBox<ScamReportModel>('scam_reports');
  }

  try {
    await Hive.openBox<FraudReportModel>('fraud_reports');
  } catch (e) {
    print('🔄 Clearing fraud_reports box due to schema mismatch: $e');
    await Hive.deleteBoxFromDisk('fraud_reports');
    await Hive.openBox<FraudReportModel>('fraud_reports');
  }

  try {
    await Hive.openBox<MalwareReportModel>('malware_reports');
  } catch (e) {
    print('🔄 Clearing malware_reports box due to schema mismatch: $e');
    await Hive.deleteBoxFromDisk('malware_reports');
    await Hive.openBox<MalwareReportModel>('malware_reports');
  }

  // Check existing data - with error handling for schema mismatches
  Box<ScamReportModel>? scamBox;
  Box<FraudReportModel>? fraudBox;
  Box<MalwareReportModel>? malwareBox;

  try {
    scamBox = Hive.box<ScamReportModel>('scam_reports');
    fraudBox = Hive.box<FraudReportModel>('fraud_reports');
    malwareBox = Hive.box<MalwareReportModel>('malware_reports');
  } catch (e) {
    print('🚨 Critical schema mismatch detected. Clearing all boxes...');
    await Hive.deleteBoxFromDisk('scam_reports');
    await Hive.deleteBoxFromDisk('fraud_reports');
    await Hive.deleteBoxFromDisk('malware_reports');

    // Reopen boxes
    scamBox = await Hive.openBox<ScamReportModel>('scam_reports');
    fraudBox = await Hive.openBox<FraudReportModel>('fraud_reports');
    malwareBox = await Hive.openBox<MalwareReportModel>('malware_reports');
  }

  // Update existing reports with keycloakUserId
  await ReportUpdateService.updateAllExistingReports();

  // Initialize app version service
  await AppVersionService.initialize();

  // Test reference data availability (commented out to prevent startup issues)
  // await testReferenceData();

  // Test offline mode (commented out to prevent startup issues)
  // await testOfflineMode();

  // Cache reference data for offline use (only if online)
  try {
    final connectivityResult = await Connectivity().checkConnectivity();
    if (connectivityResult != ConnectivityResult.none) {
      print('🌐 Online - caching reference data for offline use...');
      await cacheReferenceDataForOffline();
    } else {
      print('📱 Offline - skipping reference data caching');
    }
  } catch (e) {
    print('❌ Error during reference data caching: $e');
  }

  // Test method of contact specifically
  print('📞 Testing method of contact cache specifically...');
  try {
    await OfflineCacheService.initialize();
    final methodOfContact = OfflineCacheService.getDropdown(
      'method-of-contact',
    );
    print('📞 Method of contact cache: ${methodOfContact.length} items');

    if (methodOfContact.isNotEmpty) {
      print('📞 Sample method of contact: ${methodOfContact.first['name']}');
    } else {
      print('⚠️ No method of contact data in cache, attempting to fetch...');
      try {
        final apiService = ApiService();
        final freshData = await apiService.fetchMethodOfContact();
        print('✅ Fresh method of contact data: ${freshData.length} items');

        // Test the cache again
        final updatedCache = OfflineCacheService.getDropdown(
          'method-of-contact',
        );
        print('📞 Updated cache: ${updatedCache.length} items');
      } catch (e) {
        print('❌ Error fetching fresh method of contact data: $e');
      }
    }
  } catch (e) {
    print('❌ Error testing method of contact cache: $e');
  }

  // Test manual sync process (commented out to prevent startup issues)
  // print('🧪 Testing manual sync process...');
  // try {
  //   // First, check if we have valid tokens
  //   await TokenStorage.diagnoseTokenStorage();
  //
  //   // Check if tokens are valid before attempting sync
  //   final accessToken = await TokenStorage.getAccessToken();
  //   final refreshToken = await TokenStorage.getRefreshToken();
  //
  //   if (refreshToken == null || refreshToken.isEmpty) {
  //     print('❌ CRITICAL: Refresh token is empty! Sync will fail.');
  //     print('💡 SOLUTION: You need to re-login to get fresh tokens.');
  //     print('🔄 Please log out and log back in, then try sync again.');
  //
  //     // Don't automatically clear tokens - let user handle login manually
  //     print('🔄 Skipping sync until user logs in.');
  //     return;
  //   }
  //
  //   if (accessToken == null || accessToken.isEmpty) {
  //     print('❌ CRITICAL: Access token is empty! Sync will fail.');
  //     print('💡 SOLUTION: You need to re-login to get fresh tokens.');
  //     print('🔄 Please log out and log back in, then try sync again.');
  //
  //     // Don't automatically clear tokens - let user handle login manually
  //     print('🔄 Skipping sync until user logs in.');
  //     return;
  //   }

  //   final scamLocalService = ScamLocalService();
  //   final stats = await scamLocalService.getSyncStats();

  //   if (stats['pending'] > 0) {
  //     print('🔄 Found ${stats['pending']} pending reports, testing sync...');

  //     // Try to sync all pending reports manually
  //     final scamSyncService = ScamSyncService();
  //     final syncResult = await scamSyncService.syncReports();

  //     print('📊 Manual sync result: ${syncResult['message']}');
  //     print(
  //       '📊 Synced: ${syncResult['syncedCount']}, Failed: ${syncResult['failedCount']}',
  //     );

  //     if (syncResult['failedCount'] > 0) {
  //       print('❌ Failed reports: ${syncResult['failedReports']}');
  //     }

  //     // Check final status
  //     final finalStats = await scamLocalService.getSyncStats();
  //     print(
  //       '📊 Final sync status: ${finalStats['total']} total, ${finalStats['pending']} pending, ${finalStats['synced']} synced',
  //     );
  //   } else {
  //     print('✅ No pending reports to sync');
  //   }
  // } catch (e) {
  //   print('❌ Error during manual sync test: $e');
  // }

  // Check pending reports status
  print('📋 Checking pending reports status...');
  try {
    final scamLocalService = ScamLocalService();
    final scamStats = await scamLocalService.getSyncStats();
    print(
      '📊 Scam reports: ${scamStats['total']} total, ${scamStats['pending']} pending, ${scamStats['synced']} synced',
    );

    if (scamStats['pending'] > 0) {
      print(
        '🔄 Found ${scamStats['pending']} pending scam reports that need sync',
      );
      final pendingReports = await scamLocalService.getPendingReports();
      for (int i = 0; i < pendingReports.length && i < 3; i++) {
        final report = pendingReports[i];
        print(
          '  - Pending: ${report.description?.substring(0, report.description!.length > 30 ? 30 : report.description!.length)}... (ID: ${report.id})',
        );
      }
      if (pendingReports.length > 3) {
        print('  ... and ${pendingReports.length - 3} more pending reports');
      }

      // Test manual sync for the first pending report
      if (pendingReports.isNotEmpty) {
        print('🧪 Testing manual sync for first pending report...');
        try {
          final firstReport = pendingReports.first;
          if (firstReport.id != null) {
            print('🧪 Attempting to sync report: ${firstReport.id}');

            // Use the enhanced sync service
            final scamSyncService = ScamSyncService();
            final result = await scamSyncService.syncSpecificReport(
              firstReport.id!,
            );

            if (result) {
              print(
                '✅ Manual sync test successful for report: ${firstReport.id}',
              );
            } else {
              print('❌ Manual sync test failed for report: ${firstReport.id}');
            }

            // Check status again
            final updatedStats = await scamLocalService.getSyncStats();
            print(
              '📊 Updated stats: ${updatedStats['total']} total, ${updatedStats['pending']} pending, ${updatedStats['synced']} synced',
            );
          } else {
            print(
              '⚠️ First pending report has no ID, skipping manual sync test',
            );
          }
        } catch (e) {
          print('❌ Error during manual sync test: $e');
        }
      }
    }
  } catch (e) {
    print('❌ Error checking pending reports: $e');
  }

  // DioService interceptors are automatically set up in the constructor
  // No need to call AuthApiService.setupInterceptors() anymore

  // Test the interceptor functionality
  try {
    await DioService().testInterceptor();
  } catch (e) {
    // Interceptor test failed
  }

  // NUCLEAR DUPLICATE REMOVAL - Clear everything and start fresh

  // TARGETED DUPLICATE REMOVAL - One time only on startup
  try {
    // Remove duplicates from local storage
    await ScamReportService.removeDuplicateScamReports();
    await FraudReportService.removeDuplicateFraudReports();

    // Remove duplicates from backend (only if online)
    final startupConnectivity = await Connectivity().checkConnectivity();
    if (startupConnectivity != ConnectivityResult.none) {
      await ApiService().removeDuplicateScamFraudReports();
    }
  } catch (e) {
    // Error during startup duplicate removal
  }

  // Initial sync if online
  final initialConnectivity = await Connectivity().checkConnectivity();
  if (initialConnectivity != ConnectivityResult.none) {
    print('🌐 Internet available on startup, prewarming reference data...');

    // CRITICAL: Prewarm reference data for offline use
    try {
      await ApiService().prewarmReferenceData();
      print('✅ Reference data prewarmed successfully');
    } catch (e) {
      print('❌ Error prewarming reference data: $e');
    }

    print('🌐 Internet available on startup, syncing reports...');
    try {
      await ScamReportService.syncReports();
      print('✅ Initial scam sync completed');
    } catch (e) {
      print('❌ Error syncing scam reports: $e');
    }

    try {
      await FraudReportService.syncReports();
      print('✅ Initial fraud sync completed');
    } catch (e) {
      print('❌ Error syncing fraud reports: $e');
    }

    try {
      await MalwareReportService.syncReports();
      print('✅ Initial malware sync completed');
    } catch (e) {
      print('❌ Error syncing malware reports: $e');
    }
  } else {
    print('📱 No internet on startup, will sync when connection restored');
  }

  // Set up periodic sync (every 30 minutes when online) - reduced frequency
  Timer.periodic(const Duration(minutes: 30), (timer) async {
    final connectivity = await Connectivity().checkConnectivity();
    if (connectivity != ConnectivityResult.none) {
      // Prewarm reference data periodically
      try {
        await ApiService().prewarmReferenceData();
        print('✅ Periodic reference data prewarm completed');
      } catch (e) {
        print('❌ Error during periodic reference data prewarm: $e');
      }

      try {
        await ScamReportService.syncReports();
      } catch (e) {
        // Error syncing scam reports
      }

      try {
        await FraudReportService.syncReports();
      } catch (e) {
        // Error syncing fraud reports
      }

      try {
        await MalwareReportService.syncReports();
      } catch (e) {
        // Error syncing malware reports
      }
    }
  });

  // Track if we've already cleaned up to prevent continuous execution
  bool hasCleanedUp = false;

  Connectivity().onConnectivityChanged.listen((result) async {
    print('🌐 Connectivity changed: $result');

    if (result != ConnectivityResult.none) {
      print('🌐 Internet connection available, prewarming reference data...');

      // CRITICAL: Prewarm reference data when internet is restored
      try {
        await ApiService().prewarmReferenceData();
        print('✅ Reference data prewarmed on connectivity restore');
      } catch (e) {
        print('❌ Error prewarming reference data on connectivity restore: $e');
      }

      print('🌐 Internet connection available, syncing reports...');

      try {
        print('🔄 Starting scam reports sync on connectivity change...');
        await ScamReportService.syncReports();
        print('✅ Scam sync on connectivity change completed');

        // Get sync statistics for detailed logging
        try {
          final scamLocalService = ScamLocalService();
          final stats = await scamLocalService.getSyncStats();
          print(
            '📊 Scam sync stats: ${stats['total']} total, ${stats['pending']} pending, ${stats['synced']} synced (${stats['syncPercentage']}%)',
          );
        } catch (e) {
          print('⚠️ Could not get sync stats: $e');
        }
      } catch (e) {
        print('❌ Error syncing scam reports on connectivity change: $e');
      }

      try {
        await FraudReportService.syncReports();
        print('✅ Fraud sync on connectivity change completed');
      } catch (e) {
        print('❌ Error syncing fraud reports on connectivity change: $e');
      }

      try {
        await MalwareReportService.syncReports();
        print('✅ Malware sync on connectivity change completed');
      } catch (e) {
        print('❌ Error syncing malware reports on connectivity change: $e');
      }

      // Sync offline files when internet is restored
      try {
        print('📁 Syncing offline files on connectivity restore...');
        final fileSyncResult =
            await OfflineFileUploadService.syncOfflineFiles();

        if (fileSyncResult['success']) {
          print(
            '✅ Offline files sync completed: ${fileSyncResult['synced']} synced, ${fileSyncResult['failed']} failed',
          );
        } else {
          print('❌ Offline files sync failed: ${fileSyncResult['message']}');
        }
      } catch (e) {
        print('❌ Error syncing offline files on connectivity change: $e');
      }
    } else {
      print('📱 Internet connection lost');
    }
  });

  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => AuthProvider()),
        ChangeNotifierProvider(create: (_) => DashboardProvider()),
        ChangeNotifierProvider(create: (_) => ScamReportProvider()),
      ],
      child: const MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      // home: const SplashScreen(),
      initialRoute: '/splashScreen',
      routes: {
        // Public routes (no authentication required)
        '/login': (context) => const PublicRoute(child: LoginPage()),

        // Protected routes (authentication required)
        '/': (context) => const AuthGuard(child: DashboardPage()),
        '/dashboard': (context) => const AuthGuard(child: DashboardPage()),
        '/profile': (context) => AuthGuard(child: ProfilePage()),
        '/thread': (context) => AuthGuard(
          child: ThreadDatabaseListPage(
            searchQuery: '',
            selectedTypes: [],
            selectedSeverities: [],
            selectedCategories: [],
            hasSearchQuery: false,
            hasSelectedType: false,
            hasSelectedSeverity: false,
            hasSelectedCategory: false,
            isOffline: false,
            localReports: [],
            severityLevels: [],
          ),
        ),
        '/filter': (context) => AuthGuard(child: ThreadDatabaseFilterPage()),
        '/subscription': (context) => AuthGuard(child: SubscriptionPlansPage()),
        '/rate': (context) => AuthGuard(child: Ratepage()),
        '/share': (context) => AuthGuard(child: Shareapp()),
        '/feedback': (context) => AuthGuard(child: Feedbackpage()),
        '/splashScreen': (context) => const SplashScreen(),
        '/scam-report': (context) =>
            AuthGuard(child: ReportScam1(categoryId: 'scam_category')),
        '/malware-report': (context) =>
            AuthGuard(child: ReportMalware1(categoryId: 'malware_category')),
        '/fraud-report': (context) =>
            AuthGuard(child: ReportFraudStep1(categoryId: 'fraud_category')),
      },
    );
  }
}

// AuthGuard system is now used instead of AuthWrapper
// The new AuthGuard widget handles all authentication logic

// import 'package:flutter/material.dart';
// import 'package:provider/provider.dart';
// import 'package:security_alert/provider/scam_report_provider.dart';
// import 'package:security_alert/screens/menu/feedbackPage.dart';
// import 'package:security_alert/screens/menu/profile_page.dart';
// import 'package:security_alert/screens/menu/ratepage.dart';
// import 'package:security_alert/screens/menu/shareApp.dart';
// import 'package:security_alert/screens/menu/theard_database.dart';
// import 'package:security_alert/screens/scam/scam_report_service.dart';
// import 'package:security_alert/screens/scam/report_scam_1.dart';
// import 'package:security_alert/screens/malware/report_malware_1.dart';
// import 'package:security_alert/screens/Fraud/ReportFraudStep1.dart';

// import 'package:security_alert/screens/subscriptionPage/subscription_plans_page.dart';

// import 'package:shared_preferences/shared_preferences.dart';
// import 'package:security_alert/provider/auth_provider.dart';
// import 'package:security_alert/provider/dashboard_provider.dart';
// import 'package:security_alert/screens/SplashScreen.dart';
// import 'package:security_alert/screens/dashboard_page.dart';
// import 'package:security_alert/screens/login.dart';
// import 'package:security_alert/services/biometric_service.dart';
// import 'package:hive_flutter/hive_flutter.dart';
// import 'package:connectivity_plus/connectivity_plus.dart';
// import 'dart:async';
// import 'models/scam_report_model.dart'; // ✅ Make sure this file contains: part 'scam_report_model.g.dart';
// import 'models/fraud_report_model.dart'; // at the top, if not already present
// import 'models/malware_report_model.dart';
// // import 'models/report_model.dart'; // not used directly
// import 'screens/Fraud/fraud_report_service.dart';
// import 'screens/malware/malware_report_service.dart';
// import 'services/report_update_service.dart';
// import 'services/app_version_service.dart';
// import 'services/api_service.dart';
// // import 'services/auth_api_service.dart'; // not used directly
// import 'services/dio_service.dart';
// import 'services/offline_cache_service.dart';
// import 'package:http/http.dart' as http;
// import 'config/api_config.dart';

// void main() async {
//   WidgetsFlutterBinding.ensureInitialized();
//   await Hive.initFlutter();

//   Hive.registerAdapter(ScamReportModelAdapter());
//   Hive.registerAdapter(FraudReportModelAdapter());
//   Hive.registerAdapter(MalwareReportModelAdapter());
//   // Hive.registerAdapter(ReportModelAdapter()); // Will be generated by build_runner

//   // Open Hive boxes with error handling for corrupted databases
//   print('📦 Opening Hive boxes...');
//   // Initialize lightweight offline cache box
//   try {
//     await OfflineCacheService.initialize();
//     print('✅ Offline cache initialized');
//   } catch (e) {
//     print('❌ Failed to initialize offline cache: $e');
//   }

//   try {
//     await Hive.openBox<ScamReportModel>('scam_reports');
//     print('✅ Scam reports box opened successfully');
//   } catch (e) {
//     print('❌ Error opening scam_reports box: $e');
//     print('🧹 Clearing corrupted scam_reports box...');
//     await Hive.deleteBoxFromDisk('scam_reports');
//     await Hive.openBox<ScamReportModel>('scam_reports');
//     print('✅ Scam reports box recreated successfully');
//   }

//   try {
//     await Hive.openBox<FraudReportModel>('fraud_reports');
//     print('✅ Fraud reports box opened successfully');
//   } catch (e) {
//     print('❌ Error opening fraud_reports box: $e');
//     print('🧹 Clearing corrupted fraud_reports box...');
//     await Hive.deleteBoxFromDisk('fraud_reports');
//     await Hive.openBox<FraudReportModel>('fraud_reports');
//     print('✅ Fraud reports box recreated successfully');
//   }

//   try {
//     await Hive.openBox<MalwareReportModel>('malware_reports');
//     print('✅ Malware reports box opened successfully');
//   } catch (e) {
//     print('❌ Error opening malware_reports box: $e');
//     print('🧹 Clearing corrupted malware_reports box...');
//     await Hive.deleteBoxFromDisk('malware_reports');
//     await Hive.openBox<MalwareReportModel>('malware_reports');
//     print('✅ Malware reports box recreated successfully');
//   }

//   // Check existing data
//   final scamBox = Hive.box<ScamReportModel>('scam_reports');
//   final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
//   final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

//   print('📊 Existing data on startup:');
//   print('📊 - Scam reports: ${scamBox.length}');
//   print('📊 - Fraud reports: ${fraudBox.length}');
//   print('📊 - Malware reports: ${malwareBox.length}');

//   // Update existing reports with keycloakUserId
//   await ReportUpdateService.updateAllExistingReports();

//   // // Initialize offline storage
//   // await OfflineStorageService.initialize();

//   // // Initialize connectivity monitoring
//   // await ConnectivityService().initialize();

//   // Initialize app version service
//   await AppVersionService.initialize();

//   // DioService interceptors are automatically set up in the constructor
//   // No need to call AuthApiService.setupInterceptors() anymore

//   // Test the interceptor functionality
//   print('🧪 Testing interceptor functionality...');
//   try {
//     await DioService().testInterceptor();
//   } catch (e) {
//     print('❌ Interceptor test failed: $e');
//   }

//   // NUCLEAR DUPLICATE REMOVAL - Clear everything and start fresh
//   print('☢️ NUCLEAR DUPLICATE CLEANUP ON APP STARTUP...');

//   // TEMPORARILY DISABLED - Clear all local data
//   // await ScamReportService.clearAllData();
//   // await FraudReportService.clearAllData();

//   // TARGETED DUPLICATE REMOVAL - One time only on startup
//   print('🔍 Running targeted duplicate removal on startup...');
//   try {
//     // Remove duplicates from local storage
//     await ScamReportService.removeDuplicateScamReports();
//     await FraudReportService.removeDuplicateFraudReports();

//     // Remove duplicates from backend (only if online)
//     final startupConnectivity = await Connectivity().checkConnectivity();
//     if (startupConnectivity != ConnectivityResult.none) {
//       await ApiService().removeDuplicateScamFraudReports();
//     }
//     print('✅ Startup duplicate removal completed');
//   } catch (e) {
//     print('❌ Error during startup duplicate removal: $e');
//   }

//   // Clear all backend data (only if online) - REMOVED TO PREVENT CONTINUOUS RUNNING
//   // final startupConnectivity = await Connectivity().checkConnectivity();
//   // if (startupConnectivity != ConnectivityResult.none) {
//   //   try {
//   //     await ApiService().clearAllBackendData();
//   //   } catch (e) {
//   //     print('❌ Error clearing backend data on startup: $e');
//   //     print('⚠️ Skipping backend cleanup due to connection issues');
//   //   }
//   // } else {
//   //   print('⚠️ Skipping backend cleanup - no internet connection');
//   // }

//   // Initial sync if online
//   final initialConnectivity = await Connectivity().checkConnectivity();
//   if (initialConnectivity != ConnectivityResult.none) {
//     // Prewarm reference data so offline forms mirror online lists
//     try {
//       await ApiService().prewarmReferenceData();
//     } catch (e) {
//       print('Prewarm error: $e');
//     }

//     print('Initial sync: Syncing reports on app start...');

//     try {
//       await ScamReportService.syncReports();
//       print('Initial sync: Scam reports synced');
//     } catch (e) {
//       print('Initial sync: Error syncing scam reports: $e');
//     }

//     try {
//       await FraudReportService.syncReports();
//       print('Initial sync: Fraud reports synced');
//     } catch (e) {
//       print('Initial sync: Error syncing fraud reports: $e');
//     }

//     try {
//       await MalwareReportService.syncReports();
//       print('Initial sync: Malware reports synced');
//     } catch (e) {
//       print('Initial sync: Error syncing malware reports: $e');
//     }
//   }

//   // Set up periodic sync (every 5 minutes when online) - more frequent for better sync
//   Timer.periodic(const Duration(minutes: 5), (timer) async {
//     final connectivity = await Connectivity().checkConnectivity();
//     if (connectivity != ConnectivityResult.none) {
//       print('🔄 Periodic sync: Checking for unsynced reports...');

//       try {
//         final scamBox = Hive.box<ScamReportModel>('scam_reports');
//         final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
//         final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

//         final unsyncedScam = scamBox.values
//             .where((r) => r.isSynced != true)
//             .length;
//         final unsyncedFraud = fraudBox.values
//             .where((r) => r.isSynced != true)
//             .length;
//         final unsyncedMalware = malwareBox.values
//             .where((r) => r.isSynced != true)
//             .length;

//         if (unsyncedScam > 0 || unsyncedFraud > 0 || unsyncedMalware > 0) {
//           print(
//             '🔄 Periodic sync: Found unsynced reports - Scam: $unsyncedScam, Fraud: $unsyncedFraud, Malware: $unsyncedMalware',
//           );

//           if (unsyncedScam > 0) {
//             await ScamReportService.syncReports();
//             print('✅ Periodic sync: Scam reports synced');
//           }

//           if (unsyncedFraud > 0) {
//             await FraudReportService.syncReports();
//             print('✅ Periodic sync: Fraud reports synced');
//           }

//           if (unsyncedMalware > 0) {
//             await MalwareReportService.syncReports();
//             print('✅ Periodic sync: Malware reports synced');
//           }
//         } else {
//           print('ℹ️ Periodic sync: No unsynced reports found');
//         }
//       } catch (e) {
//         print('❌ Periodic sync: Error during sync: $e');
//       }
//     } else {
//       print('📱 Periodic sync: No internet connection - skipping');
//     }
//   });

//   // Track if we've already cleaned up to prevent continuous execution
//   bool hasCleanedUp = false;

//   // Debug method to manually test sync
//   Future<void> testSync() async {
//     print('🧪 MANUAL SYNC TEST STARTED');

//     try {
//       final scamBox = Hive.box<ScamReportModel>('scam_reports');
//       final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
//       final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

//       print('📊 Current state:');
//       print('  - Scam reports: ${scamBox.length}');
//       print('  - Fraud reports: ${fraudBox.length}');
//       print('  - Malware reports: ${malwareBox.length}');

//       // Check unsynced reports before sync
//       final unsyncedScam = scamBox.values
//           .where((r) => r.isSynced != true)
//           .length;
//       final unsyncedFraud = fraudBox.values
//           .where((r) => r.isSynced != true)
//           .length;
//       final unsyncedMalware = malwareBox.values
//           .where((r) => r.isSynced != true)
//           .length;

//       print('📊 Unsynced reports before sync:');
//       print('  - Scam: $unsyncedScam');
//       print('  - Fraud: $unsyncedFraud');
//       print('  - Malware: $unsyncedMalware');

//       if (unsyncedScam > 0) {
//         print('🔄 Testing scam sync...');
//         await ScamReportService.syncReports();
//       }

//       if (unsyncedFraud > 0) {
//         print('🔄 Testing fraud sync...');
//         await FraudReportService.syncReports();
//       }

//       if (unsyncedMalware > 0) {
//         print('🔄 Testing malware sync...');
//         await MalwareReportService.syncReports();
//       }

//       // Check unsynced reports after sync
//       final unsyncedScamAfter = scamBox.values
//           .where((r) => r.isSynced != true)
//           .length;
//       final unsyncedFraudAfter = fraudBox.values
//           .where((r) => r.isSynced != true)
//           .length;
//       final unsyncedMalwareAfter = malwareBox.values
//           .where((r) => r.isSynced != true)
//           .length;

//       print('📊 Unsynced reports after sync:');
//       print('  - Scam: $unsyncedScamAfter');
//       print('  - Fraud: $unsyncedFraudAfter');
//       print('  - Malware: $unsyncedMalwareAfter');

//       print('✅ MANUAL SYNC TEST COMPLETED');
//     } catch (e) {
//       print('❌ Manual sync test failed: $e');
//     }
//   }

//   // Track previous connectivity state
//   ConnectivityResult? _previousConnectivity;

//   Connectivity().onConnectivityChanged.listen((result) async {
//     print('🌐 CONNECTIVITY CHANGE DETECTED: $result');
//     print('🌐 Previous connectivity: $_previousConnectivity');

//     // Check if we're coming back online
//     final wasOffline = _previousConnectivity == ConnectivityResult.none;
//     final isNowOnline = result != ConnectivityResult.none;

//     _previousConnectivity = result;

//     if (result == ConnectivityResult.none) {
//       print('📱 Going offline - no sync needed');
//       return;
//     }

//     if (wasOffline && isNowOnline) {
//       print('🌐 Internet connection restored, syncing reports...');
//       print('🔍 Connectivity result: $result');

//       // Debug: Check how many unsynced reports exist before sync
//       try {
//         final scamBox = Hive.box<ScamReportModel>('scam_reports');
//         final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
//         final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

//         final unsyncedScam = scamBox.values
//             .where((r) => r.isSynced != true)
//             .length;
//         final unsyncedFraud = fraudBox.values
//             .where((r) => r.isSynced != true)
//             .length;
//         final unsyncedMalware = malwareBox.values
//             .where((r) => r.isSynced != true)
//             .length;

//         print('📊 Before sync - Unsynced reports:');
//         print('  - Scam: $unsyncedScam');
//         print('  - Fraud: $unsyncedFraud');
//         print('  - Malware: $unsyncedMalware');

//         if (unsyncedScam == 0 && unsyncedFraud == 0 && unsyncedMalware == 0) {
//           print(
//             'ℹ️ No unsynced reports to sync - all reports are already synced',
//           );
//           return;
//         }
//       } catch (e) {
//         print('❌ Error checking unsynced reports: $e');
//       }

//       // Test API connectivity first
//       print('🔍 Testing API connectivity before sync...');
//       try {
//         final connectivity = await Connectivity().checkConnectivity();
//         print('🌐 Current connectivity: $connectivity');

//         // Test a simple API call
//         final testResponse = await http.get(
//           Uri.parse(
//             '${ApiConfig.mainBaseUrl}${ApiConfig.reportCategoryEndpoint}',
//           ),
//           headers: {'Accept': 'application/json'},
//         );
//         print('🔍 API test response status: ${testResponse.statusCode}');

//         if (testResponse.statusCode != 200) {
//           print('⚠️ API test failed - server might be down');
//         }
//       } catch (e) {
//         print('❌ API connectivity test failed: $e');
//       }

//       // Always sync when we come back online
//       print('🔄 Starting scam sync...');
//       try {
//         await ScamReportService.syncReports();
//         print('✅ Scam reports synced successfully');
//       } catch (e) {
//         print('❌ Error syncing scam reports: $e');
//         print('🔍 Scam sync error details: ${e.toString()}');
//       }

//       print('🔄 Starting fraud sync...');
//       try {
//         await FraudReportService.syncReports();
//         print('✅ Fraud reports synced successfully');
//       } catch (e) {
//         print('❌ Error syncing fraud reports: $e');
//         print('🔍 Fraud sync error details: ${e.toString()}');
//       }

//       print('🔄 Starting malware sync...');
//       try {
//         await MalwareReportService.syncReports();
//         print('✅ Malware reports synced successfully');
//       } catch (e) {
//         print('❌ Error syncing malware reports: $e');
//         print('🔍 Malware sync error details: ${e.toString()}');
//       }

//       // Debug: Check how many unsynced reports exist after sync
//       try {
//         final scamBox = Hive.box<ScamReportModel>('scam_reports');
//         final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
//         final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

//         final unsyncedScam = scamBox.values
//             .where((r) => r.isSynced != true)
//             .length;
//         final unsyncedFraud = fraudBox.values
//             .where((r) => r.isSynced != true)
//             .length;
//         final unsyncedMalware = malwareBox.values
//             .where((r) => r.isSynced != true)
//             .length;

//         print('📊 After sync - Unsynced reports:');
//         print('  - Scam: $unsyncedScam');
//         print('  - Fraud: $unsyncedFraud');
//         print('  - Malware: $unsyncedMalware');

//         final totalUnsynced = unsyncedScam + unsyncedFraud + unsyncedMalware;
//         if (totalUnsynced > 0) {
//           print('⚠️ Some reports still unsynced - sync may have failed');
//         } else {
//           print('✅ All reports successfully synced!');
//         }
//       } catch (e) {
//         print('❌ Error checking unsynced reports after sync: $e');
//       }

//       // Run heavier one-time cleanup only once per app session
//       if (!hasCleanedUp) {
//         hasCleanedUp = true;
//         // (Cleanup steps remain disabled/commented to avoid data loss.)

//         // Test sync on first connectivity restore
//         print('🧪 Running manual sync test on first connectivity restore...');
//         await testSync();
//       }
//     } else {
//       print(
//         'ℹ️ Connectivity changed but not from offline to online - skipping sync',
//       );
//     }
//   });

//   runApp(
//     MultiProvider(
//       providers: [
//         ChangeNotifierProvider(create: (_) => AuthProvider()),
//         ChangeNotifierProvider(create: (_) => DashboardProvider()),
//         ChangeNotifierProvider(create: (_) => ScamReportProvider()),
//       ],
//       child: const MyApp(),
//     ),
//   );
// }

// class MyApp extends StatelessWidget {
//   const MyApp({super.key});

//   @override
//   Widget build(BuildContext context) {
//     return MaterialApp(
//       debugShowCheckedModeBanner: false,
//       // home: const SplashScreen(),
//       initialRoute: '/',
//       routes: {
//         '/': (context) => const SplashScreen(),
//         '/profile': (context) => ProfilePage(),
//         '/thread': (context) => ThreadDatabaseFilterPage(),
//         '/subscription': (context) => SubscriptionPlansPage(),
//         '/rate': (context) => Ratepage(),
//         '/share': (context) => Shareapp(),
//         '/feedback': (context) => Feedbackpage(),
//         '/splashScreen': (context) => SplashScreen(),
//         '/scam-report': (context) => ReportScam1(categoryId: 'scam_category'),
//         '/malware-report': (context) =>
//             ReportMalware1(categoryId: 'malware_category'),
//         '/fraud-report': (context) =>
//             ReportFraudStep1(categoryId: 'fraud_category'),
//       },
//     );
//   }
// }

// class SplashToAuth extends StatefulWidget {
//   const SplashToAuth({super.key});

//   @override
//   State<SplashToAuth> createState() => _SplashToAuthState();
// }

// class _SplashToAuthState extends State<SplashToAuth> {
//   bool _showAuthWrapper = false;

//   @override
//   void initState() {
//     super.initState();
//     Future.delayed(const Duration(seconds: 2), () {
//       setState(() {
//         _showAuthWrapper = true;
//       });
//     });
//   }

//   @override
//   Widget build(BuildContext context) {
//     return _showAuthWrapper ? const AuthWrapper() : const SplashScreen();
//   }
// }

// class AuthWrapper extends StatefulWidget {
//   const AuthWrapper({super.key});

//   @override
//   State<AuthWrapper> createState() => _AuthWrapperState();
// }

// class _AuthWrapperState extends State<AuthWrapper> {
//   bool _authChecked = false;
//   bool _biometricChecked = false;
//   bool _biometricPassed = false;

//   @override
//   void initState() {
//     super.initState();
//     _initializeAuth();
//   }

//   Future<void> _initializeAuth() async {
//     try {
//       await Provider.of<AuthProvider>(context, listen: false).checkAuthStatus();
//       print(
//         'Auth status checked - User logged in: ${Provider.of<AuthProvider>(context, listen: false).isLoggedIn}',
//       );
//     } catch (e) {
//       print('Error checking auth status: $e');
//     }
//     setState(() {
//       _authChecked = true;
//     });
//   }

//   Future<void> _checkBiometrics(AuthProvider authProvider) async {
//     if (!_biometricChecked && authProvider.isLoggedIn) {
//       try {
//         final prefs = await SharedPreferences.getInstance();
//         final bioEnabled = prefs.getBool('biometric_enabled') ?? false;

//         if (bioEnabled) {
//           final isAvailable = await BiometricService.isBiometricAvailable();
//           if (isAvailable) {
//             _biometricChecked = true;
//             final passed = await BiometricService.authenticateWithBiometrics();
//             if (!passed) {
//               await authProvider.logout();
//             }
//             setState(() {
//               _biometricPassed = passed;
//             });
//           } else {
//             setState(() {
//               _biometricPassed = true;
//             });
//           }
//         } else {
//           setState(() {
//             _biometricPassed = true;
//           });
//         }
//       } catch (e) {
//         print('Biometric check error: $e');
//         setState(() {
//           _biometricPassed = true;
//         });
//       }
//     }
//   }

//   @override
//   Widget build(BuildContext context) {
//     return Consumer<AuthProvider>(
//       builder: (context, authProvider, child) {
//         print(
//           'AuthWrapper build - authChecked: $_authChecked, isLoading: ${authProvider.isLoading}, isLoggedIn: ${authProvider.isLoggedIn}',
//         );

//         if (!_authChecked || authProvider.isLoading) {
//           return const SplashScreen();
//         }

//         if (authProvider.isLoggedIn) {
//           print('User is logged in, checking biometrics...');
//           if (!_biometricChecked) {
//             _checkBiometrics(authProvider);
//             return const SplashScreen();
//           }

//           if (_biometricPassed) {
//             print('Biometric passed, navigating to dashboard');
//             return const DashboardPage();
//           } else {
//             print('Biometric failed, showing login page');
//             return const LoginPage();
//           }
//         }

//         print('User not logged in, showing login page');
//         return const LoginPage();
//       },
//     );
//   }
// }
