import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:security_alert/provider/scam_report_provider.dart';
import 'package:security_alert/screens/Due_diligence/Due_diligence1.dart';
import 'package:security_alert/screens/menu/feedbackPage.dart';
import 'package:security_alert/screens/menu/profile_page.dart';
import 'package:security_alert/screens/menu/ratepage.dart';
import 'package:security_alert/screens/menu/shareApp.dart';
import 'package:security_alert/screens/menu/theard_database.dart';
import 'package:security_alert/screens/Due_diligence/Due_diligence_view.dart';
import 'package:security_alert/screens/Due_diligence/Due_diligence_demo.dart';
import 'package:security_alert/screens/menu/thread_database_listpage.dart';
import 'package:security_alert/screens/scam/scam_report_service.dart';
import 'package:security_alert/screens/scam/report_scam_1.dart';
import 'package:security_alert/screens/malware/report_malware_1.dart';
import 'package:security_alert/screens/Fraud/ReportFraudStep1.dart';
import 'package:security_alert/widgets/auth_guard.dart';
import 'package:security_alert/screens/biometric_auth_screen.dart';

import 'package:security_alert/screens/subscriptionPage/subscription_plans_page.dart';

import 'package:security_alert/provider/auth_provider.dart';
import 'package:security_alert/provider/dashboard_provider.dart';
import 'package:security_alert/screens/SplashScreen.dart';
import 'package:security_alert/screens/dashboard_page.dart';
import 'package:security_alert/screens/login.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'dart:async';
import 'models/scam_report_model.dart'; // ‚úÖ Make sure this file contains: part 'scam_report_model.g.dart';
import 'models/fraud_report_model.dart'; // at the top, if not already present
import 'models/malware_report_model.dart';
import 'models/file_model.dart'; // Add FileModel import
import 'screens/Fraud/fraud_report_service.dart';
import 'screens/malware/malware_report_service.dart';
import 'services/report_update_service.dart';
import 'services/app_version_service.dart';
import 'services/api_service.dart';
import 'services/dio_service.dart';
import 'services/token_storage.dart';
import 'services/biometric_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Hive.initFlutter();

  // Note: Removed automatic token clearing on startup to preserve user sessions

  Hive.registerAdapter(ScamReportModelAdapter());
  Hive.registerAdapter(FraudReportModelAdapter());
  Hive.registerAdapter(MalwareReportModelAdapter());
  Hive.registerAdapter(FileModelAdapter()); // Add FileModelAdapter registration
  // Hive.registerAdapter(ReportModelAdapter()); // Will be generated by build_runner

  // Test token storage functionality
  print('üß™ Testing token storage...');
  try {
    await TokenStorage.testStorage();
    print('‚úÖ Token storage test passed');
  } catch (e) {
    print('‚ùå Token storage test failed: $e');
  }

  // Test biometric functionality
  print('üß™ Testing biometric functionality...');
  try {
    await BiometricService.testBiometric();
    print('‚úÖ Biometric test completed');
  } catch (e) {
    print('‚ùå Biometric test failed: $e');
  }

  // Open Hive boxes with error handling for corrupted databases

  try {
    await Hive.openBox<ScamReportModel>('scam_reports');
  } catch (e) {
    await Hive.deleteBoxFromDisk('scam_reports');
    await Hive.openBox<ScamReportModel>('scam_reports');
  }

  try {
    await Hive.openBox<FraudReportModel>('fraud_reports');
  } catch (e) {
    await Hive.deleteBoxFromDisk('fraud_reports');
    await Hive.openBox<FraudReportModel>('fraud_reports');
  }

  try {
    await Hive.openBox<MalwareReportModel>('malware_reports');
  } catch (e) {
    await Hive.deleteBoxFromDisk('malware_reports');
    await Hive.openBox<MalwareReportModel>('malware_reports');
  }

  // Check existing data
  final scamBox = Hive.box<ScamReportModel>('scam_reports');
  final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
  final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

  // Update existing reports with keycloakUserId
  await ReportUpdateService.updateAllExistingReports();

  // Initialize app version service
  await AppVersionService.initialize();

  // DioService interceptors are automatically set up in the constructor
  // No need to call AuthApiService.setupInterceptors() anymore

  // Test the interceptor functionality
  try {
    await DioService().testInterceptor();
  } catch (e) {
    // Interceptor test failed
  }

  // Check if user is authenticated before making API calls
  final accessToken = await TokenStorage.getAccessToken();
  final refreshToken = await TokenStorage.getRefreshToken();
  final hasValidTokens =
      (accessToken != null && accessToken.isNotEmpty) ||
      (refreshToken != null && refreshToken.isNotEmpty);

  if (hasValidTokens) {
    print(
      'üîê User has valid tokens, proceeding with authenticated operations...',
    );

    // NUCLEAR DUPLICATE REMOVAL - Clear everything and start fresh

    // TARGETED DUPLICATE REMOVAL - One time only on startup
    try {
      // Remove duplicates from local storage
      await ScamReportService.removeDuplicateScamReports();
      await FraudReportService.removeDuplicateFraudReports();

      // Remove duplicates from backend (only if online)
      final startupConnectivity = await Connectivity().checkConnectivity();
      if (startupConnectivity != ConnectivityResult.none) {
        await ApiService().removeDuplicateScamFraudReports();
      }
    } catch (e) {
      // Error during startup duplicate removal
    }

    // Initial sync if online
    final initialConnectivity = await Connectivity().checkConnectivity();
    if (initialConnectivity != ConnectivityResult.none) {
      try {
        await ScamReportService.syncReports();
      } catch (e) {
        // Error syncing scam reports
      }

      try {
        await FraudReportService.syncReports();
      } catch (e) {
        // Error syncing fraud reports
      }

      try {
        await MalwareReportService.syncReports();
      } catch (e) {
        // Error syncing malware reports
      }
    }

    // Set up periodic sync (every 30 minutes when online) - reduced frequency
    Timer.periodic(const Duration(minutes: 30), (timer) async {
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        try {
          await ScamReportService.syncReports();
        } catch (e) {
          // Error syncing scam reports
        }

        try {
          await FraudReportService.syncReports();
        } catch (e) {
          // Error syncing fraud reports
        }

        try {
          await MalwareReportService.syncReports();
        } catch (e) {
          // Error syncing malware reports
        }
      }
    });

    // Track if we've already cleaned up to prevent continuous execution
    bool hasCleanedUp = false;

    Connectivity().onConnectivityChanged.listen((result) async {
      if (result != ConnectivityResult.none && !hasCleanedUp) {
        hasCleanedUp = true; // Prevent multiple executions

        // Then sync reports
        try {
          await ScamReportService.syncReports();
        } catch (e) {
          // Error syncing scam reports
        }

        try {
          await FraudReportService.syncReports();
        } catch (e) {
          // Error syncing fraud reports
        }

        try {
          await MalwareReportService.syncReports();
        } catch (e) {
          // Error syncing malware reports
        }
      }
    });
  } else {
    print('üîê No valid tokens found, skipping authenticated operations...');
  }

  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => AuthProvider()),
        ChangeNotifierProvider(create: (_) => DashboardProvider()),
        ChangeNotifierProvider(create: (_) => ScamReportProvider()),
      ],
      child: const MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      // home: const SplashScreen(),
      initialRoute: '/splashScreen',
      routes: {
        // Public routes (no authentication required)
        '/login': (context) => const PublicRoute(child: LoginPage()),

        // Protected routes (authentication required)
        '/': (context) => const AuthGuard(child: DashboardPage()),
        '/dashboard': (context) => const AuthGuard(child: DashboardPage()),
        '/profile': (context) => AuthGuard(child: ProfilePage()),
        '/thread': (context) => AuthGuard(
          child: ThreadDatabaseListPage(
            searchQuery: '',
            selectedTypes: [],
            selectedSeverities: [],
            selectedCategories: [],
            hasSearchQuery: false,
            hasSelectedType: false,
            hasSelectedSeverity: false,
            hasSelectedCategory: false,
            isOffline: false,
            localReports: [],
            alertLevels: [],
          ),
        ),
        '/filter': (context) => AuthGuard(child: ThreadDatabaseFilterPage()),
        '/due-diligence': (context) => AuthGuard(child: DueDiligenceWrapper()),
        '/due-diligence-view': (context) {
          final args = ModalRoute.of(context)?.settings.arguments;
          final reportId = args as String?;
          return AuthGuard(child: DueDiligenceView(reportId: reportId));
        },
        '/due-diligence-demo': (context) =>
            AuthGuard(child: DueDiligenceDemo()),
        // '/subscription': (context) => AuthGuard(child: SubscriptionPlansPage()),
        '/rate': (context) => AuthGuard(child: Ratepage()),
        '/share': (context) => AuthGuard(child: Shareapp()),
        '/feedback': (context) => AuthGuard(child: Feedbackpage()),
        '/splashScreen': (context) => const SplashScreen(),
        '/biometric-auth': (context) => const BiometricAuthScreen(),
        '/scam-report': (context) =>
            AuthGuard(child: ReportScam1(categoryId: 'scam_category')),
        '/malware-report': (context) =>
            AuthGuard(child: ReportMalware1(categoryId: 'malware_category')),
        '/fraud-report': (context) =>
            AuthGuard(child: ReportFraudStep1(categoryId: 'fraud_category')),
      },
    );
  }
}

// AuthGuard system is now used instead of AuthWrapper
// The new AuthGuard widget handles all authentication logic

// import 'package:flutter/material.dart';
// import 'package:provider/provider.dart';
// import 'package:security_alert/provider/scam_report_provider.dart';
// import 'package:security_alert/screens/menu/feedbackPage.dart';
// import 'package:security_alert/screens/menu/profile_page.dart';
// import 'package:security_alert/screens/menu/ratepage.dart';
// import 'package:security_alert/screens/menu/shareApp.dart';
// import 'package:security_alert/screens/menu/theard_database.dart';
// import 'package:security_alert/screens/scam/scam_report_service.dart';
// import 'package:security_alert/screens/scam/report_scam_1.dart';
// import 'package:security_alert/screens/malware/report_malware_1.dart';
// import 'package:security_alert/screens/Fraud/ReportFraudStep1.dart';

// import 'package:security_alert/screens/subscriptionPage/subscription_plans_page.dart';

// import 'package:shared_preferences/shared_preferences.dart';
// import 'package:security_alert/provider/auth_provider.dart';
// import 'package:security_alert/provider/dashboard_provider.dart';
// import 'package:security_alert/screens/SplashScreen.dart';
// import 'package:security_alert/screens/dashboard_page.dart';
// import 'package:security_alert/screens/login.dart';
// import 'package:security_alert/services/biometric_service.dart';
// import 'package:hive_flutter/hive_flutter.dart';
// import 'package:connectivity_plus/connectivity_plus.dart';
// import 'dart:async';
// import 'models/scam_report_model.dart'; // ‚úÖ Make sure this file contains: part 'scam_report_model.g.dart';
// import 'models/fraud_report_model.dart'; // at the top, if not already present
// import 'models/malware_report_model.dart';
// // import 'models/report_model.dart'; // not used directly
// import 'screens/Fraud/fraud_report_service.dart';
// import 'screens/malware/malware_report_service.dart';
// import 'services/report_update_service.dart';
// import 'services/app_version_service.dart';
// import 'services/api_service.dart';
// // import 'services/auth_api_service.dart'; // not used directly
// import 'services/dio_service.dart';
// import 'services/offline_cache_service.dart';
// import 'package:http/http.dart' as http;
// import 'config/api_config.dart';

// void main() async {
//   WidgetsFlutterBinding.ensureInitialized();
//   await Hive.initFlutter();

//   Hive.registerAdapter(ScamReportModelAdapter());
//   Hive.registerAdapter(FraudReportModelAdapter());
//   Hive.registerAdapter(MalwareReportModelAdapter());
//   // Hive.registerAdapter(ReportModelAdapter()); // Will be generated by build_runner

//   // Open Hive boxes with error handling for corrupted databases
//   print('üì¶ Opening Hive boxes...');
//   // Initialize lightweight offline cache box
//   try {
//     await OfflineCacheService.initialize();
//     print('‚úÖ Offline cache initialized');
//   } catch (e) {
//     print('‚ùå Failed to initialize offline cache: $e');
//   }

//   try {
//     await Hive.openBox<ScamReportModel>('scam_reports');
//     print('‚úÖ Scam reports box opened successfully');
//   } catch (e) {
//     print('‚ùå Error opening scam_reports box: $e');
//     print('üßπ Clearing corrupted scam_reports box...');
//     await Hive.deleteBoxFromDisk('scam_reports');
//     await Hive.openBox<ScamReportModel>('scam_reports');
//     print('‚úÖ Scam reports box recreated successfully');
//   }

//   try {
//     await Hive.openBox<FraudReportModel>('fraud_reports');
//     print('‚úÖ Fraud reports box opened successfully');
//   } catch (e) {
//     print('‚ùå Error opening fraud_reports box: $e');
//     print('üßπ Clearing corrupted fraud_reports box...');
//     await Hive.deleteBoxFromDisk('fraud_reports');
//     await Hive.openBox<FraudReportModel>('fraud_reports');
//     print('‚úÖ Fraud reports box recreated successfully');
//   }

//   try {
//     await Hive.openBox<MalwareReportModel>('malware_reports');
//     print('‚úÖ Malware reports box opened successfully');
//   } catch (e) {
//     print('‚ùå Error opening malware_reports box: $e');
//     print('üßπ Clearing corrupted malware_reports box...');
//     await Hive.deleteBoxFromDisk('malware_reports');
//     await Hive.openBox<MalwareReportModel>('malware_reports');
//     print('‚úÖ Malware reports box recreated successfully');
//   }

//   // Check existing data
//   final scamBox = Hive.box<ScamReportModel>('scam_reports');
//   final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
//   final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

//   print('üìä Existing data on startup:');
//   print('üìä - Scam reports: ${scamBox.length}');
//   print('üìä - Fraud reports: ${fraudBox.length}');
//   print('üìä - Malware reports: ${malwareBox.length}');

//   // Update existing reports with keycloakUserId
//   await ReportUpdateService.updateAllExistingReports();

//   // // Initialize offline storage
//   // await OfflineStorageService.initialize();

//   // // Initialize connectivity monitoring
//   // await ConnectivityService().initialize();

//   // Initialize app version service
//   await AppVersionService.initialize();

//   // DioService interceptors are automatically set up in the constructor
//   // No need to call AuthApiService.setupInterceptors() anymore

//   // Test the interceptor functionality
//   print('üß™ Testing interceptor functionality...');
//   try {
//     await DioService().testInterceptor();
//   } catch (e) {
//     print('‚ùå Interceptor test failed: $e');
//   }

//   // NUCLEAR DUPLICATE REMOVAL - Clear everything and start fresh
//   print('‚ò¢Ô∏è NUCLEAR DUPLICATE CLEANUP ON APP STARTUP...');

//   // TEMPORARILY DISABLED - Clear all local data
//   // await ScamReportService.clearAllData();
//   // await FraudReportService.clearAllData();

//   // TARGETED DUPLICATE REMOVAL - One time only on startup
//   print('üîç Running targeted duplicate removal on startup...');
//   try {
//     // Remove duplicates from local storage
//     await ScamReportService.removeDuplicateScamReports();
//     await FraudReportService.removeDuplicateFraudReports();

//     // Remove duplicates from backend (only if online)
//     final startupConnectivity = await Connectivity().checkConnectivity();
//     if (startupConnectivity != ConnectivityResult.none) {
//       await ApiService().removeDuplicateScamFraudReports();
//     }
//     print('‚úÖ Startup duplicate removal completed');
//   } catch (e) {
//     print('‚ùå Error during startup duplicate removal: $e');
//   }

//   // Clear all backend data (only if online) - REMOVED TO PREVENT CONTINUOUS RUNNING
//   // final startupConnectivity = await Connectivity().checkConnectivity();
//   // if (startupConnectivity != ConnectivityResult.none) {
//   //   try {
//   //     await ApiService().clearAllBackendData();
//   //   } catch (e) {
//   //     print('‚ùå Error clearing backend data on startup: $e');
//   //     print('‚ö†Ô∏è Skipping backend cleanup due to connection issues');
//   //   }
//   // } else {
//   //   print('‚ö†Ô∏è Skipping backend cleanup - no internet connection');
//   // }

//   // Initial sync if online
//   final initialConnectivity = await Connectivity().checkConnectivity();
//   if (initialConnectivity != ConnectivityResult.none) {
//     // Prewarm reference data so offline forms mirror online lists
//     try {
//       await ApiService().prewarmReferenceData();
//     } catch (e) {
//       print('Prewarm error: $e');
//     }

//     print('Initial sync: Syncing reports on app start...');

//     try {
//       await ScamReportService.syncReports();
//       print('Initial sync: Scam reports synced');
//     } catch (e) {
//       print('Initial sync: Error syncing scam reports: $e');
//     }

//     try {
//       await FraudReportService.syncReports();
//       print('Initial sync: Fraud reports synced');
//     } catch (e) {
//       print('Initial sync: Error syncing fraud reports: $e');
//     }

//     try {
//       await MalwareReportService.syncReports();
//       print('Initial sync: Malware reports synced');
//     } catch (e) {
//       print('Initial sync: Error syncing malware reports: $e');
//     }
//   }

//   // Set up periodic sync (every 5 minutes when online) - more frequent for better sync
//   Timer.periodic(const Duration(minutes: 5), (timer) async {
//     final connectivity = await Connectivity().checkConnectivity();
//     if (connectivity != ConnectivityResult.none) {
//       print('üîÑ Periodic sync: Checking for unsynced reports...');

//       try {
//         final scamBox = Hive.box<ScamReportModel>('scam_reports');
//         final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
//         final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

//         final unsyncedScam = scamBox.values
//             .where((r) => r.isSynced != true)
//             .length;
//         final unsyncedFraud = fraudBox.values
//             .where((r) => r.isSynced != true)
//             .length;
//         final unsyncedMalware = malwareBox.values
//             .where((r) => r.isSynced != true)
//             .length;

//         if (unsyncedScam > 0 || unsyncedFraud > 0 || unsyncedMalware > 0) {
//           print(
//             'üîÑ Periodic sync: Found unsynced reports - Scam: $unsyncedScam, Fraud: $unsyncedFraud, Malware: $unsyncedMalware',
//           );

//           if (unsyncedScam > 0) {
//             await ScamReportService.syncReports();
//             print('‚úÖ Periodic sync: Scam reports synced');
//           }

//           if (unsyncedFraud > 0) {
//             await FraudReportService.syncReports();
//             print('‚úÖ Periodic sync: Fraud reports synced');
//           }

//           if (unsyncedMalware > 0) {
//             await MalwareReportService.syncReports();
//             print('‚úÖ Periodic sync: Malware reports synced');
//           }
//         } else {
//           print('‚ÑπÔ∏è Periodic sync: No unsynced reports found');
//         }
//       } catch (e) {
//         print('‚ùå Periodic sync: Error during sync: $e');
//       }
//     } else {
//       print('üì± Periodic sync: No internet connection - skipping');
//     }
//   });

//   // Track if we've already cleaned up to prevent continuous execution
//   bool hasCleanedUp = false;

//   // Debug method to manually test sync
//   Future<void> testSync() async {
//     print('üß™ MANUAL SYNC TEST STARTED');

//     try {
//       final scamBox = Hive.box<ScamReportModel>('scam_reports');
//       final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
//       final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

//       print('üìä Current state:');
//       print('  - Scam reports: ${scamBox.length}');
//       print('  - Fraud reports: ${fraudBox.length}');
//       print('  - Malware reports: ${malwareBox.length}');

//       // Check unsynced reports before sync
//       final unsyncedScam = scamBox.values
//           .where((r) => r.isSynced != true)
//           .length;
//       final unsyncedFraud = fraudBox.values
//           .where((r) => r.isSynced != true)
//           .length;
//       final unsyncedMalware = malwareBox.values
//           .where((r) => r.isSynced != true)
//           .length;

//       print('üìä Unsynced reports before sync:');
//       print('  - Scam: $unsyncedScam');
//       print('  - Fraud: $unsyncedFraud');
//       print('  - Malware: $unsyncedMalware');

//       if (unsyncedScam > 0) {
//         print('üîÑ Testing scam sync...');
//         await ScamReportService.syncReports();
//       }

//       if (unsyncedFraud > 0) {
//         print('üîÑ Testing fraud sync...');
//         await FraudReportService.syncReports();
//       }

//       if (unsyncedMalware > 0) {
//         print('üîÑ Testing malware sync...');
//         await MalwareReportService.syncReports();
//       }

//       // Check unsynced reports after sync
//       final unsyncedScamAfter = scamBox.values
//           .where((r) => r.isSynced != true)
//           .length;
//       final unsyncedFraudAfter = fraudBox.values
//           .where((r) => r.isSynced != true)
//           .length;
//       final unsyncedMalwareAfter = malwareBox.values
//           .where((r) => r.isSynced != true)
//           .length;

//       print('üìä Unsynced reports after sync:');
//       print('  - Scam: $unsyncedScamAfter');
//       print('  - Fraud: $unsyncedFraudAfter');
//       print('  - Malware: $unsyncedMalwareAfter');

//       print('‚úÖ MANUAL SYNC TEST COMPLETED');
//     } catch (e) {
//       print('‚ùå Manual sync test failed: $e');
//     }
//   }

//   // Track previous connectivity state
//   ConnectivityResult? _previousConnectivity;

//   Connectivity().onConnectivityChanged.listen((result) async {
//     print('üåê CONNECTIVITY CHANGE DETECTED: $result');
//     print('üåê Previous connectivity: $_previousConnectivity');

//     // Check if we're coming back online
//     final wasOffline = _previousConnectivity == ConnectivityResult.none;
//     final isNowOnline = result != ConnectivityResult.none;

//     _previousConnectivity = result;

//     if (result == ConnectivityResult.none) {
//       print('üì± Going offline - no sync needed');
//       return;
//     }

//     if (wasOffline && isNowOnline) {
//       print('üåê Internet connection restored, syncing reports...');
//       print('üîç Connectivity result: $result');

//       // Debug: Check how many unsynced reports exist before sync
//       try {
//         final scamBox = Hive.box<ScamReportModel>('scam_reports');
//         final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
//         final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

//         final unsyncedScam = scamBox.values
//             .where((r) => r.isSynced != true)
//             .length;
//         final unsyncedFraud = fraudBox.values
//             .where((r) => r.isSynced != true)
//             .length;
//         final unsyncedMalware = malwareBox.values
//             .where((r) => r.isSynced != true)
//             .length;

//         print('üìä Before sync - Unsynced reports:');
//         print('  - Scam: $unsyncedScam');
//         print('  - Fraud: $unsyncedFraud');
//         print('  - Malware: $unsyncedMalware');

//         if (unsyncedScam == 0 && unsyncedFraud == 0 && unsyncedMalware == 0) {
//           print(
//             '‚ÑπÔ∏è No unsynced reports to sync - all reports are already synced',
//           );
//           return;
//         }
//       } catch (e) {
//         print('‚ùå Error checking unsynced reports: $e');
//       }

//       // Test API connectivity first
//       print('üîç Testing API connectivity before sync...');
//       try {
//         final connectivity = await Connectivity().checkConnectivity();
//         print('üåê Current connectivity: $connectivity');

//         // Test a simple API call
//         final testResponse = await http.get(
//           Uri.parse(
//             '${ApiConfig.mainBaseUrl}${ApiConfig.reportCategoryEndpoint}',
//           ),
//           headers: {'Accept': 'application/json'},
//         );
//         print('üîç API test response status: ${testResponse.statusCode}');

//         if (testResponse.statusCode != 200) {
//           print('‚ö†Ô∏è API test failed - server might be down');
//         }
//       } catch (e) {
//         print('‚ùå API connectivity test failed: $e');
//       }

//       // Always sync when we come back online
//       print('üîÑ Starting scam sync...');
//       try {
//         await ScamReportService.syncReports();
//         print('‚úÖ Scam reports synced successfully');
//       } catch (e) {
//         print('‚ùå Error syncing scam reports: $e');
//         print('üîç Scam sync error details: ${e.toString()}');
//       }

//       print('üîÑ Starting fraud sync...');
//       try {
//         await FraudReportService.syncReports();
//         print('‚úÖ Fraud reports synced successfully');
//       } catch (e) {
//         print('‚ùå Error syncing fraud reports: $e');
//         print('üîç Fraud sync error details: ${e.toString()}');
//       }

//       print('üîÑ Starting malware sync...');
//       try {
//         await MalwareReportService.syncReports();
//         print('‚úÖ Malware reports synced successfully');
//       } catch (e) {
//         print('‚ùå Error syncing malware reports: $e');
//         print('üîç Malware sync error details: ${e.toString()}');
//       }

//       // Debug: Check how many unsynced reports exist after sync
//       try {
//         final scamBox = Hive.box<ScamReportModel>('scam_reports');
//         final fraudBox = Hive.box<FraudReportModel>('fraud_reports');
//         final malwareBox = Hive.box<MalwareReportModel>('malware_reports');

//         final unsyncedScam = scamBox.values
//             .where((r) => r.isSynced != true)
//             .length;
//         final unsyncedFraud = fraudBox.values
//             .where((r) => r.isSynced != true)
//             .length;
//         final unsyncedMalware = malwareBox.values
//             .where((r) => r.isSynced != true)
//             .length;

//         print('üìä After sync - Unsynced reports:');
//         print('  - Scam: $unsyncedScam');
//         print('  - Fraud: $unsyncedFraud');
//         print('  - Malware: $unsyncedMalware');

//         final totalUnsynced = unsyncedScam + unsyncedFraud + unsyncedMalware;
//         if (totalUnsynced > 0) {
//           print('‚ö†Ô∏è Some reports still unsynced - sync may have failed');
//         } else {
//           print('‚úÖ All reports successfully synced!');
//         }
//       } catch (e) {
//         print('‚ùå Error checking unsynced reports after sync: $e');
//       }

//       // Run heavier one-time cleanup only once per app session
//       if (!hasCleanedUp) {
//         hasCleanedUp = true;
//         // (Cleanup steps remain disabled/commented to avoid data loss.)

//         // Test sync on first connectivity restore
//         print('üß™ Running manual sync test on first connectivity restore...');
//         await testSync();
//       }
//     } else {
//       print(
//         '‚ÑπÔ∏è Connectivity changed but not from offline to online - skipping sync',
//       );
//     }
//   });

//   runApp(
//     MultiProvider(
//       providers: [
//         ChangeNotifierProvider(create: (_) => AuthProvider()),
//         ChangeNotifierProvider(create: (_) => DashboardProvider()),
//         ChangeNotifierProvider(create: (_) => ScamReportProvider()),
//       ],
//       child: const MyApp(),
//     ),
//   );
// }

// class MyApp extends StatelessWidget {
//   const MyApp({super.key});

//   @override
//   Widget build(BuildContext context) {
//     return MaterialApp(
//       debugShowCheckedModeBanner: false,
//       // home: const SplashScreen(),
//       initialRoute: '/',
//       routes: {
//         '/': (context) => const SplashScreen(),
//         '/profile': (context) => ProfilePage(),
//         '/thread': (context) => ThreadDatabaseFilterPage(),
//         '/subscription': (context) => SubscriptionPlansPage(),
//         '/rate': (context) => Ratepage(),
//         '/share': (context) => Shareapp(),
//         '/feedback': (context) => Feedbackpage(),
//         '/splashScreen': (context) => SplashScreen(),
//         '/scam-report': (context) => ReportScam1(categoryId: 'scam_category'),
//         '/malware-report': (context) =>
//             ReportMalware1(categoryId: 'malware_category'),
//         '/fraud-report': (context) =>
//             ReportFraudStep1(categoryId: 'fraud_category'),
//       },
//     );
//   }
// }

// class SplashToAuth extends StatefulWidget {
//   const SplashToAuth({super.key});

//   @override
//   State<SplashToAuth> createState() => _SplashToAuthState();
// }

// class _SplashToAuthState extends State<SplashToAuth> {
//   bool _showAuthWrapper = false;

//   @override
//   void initState() {
//     super.initState();
//     Future.delayed(const Duration(seconds: 2), () {
//       setState(() {
//         _showAuthWrapper = true;
//       });
//     });
//   }

//   @override
//   Widget build(BuildContext context) {
//     return _showAuthWrapper ? const AuthWrapper() : const SplashScreen();
//   }
// }

// class AuthWrapper extends StatefulWidget {
//   const AuthWrapper({super.key});

//   @override
//   State<AuthWrapper> createState() => _AuthWrapperState();
// }

// class _AuthWrapperState extends State<AuthWrapper> {
//   bool _authChecked = false;
//   bool _biometricChecked = false;
//   bool _biometricPassed = false;

//   @override
//   void initState() {
//     super.initState();
//     _initializeAuth();
//   }

//   Future<void> _initializeAuth() async {
//     try {
//       await Provider.of<AuthProvider>(context, listen: false).checkAuthStatus();
//       print(
//         'Auth status checked - User logged in: ${Provider.of<AuthProvider>(context, listen: false).isLoggedIn}',
//       );
//     } catch (e) {
//       print('Error checking auth status: $e');
//     }
//     setState(() {
//       _authChecked = true;
//     });
//   }

//   Future<void> _checkBiometrics(AuthProvider authProvider) async {
//     if (!_biometricChecked && authProvider.isLoggedIn) {
//       try {
//         final prefs = await SharedPreferences.getInstance();
//         final bioEnabled = prefs.getBool('biometric_enabled') ?? false;

//         if (bioEnabled) {
//           final isAvailable = await BiometricService.isBiometricAvailable();
//           if (isAvailable) {
//             _biometricChecked = true;
//             final passed = await BiometricService.authenticateWithBiometrics();
//             if (!passed) {
//               await authProvider.logout();
//             }
//             setState(() {
//               _biometricPassed = passed;
//             });
//           } else {
//             setState(() {
//               _biometricPassed = true;
//             });
//           }
//         } else {
//           setState(() {
//             _biometricPassed = true;
//           });
//         }
//       } catch (e) {
//         print('Biometric check error: $e');
//         setState(() {
//           _biometricPassed = true;
//         });
//       }
//     }
//   }

//   @override
//   Widget build(BuildContext context) {
//     return Consumer<AuthProvider>(
//       builder: (context, authProvider, child) {
//         print(
//           'AuthWrapper build - authChecked: $_authChecked, isLoading: ${authProvider.isLoading}, isLoggedIn: ${authProvider.isLoggedIn}',
//         );

//         if (!_authChecked || authProvider.isLoading) {
//           return const SplashScreen();
//         }

//         if (authProvider.isLoggedIn) {
//           print('User is logged in, checking biometrics...');
//           if (!_biometricChecked) {
//             _checkBiometrics(authProvider);
//             return const SplashScreen();
//           }

//           if (_biometricPassed) {
//             print('Biometric passed, navigating to dashboard');
//             return const DashboardPage();
//           } else {
//             print('Biometric failed, showing login page');
//             return const LoginPage();
//           }
//         }

//         print('User not logged in, showing login page');
//         return const LoginPage();
//       },
//     );
//   }
// }
