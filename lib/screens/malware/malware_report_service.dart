import 'package:hive/hive.dart';
import 'dart:convert';
import 'dart:io';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';
import 'package:http/http.dart' as http;
import 'package:dio/dio.dart';
import 'package:dio/dio.dart' show FormData, MultipartFile;

import '../../models/malware_report_model.dart';
import '../../config/api_config.dart';
import '../../services/api_service.dart';
import '../../services/jwt_service.dart';
import '../../services/malware_reference_service.dart';
import '../../services/dio_service.dart';
import '../../services/location_storage_service.dart';
import '../../custom/offline_file_upload.dart' as custom;

class MalwareReportService {
  static final _box = Hive.box<MalwareReportModel>('malware_reports');
  static final ApiService _apiService = ApiService();

  // Handle app restart and refresh existing duplicates
  static Future<void> handleAppRestart() async {
    print('üöÄ Handling app restart for malware reports...');

    // Step 1: Clean up any existing duplicates
    await cleanDuplicates();

    // Step 2: Fix any null IDs or corrupted data
    await _fixCorruptedData();

    // Step 3: Final verification
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final finalCount = box.length;

    print('‚úÖ App restart handling completed. Final report count: $finalCount');
  }

  // Store files offline for malware reports
  static Future<Map<String, dynamic>> storeFilesOffline({
    required String reportId,
    required List<File> screenshots,
    required List<File> documents,
    required List<File> voiceMessages,
    required List<File> videofiles,
  }) async {
    try {
      print(
        'üìÅ MalwareReportService: Storing files offline for report $reportId',
      );

      final result =
          await custom.OfflineFileUploadService.storeMultipleFilesOffline(
            reportId: reportId,
            reportType: 'malware',
            screenshots: screenshots,
            documents: documents,
            voiceMessages: voiceMessages,
            videofiles: videofiles,
          );

      print('‚úÖ MalwareReportService: Files stored offline successfully');
      return result;
    } catch (e) {
      print('‚ùå MalwareReportService: Error storing files offline: $e');
      return {'success': false, 'message': 'Failed to store files offline: $e'};
    }
  }

  // Fix corrupted data and null IDs
  static Future<void> _fixCorruptedData() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final allReports = box.values.toList();
    final fixedReports = <MalwareReportModel>[];

    print('üîß Fixing corrupted data and null IDs...');

    for (var report in allReports) {
      var fixedReport = report;

      // Fix null IDs
      if (report.id == null || report.id!.isEmpty) {
        final newId = DateTime.now().millisecondsSinceEpoch.toString();
        fixedReport = report.copyWith(id: newId);
        print('üîß Fixed null ID: ${report.name} -> $newId');
      }

      // Fix null timestamps
      if (report.date == null) {
        fixedReport = fixedReport.copyWith(date: DateTime.now().toUtc());
        print('üîß Fixed null date: ${report.name}');
      }

      fixedReports.add(fixedReport);
    }

    // Update the box with fixed reports
    if (fixedReports.length == allReports.length) {
      await box.clear();
      for (var report in fixedReports) {
        await box.put(report.id, report);
      }
      print('‚úÖ Fixed ${fixedReports.length} reports');
    }
  }

  static Future<void> saveReport(MalwareReportModel report) async {
    // Get current user ID from JWT token
    final keycloakUserId = await JwtService.getCurrentUserId();

    // Run diagnostics if no user ID found (device-specific issue)
    if (keycloakUserId == null) {
      await JwtService.diagnoseTokenStorage();
    }

    if (keycloakUserId != null) {
      report = report.copyWith(keycloackUserId: keycloakUserId);
    } else {
      // Fallback for device-specific issues
      report = report.copyWith(
        keycloackUserId: 'device_user_${DateTime.now().millisecondsSinceEpoch}',
      );
    }

    // Ensure unique timestamp for each report
    final now = DateTime.now().toUtc(); // Use UTC time consistently
    report = report.copyWith(date: now);

    // Check for duplicates BEFORE saving to prevent duplicates when creating reports
    final isDuplicate = await checkForDuplicateBeforeSaving(report);
    if (isDuplicate) {
      print('‚ö†Ô∏è Duplicate malware report detected - skipping save');
      print('‚ö†Ô∏è This prevents duplicates when creating reports');
      return;
    }

    // Check connectivity FIRST to determine online vs offline approach
    final connectivity = await Connectivity().checkConnectivity();

    if (connectivity != ConnectivityResult.none) {
      // ONLINE MODE: Direct server sync first, then local backup
      print('üåê ONLINE MODE: Direct server sync for malware report...');

      try {
        // Initialize reference service before syncing
        await MalwareReferenceService.initialize();

        // Send to server FIRST (preserves evidence)
        bool success = await sendToBackend(report);

        if (success) {
          // Server sync successful - the report object is already updated with server data
          // No need to save again as sendToBackend already updated the local database
          print(
            '‚úÖ ONLINE MODE: Malware report synced directly with server, evidence preserved',
          );
        } else {
          // Server sync failed - fall back to offline mode
          print(
            '‚ö†Ô∏è ONLINE MODE: Server sync failed, falling back to offline mode',
          );
          await saveReportOffline(report);
        }
      } catch (e) {
        print(
          '‚ùå ONLINE MODE: Server sync error, falling back to offline mode: $e',
        );
        await saveReportOffline(report);
      }
    } else {
      // OFFLINE MODE: Save locally first, then sync later
      print('üì± OFFLINE MODE: Saving malware report locally for later sync...');
      await saveReportOffline(report);
    }

    // Remove duplicates immediately after saving
    await removeDuplicateReports();
  }

  static Future<void> saveReportOffline(MalwareReportModel report) async {
    // Get current user ID from JWT token
    final keycloakUserId = await JwtService.getCurrentUserId();
    if (keycloakUserId != null) {
      report = report.copyWith(keycloackUserId: keycloakUserId);
    }

    // Check for duplicates BEFORE saving
    final isDuplicate = await checkForExactDuplicate(report);
    if (isDuplicate) {
      print('‚ö†Ô∏è Duplicate malware report detected - skipping save');
      return;
    }

    print('Saving malware report to local storage: ${report.toJson()}');
    await _box.add(report);

    // Handle offline file uploads for this report
    await _handleOfflineFileUploads(report);

    // AUTOMATIC DUPLICATE CLEANUP after saving (like scam/fraud)
    print('üßπ Auto-cleaning duplicates after saving new malware report...');
    await cleanDuplicates();
  }

  static Future<void> syncReports() async {
    final connectivity = await Connectivity().checkConnectivity();
    if (connectivity == ConnectivityResult.none) {
      print('üì± No internet connection, skipping malware sync');
      return;
    }

    print('üîÑ Starting malware reports sync...');

    // AUTOMATIC DUPLICATE CLEANUP BEFORE SYNC
    print('üßπ Automatic duplicate cleanup before malware sync...');
    await cleanDuplicates();

    try {
      final pendingReports = _box.values
          .where((report) => !report.isSynced)
          .toList();
      print(
        'üìã Found ${pendingReports.length} pending malware reports to sync',
      );

      int syncedCount = 0;
      int failedCount = 0;

      for (final report in pendingReports) {
        try {
          print('üîÑ Syncing malware report: ${report.id}');
          final success = await sendToBackend(report);

          if (success) {
            syncedCount++;
            print('‚úÖ Malware report ${report.id} synced successfully');
          } else {
            failedCount++;
            print('‚ùå Failed to sync malware report ${report.id}');
          }
        } catch (e) {
          failedCount++;
          print('‚ùå Error syncing malware report ${report.id}: $e');
        }
      }

      print('üìä Malware sync summary:');
      print('üìä - Total pending: ${pendingReports.length}');
      print('üìä - Synced: $syncedCount');
      print('üìä - Failed: $failedCount');

      // AUTOMATIC DUPLICATE CLEANUP AFTER SYNC
      print('üßπ Automatic duplicate cleanup after malware sync...');
      await cleanDuplicates();
    } catch (e) {
      print('‚ùå Error during malware sync: $e');
    }
  }

  static Future<bool> sendToBackend(MalwareReportModel report) async {
    try {
      print('üîÑ Sending malware report to backend...');
      print('üìã Report data: ${report.toJson()}');

      // Get dynamic ObjectIds for missing fields
      final deviceTypeId = report.deviceTypeId?.isNotEmpty == true
          ? report.deviceTypeId!
          : await _getDynamicDeviceTypeId();
      final detectTypeId = report.detectTypeId?.isNotEmpty == true
          ? report.detectTypeId!
          : await _getDynamicDetectionTypeId();
      final operatingSystemId = report.operatingSystemName?.isNotEmpty == true
          ? report.operatingSystemName!
          : await _getDynamicOperatingSystemId();

      // Remove local-only fields from payload
      final reportData = report.toJson();
      reportData.remove('isSynced'); // Remove local-only field

      // Add missing fields dynamically - ONLY if they are valid ObjectIds
      if (deviceTypeId.isNotEmpty &&
          deviceTypeId.length == 24 &&
          RegExp(r'^[0-9a-fA-F]{24}$').hasMatch(deviceTypeId)) {
        reportData['deviceTypeId'] = deviceTypeId;
        print('‚úÖ Added valid deviceTypeId ObjectId: $deviceTypeId');
      } else {
        print(
          '‚ö†Ô∏è Skipping invalid deviceTypeId: $deviceTypeId (not a valid ObjectId)',
        );
        reportData.remove('deviceTypeId'); // Remove invalid field
      }

      if (detectTypeId.isNotEmpty &&
          detectTypeId.length == 24 &&
          RegExp(r'^[0-9a-fA-F]{24}$').hasMatch(detectTypeId)) {
        reportData['detectTypeId'] = detectTypeId;
        print('‚úÖ Added valid detectTypeId ObjectId: $detectTypeId');
      } else {
        print(
          '‚ö†Ô∏è Skipping invalid detectTypeId: $detectTypeId (not a valid ObjectId)',
        );
        reportData.remove('detectTypeId'); // Remove invalid field
      }

      if (operatingSystemId.isNotEmpty &&
          operatingSystemId.length == 24 &&
          RegExp(r'^[0-9a-fA-F]{24}$').hasMatch(operatingSystemId)) {
        reportData['operatingSystemName'] = operatingSystemId;
        print('‚úÖ Added valid operatingSystemName ObjectId: $operatingSystemId');
      } else {
        print(
          '‚ö†Ô∏è Skipping invalid operatingSystemName: $operatingSystemId (not a valid ObjectId)',
        );
        reportData.remove('operatingSystemName'); // Remove invalid field
      }

      // Ensure keycloackUserId is set
      if (reportData['keycloackUserId'] == null ||
          reportData['keycloackUserId'] == '') {
        final keycloakUserId = await JwtService.getCurrentUserId();
        if (keycloakUserId != null) {
          reportData['keycloackUserId'] = keycloakUserId;
          print('‚úÖ Added keycloackUserId: $keycloakUserId');
        }
      }

      // Get the best available location for this malware report
      final bestLocation = await _getBestAvailableLocation();
      reportData['location'] = bestLocation;
      print('üìç Malware report: Using location: ${bestLocation['address']}');

      // Remove old location field if it exists
      if (reportData['locationCoordinates'] != null) {
        reportData.remove('locationCoordinates');
      }

      // CRITICAL FIX: Upload files to server and replace local paths with server URLs
      if (reportData['screenshots'] != null &&
          reportData['screenshots'].isNotEmpty) {
        print('üìÅ Uploading screenshots to server...');
        final screenshotUrls = await _uploadFilesToServer(
          reportData['screenshots'],
          'screenshot',
          report.id!,
        );
        reportData['screenshots'] = screenshotUrls;
        print('‚úÖ Screenshots uploaded: $screenshotUrls');
      }

      if (reportData['documents'] != null &&
          reportData['documents'].isNotEmpty) {
        print('üìÅ Uploading documents to server...');
        final documentUrls = await _uploadFilesToServer(
          reportData['documents'],
          'document',
          report.id!,
        );
        reportData['documents'] = documentUrls;
        print('‚úÖ Documents uploaded: $documentUrls');
      }

      if (reportData['videofiles'] != null &&
          reportData['videofiles'].isNotEmpty) {
        print('üìÅ Uploading video files to server...');
        final videoUrls = await _uploadFilesToServer(
          reportData['videofiles'],
          'video',
          report.id!,
        );
        reportData['videofiles'] = videoUrls;
        print('‚úÖ Video files uploaded: $videoUrls');
      }

      if (reportData['voiceMessages'] != null &&
          reportData['voiceMessages'].isNotEmpty) {
        print('üìÅ Uploading voice messages to server...');
        final voiceUrls = await _uploadFilesToServer(
          reportData['voiceMessages'],
          'audio',
          report.id!,
        );
        reportData['voiceMessages'] = voiceUrls;
        print('‚úÖ Voice messages uploaded: $voiceUrls');
      }

      print('üì§ Sending payload: $reportData');

      // Use dioService for authenticated requests
      final dioService = DioService();
      final dioResponse = await dioService.reportsPost(
        ApiConfig.reportSecurityIssueEndpoint,
        data: reportData,
      );

      print('üì• Response status: ${dioResponse.statusCode}');
      print('üì• Response body: ${dioResponse.data}');

      if (dioResponse.statusCode == 200 || dioResponse.statusCode == 201) {
        // Parse server response to get _id and timestamps
        final responseData = dioResponse.data;
        final serverId = responseData['_id'] ?? responseData['id'];
        final serverCreatedAt = responseData['createdAt'];
        final serverUpdatedAt = responseData['updatedAt'];

        print('‚úÖ Malware report synced successfully');
        print('üÜî Server ID: $serverId');
        print('üìÖ Server createdAt: $serverCreatedAt');
        print('üìÖ Server updatedAt: $serverUpdatedAt');

        // CRITICAL FIX: Update the report with server data AND server URLs for evidence files
        // The server URLs are in reportData from the file upload process
        final updated = report.copyWith(
          id: serverId,
          date: serverCreatedAt != null
              ? DateTime.parse(serverCreatedAt)
              : report.date,
          isSynced: true,
          // CRITICAL: Use server URLs from reportData, not local paths
          // These URLs were returned from the file upload process
          screenshots:
              (reportData['screenshots'] as List?)
                  ?.map((e) => e.toString())
                  .toList() ??
              [],
          documents:
              (reportData['documents'] as List?)
                  ?.map((e) => e.toString())
                  .toList() ??
              [],
          videofiles:
              (reportData['videofiles'] as List?)
                  ?.map((e) => e.toString())
                  .toList() ??
              [],
          voiceMessages:
              (reportData['voiceMessages'] as List?)
                  ?.map((e) => e.toString())
                  .toList() ??
              [],
        );

        // Re-key the report in Hive to match server ID
        final previousLocalId = report.id;
        final targetKey = updated.id ?? previousLocalId;

        // Delete old record and add new one with server ID
        if (previousLocalId != targetKey) {
          await _box.delete(previousLocalId);
          print(
            'üîÅ Re-keyed local malware report from $previousLocalId to ${updated.id}',
          );
        }

        await _box.put(targetKey, updated);

        // AUTOMATIC BACKEND DUPLICATE CLEANUP after successful sync (like scam/fraud)
        try {
          print(
            'üßπ Cleaning backend duplicates after successful malware sync...',
          );
          await _apiService.removeDuplicateMalwareReports();
        } catch (e) {
          print('‚ö†Ô∏è Error cleaning backend duplicates: $e');
        }

        return true;
      } else {
        print('‚ùå Failed to sync malware report: ${dioResponse.statusCode}');
        print('‚ùå Response data: ${dioResponse.data}');
        return false;
      }
    } catch (e) {
      print('‚ùå Error sending malware report to backend: $e');
      if (e is DioException) {
        print('‚ùå DioException response: ${e.response?.data}');
        print('‚ùå DioException status: ${e.response?.statusCode}');
        print('‚ùå DioException message: ${e.message}');
      }
      return false;
    }
  }

  // Upload files to server and return URLs
  static Future<List<String>> _uploadFilesToServer(
    List<String> filePaths,
    String fileType,
    String reportId,
  ) async {
    List<String> uploadedUrls = [];

    for (String filePath in filePaths) {
      try {
        final file = File(filePath);
        if (await file.exists()) {
          // Create FormData for file upload
          final formData = FormData.fromMap({
            'file': await MultipartFile.fromFile(
              filePath,
              filename: file.path.split('/').last,
            ),
            'fileType': fileType,
            'description': 'Uploaded from offline storage',
          });

          // Upload to server
          // Use the same URL format as the working file upload
          final dioService = DioService();
          final uploadUrl =
              '${ApiConfig.fileUploadBaseUrl}/file-upload/threads-malware?reportId=$reportId';
          print('üîÑ Uploading file to URL: $uploadUrl');

          final response = await dioService.reportsPost(
            uploadUrl,
            data: formData,
          );

          if (response.statusCode == 200 || response.statusCode == 201) {
            final serverUrl = response.data['url'] ?? response.data['fileUrl'];
            if (serverUrl != null) {
              uploadedUrls.add(serverUrl);
              print('‚úÖ File uploaded successfully: $filePath -> $serverUrl');
            }
          } else {
            print(
              '‚ùå File upload failed: $filePath (Status: ${response.statusCode})',
            );
          }
        } else {
          print('‚ùå File not found: $filePath');
        }
      } catch (e) {
        print('‚ùå Error uploading file $filePath: $e');
      }
    }

    return uploadedUrls;
  }

  static Future<void> updateReport(MalwareReportModel report) async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.put(report.id, report);
  }

  // Get the best available location for offline malware reports
  static Future<Map<String, dynamic>> _getBestAvailableLocation() async {
    try {
      // Step 1: Try to get current location (if online and location services available)
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        try {
          // Check if location services are enabled
          bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
          if (serviceEnabled) {
            // Check location permission
            LocationPermission permission = await Geolocator.checkPermission();
            if (permission == LocationPermission.denied) {
              permission = await Geolocator.requestPermission();
            }

            if (permission == LocationPermission.whileInUse ||
                permission == LocationPermission.always) {
              // Get current position
              Position position = await Geolocator.getCurrentPosition(
                desiredAccuracy: LocationAccuracy.high,
                timeLimit: const Duration(seconds: 10),
              );

              print(
                '‚úÖ Malware report: Got current location: ${position.latitude}, ${position.longitude}',
              );

              // Try to get address from coordinates
              String address = '${position.latitude}, ${position.longitude}';
              try {
                List<Placemark> placemarks = await placemarkFromCoordinates(
                  position.latitude,
                  position.longitude,
                );

                if (placemarks.isNotEmpty) {
                  Placemark placemark = placemarks[0];
                  address = [
                    placemark.street,
                    placemark.subLocality,
                    placemark.locality,
                    placemark.administrativeArea,
                    placemark.country,
                  ].where((e) => e != null && e.isNotEmpty).join(', ');
                }
              } catch (e) {
                print(
                  '‚ö†Ô∏è Malware report: Could not get address from coordinates: $e',
                );
              }

              // Save this location for future offline use
              await LocationStorageService.saveLastSelectedAddress(
                label: 'Current Location',
                address: address,
              );

              return {
                'type': 'Point',
                'coordinates': [
                  position.longitude,
                  position.latitude,
                ], // [lng, lat] format
                'address': address,
              };
            }
          }
        } catch (e) {
          print('‚ö†Ô∏è Malware report: Could not get current location: $e');
        }
      }

      // Step 2: Try to get last saved location
      final lastLocation =
          await LocationStorageService.getLastSelectedAddress();
      if (lastLocation != null && lastLocation['address']!.isNotEmpty) {
        print(
          '‚úÖ Malware report: Using last saved location: ${lastLocation['address']}',
        );
        return {
          'type': 'Point',
          'coordinates': [79.8114, 11.9416], // Default coordinates
          'address': lastLocation['address']!,
        };
      }

      // Step 3: Use default location as final fallback
      print(
        '‚ö†Ô∏è Malware report: Using default location (no saved location available)',
      );
      return {
        'type': 'Point',
        'coordinates': [79.8114, 11.9416], // Default coordinates
        'address': 'Default Location',
      };
    } catch (e) {
      print('‚ùå Malware report: Error getting location: $e');
      // Final fallback
      return {
        'type': 'Point',
        'coordinates': [79.8114, 11.9416],
        'address': 'Default Location',
      };
    }
  }

  // Dynamic methods to get ObjectIds from reference service
  static Future<String> _getDynamicReportCategoryId(String categoryName) async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getMalwareReportCategoryId();
    } catch (e) {
      return '';
    }
  }

  static Future<String> _getDynamicReportTypeId(String typeName) async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getMalwareReportTypeId();
    } catch (e) {
      return '';
    }
  }

  static Future<String> _getDynamicDeviceTypeId() async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getDeviceTypeId(
        'desktop',
      ); // Default to desktop
    } catch (e) {
      return '';
    }
  }

  static Future<String> _getDynamicDetectionTypeId() async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getDetectionTypeId(
        'antivirus',
      ); // Default to antivirus
    } catch (e) {
      return '';
    }
  }

  static Future<String> _getDynamicOperatingSystemId() async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getOperatingSystemId(
        'windows',
      ); // Default to windows
    } catch (e) {
      return '';
    }
  }

  static List<MalwareReportModel> getLocalReports() {
    final reports = _box.values.toList();
    return reports;
  }

  static Future<void> updateExistingReportsWithKeycloakUserId() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();

    for (int i = 0; i < reports.length; i++) {
      final report = reports[i];
      if (report.keycloackUserId == null) {
        final keycloakUserId = await JwtService.getCurrentUserId();
        if (keycloakUserId != null) {
          final updatedReport = report.copyWith(
            keycloackUserId: keycloakUserId,
          );
          final key = box.keyAt(i);
          await box.put(key, updatedReport);
        }
      }
    }
  }

  // MALWARE DUPLICATE CLEANUP - Following scam/fraud pattern
  static Future<void> cleanDuplicates() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final allReports = box.values.toList();
    final uniqueReports = <MalwareReportModel>[];
    final seenKeys = <String>{};

    print('üßπ MALWARE DUPLICATE CLEANUP STARTING...');
    print('üìä Total reports to check: ${allReports.length}');

    for (var report in allReports) {
      // More comprehensive key including all relevant fields (following scam/fraud pattern)
      final key =
          '${report.name}_${report.malwareType}_${report.fileName}_${report.description}_${report.infectedDeviceType}_${report.operatingSystem}_${report.detectionMethod}_${report.location}_${report.systemAffected}_${report.alertSeverityLevel}_${report.reportTypeId}_${report.reportCategoryId}_${report.createdAt?.millisecondsSinceEpoch}';

      if (!seenKeys.contains(key)) {
        seenKeys.add(key);
        uniqueReports.add(report);
        print(
          '‚úÖ Keeping malware report: ${report.name} - ${report.malwareType} - ${report.infectedDeviceType}',
        );
      } else {
        print(
          'üóëÔ∏è Removing duplicate malware report: ${report.name} - ${report.malwareType} - ${report.infectedDeviceType}',
        );
      }
    }

    if (uniqueReports.length < allReports.length) {
      print(
        'üßπ Cleaning up ${allReports.length - uniqueReports.length} duplicate malware reports',
      );
      await box.clear();
      for (var report in uniqueReports) {
        await box.add(report);
      }
    } else {
      print('‚úÖ No duplicates found in malware reports');
    }

    final remainingReports = box.values.toList();
    print(
      '‚úÖ Malware duplicate cleanup completed. Remaining reports: ${remainingReports.length}',
    );
  }

  // Enhanced method to prevent duplicates when creating offline data using serverId
  static Future<bool> checkForDuplicateBeforeSaving(
    MalwareReportModel newReport,
  ) async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final existingReports = box.values.toList();

    print('üõ°Ô∏è Checking for duplicates before saving new malware report...');
    print('üõ°Ô∏è New report name: ${newReport.name}');

    for (var existingReport in existingReports) {
      // Check if this is a synced report with serverId
      if (existingReport.isSynced == true &&
          existingReport.id != null &&
          existingReport.id!.length == 24) {
        // For synced reports, check if the new report has the same serverId
        if (newReport.id == existingReport.id) {
          print(
            '‚ùå DUPLICATE DETECTED: New report has same serverId as existing synced report',
          );
          print(
            '‚ùå Existing: ${existingReport.name} (ServerID: ${existingReport.id})',
          );
          print('‚ùå New: ${newReport.name} (ServerID: ${newReport.id})');
          return true; // Duplicate found
        }
      }

      // Check for content-based duplicates (for unsynced reports)
      // Only consider it a duplicate if ALL key fields match exactly
      if (existingReport.isSynced != true) {
        // Check if this is a true duplicate by comparing essential fields
        final nameMatch = existingReport.name == newReport.name;
        final malwareTypeMatch =
            existingReport.malwareType == newReport.malwareType;
        final fileNameMatch = existingReport.fileName == newReport.fileName;
        final descriptionMatch =
            existingReport.description == newReport.description;
        final infectedDeviceTypeMatch =
            existingReport.infectedDeviceType == newReport.infectedDeviceType;
        final operatingSystemMatch =
            existingReport.operatingSystem == newReport.operatingSystem;
        final detectionMethodMatch =
            existingReport.detectionMethod == newReport.detectionMethod;
        final locationMatch = existingReport.location == newReport.location;
        final systemAffectedMatch =
            existingReport.systemAffected == newReport.systemAffected;
        final alertSeverityLevelMatch =
            existingReport.alertSeverityLevel == newReport.alertSeverityLevel;

        // Only consider it a duplicate if ALL these fields match exactly
        // This allows for legitimate variations in evidence, etc.
        if (nameMatch &&
            malwareTypeMatch &&
            fileNameMatch &&
            descriptionMatch &&
            infectedDeviceTypeMatch &&
            operatingSystemMatch &&
            detectionMethodMatch &&
            locationMatch &&
            systemAffectedMatch &&
            alertSeverityLevelMatch) {
          // Additional check: if they were created within a very short time window (5 minutes)
          // and have identical content, it's likely a duplicate
          final timeDifference =
              (existingReport.date
                  ?.difference(newReport.date ?? DateTime.now())
                  ?.abs() ??
              Duration.zero);
          if (timeDifference.inMinutes < 5) {
            print(
              '‚ùå CONTENT DUPLICATE DETECTED: New report has same content as existing unsynced report',
            );
            print(
              '‚ùå Existing: ${existingReport.name} (Created: ${existingReport.date})',
            );
            print('‚ùå New: ${newReport.name} (Created: ${newReport.date})');
            print('‚ùå Time difference: ${timeDifference.inMinutes} minutes');
            return true; // Duplicate found
          } else {
            print(
              '‚ö†Ô∏è Similar content found but time difference is ${timeDifference.inMinutes} minutes - allowing save',
            );
          }
        }
      }
    }

    print('‚úÖ No duplicates detected - safe to save new malware report');
    return false; // No duplicates found
  }

  static Future<void> removeDuplicateReports() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final seenContent = <String>{};
    final seenServerIds = <String>{};
    final toDelete = <int>[];

    print('üßπ MALWARE DUPLICATE REMOVAL STARTING...');
    print('üìä Total reports to check: ${reports.length}');

    for (int i = 0; i < reports.length; i++) {
      final report = reports[i];

      // For synced reports, use server ID as primary identifier
      if (report.isSynced == true &&
          report.id != null &&
          report.id!.length == 24) {
        // This is a synced report with valid server ID
        if (seenServerIds.contains(report.id)) {
          toDelete.add(i);
          print(
            '‚ùå DUPLICATE SYNCED REPORT FOUND: ${report.name} (ID: ${report.id})',
          );
        } else {
          seenServerIds.add(report.id!);
          print('‚úÖ KEEPING SYNCED: ${report.name} (ID: ${report.id})');
        }
        continue; // Skip content-based check for synced reports
      }

      // For unsynced reports, use content-based detection
      final name = report.name?.toString().toLowerCase().trim() ?? '';
      final malwareType =
          report.malwareType?.toString().toLowerCase().trim() ?? '';
      final fileName = report.fileName?.toString().toLowerCase().trim() ?? '';
      final description =
          report.description?.toString().toLowerCase().trim() ?? '';
      final infectedDeviceType =
          report.infectedDeviceType?.toString().toLowerCase().trim() ?? '';
      final operatingSystem =
          report.operatingSystem?.toString().toLowerCase().trim() ?? '';
      final detectionMethod =
          report.detectionMethod?.toString().toLowerCase().trim() ?? '';
      final location = report.location?.toString().toLowerCase().trim() ?? '';
      final systemAffected =
          report.systemAffected?.toString().toLowerCase().trim() ?? '';
      final alertSeverityLevel =
          report.alertSeverityLevel?.toString().toLowerCase().trim() ?? '';

      final contentKey =
          '${name}_${malwareType}_${fileName}_${description}_${infectedDeviceType}_${operatingSystem}_${detectionMethod}_${location}_${systemAffected}_${alertSeverityLevel}';

      if (seenContent.contains(contentKey)) {
        toDelete.add(i);
        print(
          '‚ùå DUPLICATE UNSYNCED REPORT FOUND: ${report.name} (${report.malwareType}) - ${report.infectedDeviceType} - ${report.location}',
        );
      } else {
        seenContent.add(contentKey);
        print(
          '‚úÖ KEEPING UNSYNCED: ${report.name} (${report.malwareType}) - ${report.infectedDeviceType} - ${report.location}',
        );
      }
    }

    print('üßπ Found ${toDelete.length} duplicates to remove');

    // Delete duplicates in reverse order to maintain indices
    for (int i = toDelete.length - 1; i >= 0; i--) {
      final key = box.keyAt(toDelete[i]);
      await box.delete(key);
      print('üóëÔ∏è Deleted duplicate at index ${toDelete[i]}');
    }

    final remainingReports = box.values.toList();
    print(
      '‚úÖ Duplicate removal completed. Remaining reports: ${remainingReports.length}',
    );
  }

  // AGGRESSIVE malware duplicate removal - specifically for synced reports
  static Future<void> removeMalwareDuplicatesAggressively() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();

    print('üßπ AGGRESSIVE MALWARE DUPLICATE REMOVAL STARTING...');
    print('üìä Total malware reports: ${reports.length}');

    // Separate synced and unsynced reports
    final syncedReports = <String, MalwareReportModel>{};
    final unsyncedReports = <String, MalwareReportModel>{};
    final toDelete = <String>[];

    for (final report in reports) {
      if (report.isSynced == true &&
          report.id != null &&
          report.id!.length == 24) {
        // Synced report - use server ID
        if (syncedReports.containsKey(report.id)) {
          toDelete.add(report.id!);
          print('‚ùå DUPLICATE SYNCED: ${report.name} (ID: ${report.id})');
        } else {
          syncedReports[report.id!] = report;
          print('‚úÖ KEEPING SYNCED: ${report.name} (ID: ${report.id})');
        }
      } else {
        // Unsynced report - use content-based key
        final contentKey = _createContentKey(report);
        if (unsyncedReports.containsKey(contentKey)) {
          toDelete.add(report.id ?? '');
          print('‚ùå DUPLICATE UNSYNCED: ${report.name} (Content: $contentKey)');
        } else {
          unsyncedReports[contentKey] = report;
          print('‚úÖ KEEPING UNSYNCED: ${report.name} (Content: $contentKey)');
        }
      }
    }

    // Delete duplicates
    for (final key in toDelete) {
      if (key.isNotEmpty) {
        await box.delete(key);
        print('üóëÔ∏è Deleted duplicate: $key');
      }
    }

    final remainingReports = box.values.toList();
    print('‚úÖ AGGRESSIVE MALWARE DUPLICATE REMOVAL COMPLETED');
    print('üìä Remaining reports: ${remainingReports.length}');
    print('üìä - Synced: ${syncedReports.length}');
    print('üìä - Unsynced: ${unsyncedReports.length}');
  }

  // Helper method to create content key for unsynced reports
  static String _createContentKey(MalwareReportModel report) {
    final name = report.name?.toString().toLowerCase().trim() ?? '';
    final malwareType =
        report.malwareType?.toString().toLowerCase().trim() ?? '';
    final fileName = report.fileName?.toString().toLowerCase().trim() ?? '';
    final description =
        report.description?.toString().toLowerCase().trim() ?? '';
    final infectedDeviceType =
        report.infectedDeviceType?.toString().toLowerCase().trim() ?? '';
    final operatingSystem =
        report.operatingSystem?.toString().toLowerCase().trim() ?? '';
    final detectionMethod =
        report.detectionMethod?.toString().toLowerCase().trim() ?? '';
    final location = report.location?.toString().toLowerCase().trim() ?? '';
    final systemAffected =
        report.systemAffected?.toString().toLowerCase().trim() ?? '';
    final alertSeverityLevel =
        report.alertSeverityLevel?.toString().toLowerCase().trim() ?? '';

    return '${name}_${malwareType}_${fileName}_${description}_${infectedDeviceType}_${operatingSystem}_${detectionMethod}_${location}_${systemAffected}_${alertSeverityLevel}';
  }

  // STRICT duplicate check - Check for exact duplicates before saving
  static Future<bool> checkForExactDuplicate(
    MalwareReportModel newReport,
  ) async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final existingReports = box.values.toList();

    print(
      'üîç STRICT DUPLICATE CHECK: ${newReport.name} (${newReport.malwareType})',
    );

    for (final existingReport in existingReports) {
      // Skip synced reports when checking for duplicates of new reports
      if (existingReport.isSynced == true &&
          existingReport.id != null &&
          existingReport.id!.length == 24) {
        print(
          '‚è≠Ô∏è Skipping synced report ${existingReport.id} during duplicate check',
        );
        continue;
      }

      // Check for comprehensive match using all relevant fields
      if (existingReport.name?.toString().toLowerCase().trim() ==
              newReport.name?.toString().toLowerCase().trim() &&
          existingReport.malwareType?.toString().toLowerCase().trim() ==
              newReport.malwareType?.toString().toLowerCase().trim() &&
          existingReport.fileName?.toString().toLowerCase().trim() ==
              newReport.fileName?.toString().toLowerCase().trim() &&
          existingReport.description?.toString().toLowerCase().trim() ==
              newReport.description?.toString().toLowerCase().trim() &&
          existingReport.infectedDeviceType?.toString().toLowerCase().trim() ==
              newReport.infectedDeviceType?.toString().toLowerCase().trim() &&
          existingReport.operatingSystem?.toString().toLowerCase().trim() ==
              newReport.operatingSystem?.toString().toLowerCase().trim() &&
          existingReport.detectionMethod?.toString().toLowerCase().trim() ==
              newReport.detectionMethod?.toString().toLowerCase().trim() &&
          existingReport.location?.toString().toLowerCase().trim() ==
              newReport.location?.toString().toLowerCase().trim() &&
          existingReport.systemAffected?.toString().toLowerCase().trim() ==
              newReport.systemAffected?.toString().toLowerCase().trim() &&
          existingReport.alertSeverityLevel?.toString().toLowerCase().trim() ==
              newReport.alertSeverityLevel?.toString().toLowerCase().trim()) {
        print(
          '‚ùå EXACT DUPLICATE FOUND: ${newReport.name} (${newReport.malwareType}) - ${newReport.infectedDeviceType} - ${newReport.location}',
        );
        return true;
      }
    }

    print(
      '‚úÖ NO EXACT DUPLICATE: ${newReport.name} (${newReport.malwareType}) - ${newReport.infectedDeviceType} - ${newReport.location}',
    );
    return false;
  }

  // Convert payload format to MalwareReportModel
  static MalwareReportModel fromPayload(Map<String, dynamic> payload) {
    return MalwareReportModel(
      id: payload['id'] ?? DateTime.now().millisecondsSinceEpoch.toString(),
      malwareType: payload['attackName'] ?? 'Unknown Malware',
      infectedDeviceType: payload['deviceTypeId'] ?? 'Unknown Device',
      operatingSystem: payload['attackSystem'] ?? 'Unknown OS',
      detectionMethod: payload['detectTypeId'] ?? 'Unknown Detection',
      location: _extractLocationString(payload['location']),
      fileName: payload['attackName'] ?? 'Unknown File',
      name: payload['attackName'] ?? 'Unknown Attack',
      systemAffected: payload['attackSystem'] ?? 'Unknown System',
      alertSeverityLevel: payload['alertLevels'] ?? 'Medium',
      date: DateTime.now(),
      isSynced: false,
      keycloackUserId: payload['keycloackUserId'],
      reportCategoryId: payload['reportCategoryId'],
      reportTypeId: payload['reportTypeId'],
      alertLevels: payload['alertLevels'],
      deviceTypeId: payload['deviceTypeId'],
      detectTypeId: payload['detectTypeId'],
      operatingSystemName: payload['operatingSystemName'],
      attackName: payload['attackName'],
      attackSystem: payload['attackSystem'],
      createdBy: payload['createdBy'],
      // Removed status field
      description: payload['description'],
      incidentDate: payload['incidentDate'] != null
          ? DateTime.parse(payload['incidentDate'])
          : null,
      reportOutcome: payload['reportOutcome'],
      locationCoordinates: payload['location'],
      screenshots: payload['screenshots'] ?? [],
      voiceMessages: payload['voiceMessages'] ?? [],
      documents: payload['documents'] ?? [],
    );
  }

  // Helper function to extract location string from coordinates
  static String _extractLocationString(dynamic location) {
    if (location is Map<String, dynamic>) {
      if (location['coordinates'] is List &&
          location['coordinates'].length >= 2) {
        final lat = location['coordinates'][1];
        final lng = location['coordinates'][0];
        return '$lat, $lng';
      }
    }
    return 'Unknown Location';
  }

  // Create malware report from payload and save
  static Future<void> createFromPayload(Map<String, dynamic> payload) async {
    try {
      // Convert payload to model
      final report = fromPayload(payload);

      // Check for duplicates before saving
      final isDuplicate = await checkForExactDuplicate(report);
      if (isDuplicate) {
        return;
      }

      // Save the report
      await saveReport(report);
    } catch (e) {
      print('‚ùå Error creating malware report from payload: $e');
    }
  }

  // Update existing malware report with payload
  static Future<void> updateFromPayload(
    String reportId,
    Map<String, dynamic> payload,
  ) async {
    try {
      final box = Hive.box<MalwareReportModel>('malware_reports');
      final existingReport = box.get(reportId);

      if (existingReport == null) {
        return;
      }

      // Update the report with new payload data
      final updatedReport = existingReport.copyWith(
        reportCategoryId: payload['reportCategoryId'],
        reportTypeId: payload['reportTypeId'],
        alertLevels: payload['alertLevels'],
        deviceTypeId: payload['deviceTypeId'],
        detectTypeId: payload['detectTypeId'],
        operatingSystemName: payload['operatingSystemName'],
        attackName: payload['attackName'],
        attackSystem: payload['attackSystem'],

        description: payload['description'],
        incidentDate: payload['incidentDate'] != null
            ? DateTime.parse(payload['incidentDate'])
            : null,
        reportOutcome: payload['reportOutcome'],
        locationCoordinates: payload['location'],
        screenshots: payload['screenshots'] ?? [],
        voiceMessages: payload['voiceMessages'] ?? [],
        documents: payload['documents'] ?? [],
      );

      // Save updated report
      await box.put(reportId, updatedReport);

      // Try to sync with backend
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        final success = await sendToBackend(updatedReport);
        if (success) {
          final syncedReport = updatedReport.copyWith(isSynced: true);
          await box.put(reportId, syncedReport);
        }
      }
    } catch (e) {
      print('‚ùå Error updating malware report from payload: $e');
    }
  }

  // Malware-specific update method using your exact payload format
  static Future<void> updateMalwareWithPayload(
    Map<String, dynamic> malwarePayload,
  ) async {
    try {
      // Extract the report ID from payload or generate one
      String reportId =
          malwarePayload['id'] ??
          DateTime.now().millisecondsSinceEpoch.toString();

      // Create or update the malware report
      final box = Hive.box<MalwareReportModel>('malware_reports');

      // Check if report exists
      final existingReport = box.get(reportId);

      if (existingReport != null) {
        // Update existing report
        final updatedReport = existingReport.copyWith(
          reportCategoryId: malwarePayload['reportCategoryId'],
          reportTypeId: malwarePayload['reportTypeId'],
          alertLevels: malwarePayload['alertLevels'],
          keycloackUserId: malwarePayload['keycloackUserId'],
          locationCoordinates: malwarePayload['location'],
          deviceTypeId: malwarePayload['deviceTypeId'],
          detectTypeId: malwarePayload['detectTypeId'],
          operatingSystemName: malwarePayload['operatingSystemName'],
          attackName: malwarePayload['attackName'],
          attackSystem: malwarePayload['attackSystem'],
          description: malwarePayload['description'],
          incidentDate: malwarePayload['incidentDate'] != null
              ? DateTime.parse(malwarePayload['incidentDate'])
              : null,
          createdBy: malwarePayload['createdBy'],
          reportOutcome: malwarePayload['reportOutcome'],
          screenshots: malwarePayload['screenshots'] ?? [],
          voiceMessages: malwarePayload['voiceMessages'] ?? [],
          documents: malwarePayload['documents'] ?? [],
        );

        await box.put(reportId, updatedReport);

        // Try to sync with backend
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.none) {
          final success = await sendToBackend(updatedReport);
          if (success) {
            final syncedReport = updatedReport.copyWith(isSynced: true);
            await box.put(reportId, syncedReport);
          }
        }
      } else {
        // Create new report from payload
        final newReport = MalwareReportModel(
          id: reportId,
          malwareType: malwarePayload['attackName'] ?? 'Unknown Malware',
          infectedDeviceType:
              malwarePayload['deviceTypeId'] ?? 'Unknown Device',
          operatingSystem: malwarePayload['attackSystem'] ?? 'Unknown OS',
          detectionMethod:
              malwarePayload['detectTypeId'] ?? 'Unknown Detection',
          location: _extractLocationString(malwarePayload['location']),
          fileName: malwarePayload['attackName'] ?? 'Unknown File',
          name: malwarePayload['attackName'] ?? 'Unknown Attack',
          systemAffected: malwarePayload['attackSystem'] ?? 'Unknown System',
          alertSeverityLevel: malwarePayload['alertLevels'] ?? 'Medium',
          date: DateTime.now(),
          isSynced: false,
          keycloackUserId: malwarePayload['keycloackUserId'],
          reportCategoryId: malwarePayload['reportCategoryId'],
          reportTypeId: malwarePayload['reportTypeId'],
          alertLevels: malwarePayload['alertLevels'],
          deviceTypeId: malwarePayload['deviceTypeId'],
          detectTypeId: malwarePayload['detectTypeId'],
          operatingSystemName: malwarePayload['operatingSystemName'],
          attackName: malwarePayload['attackName'],
          attackSystem: malwarePayload['attackSystem'],
          createdBy: malwarePayload['createdBy'],
          description: malwarePayload['description'],
          incidentDate: malwarePayload['incidentDate'] != null
              ? DateTime.parse(malwarePayload['incidentDate'])
              : null,
          reportOutcome: malwarePayload['reportOutcome'],
          locationCoordinates: malwarePayload['location'],
          screenshots: malwarePayload['screenshots'] ?? [],
          voiceMessages: malwarePayload['voiceMessages'] ?? [],
          documents: malwarePayload['documents'] ?? [],
        );

        await box.add(newReport);

        // Try to sync with backend
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.none) {
          final success = await sendToBackend(newReport);
          if (success) {
            final syncedReport = newReport.copyWith(isSynced: true);
            await box.put(reportId, syncedReport);
          }
        }
      }
    } catch (e) {
      print('‚ùå Error updating malware with payload: $e');
    }
  }

  // Test your specific malware payload
  static Future<void> testYourMalwarePayload() async {
    try {
      // Your exact payload structure
      final yourPayload = {
        "reportCategoryId": "64e8b0a13c9f9c1e2aa1a111",
        "reportTypeId": "64e8b1b63c9f9c1e2aa1a222",
        "alertLevels": "64e8b2c83c9f9c1e2aa1a333",
        "keycloackUserId": "123e4567-e89b-12d3-a456-426614174000",
        "location": {
          "type": "Point",
          "coordinates": [77.5946, 12.9716], // Bangalore
        },
        "deviceTypeId": "64e8b4d93c9f9c1e2aa1a444",
        "detectTypeId": "64e8b5ea3c9f9c1e2aa1a555",
        "operatingSystemName": "64e8b6fb3c9f9c1e2aa1a666",
        "attackName": "Remote Access Trojan",
        "attackSystem": "Windows 10",
        "description":
            "Suspicious executable running in background. Data being sent to unknown IP.",
        "incidentDate": "2025-07-25T00:00:00.000Z",
        "createdBy": "security.admin@example.com",
        "reportOutcome": false,
        "screenshots": [],
        "voiceMessages": [],
        "documents": [],
      };

      // Update malware report with your payload
      await updateMalwareWithPayload(yourPayload);

      print(
        'üìù You can now use updateMalwareWithPayload() with your exact payload format',
      );
    } catch (e) {
      print('‚ùå Test failed: $e');
    }
  }

  // Test malware payload structure (like scam and fraud)
  static Future<void> testMalwarePayloadStructure() async {
    try {
      print('üß™ Testing malware payload structure (like scam and fraud)...');

      // Create a test malware report
      final testReport = MalwareReportModel(
        id: 'test_malware_${DateTime.now().millisecondsSinceEpoch}',
        malwareType: 'Test Malware',
        infectedDeviceType: 'Desktop',
        operatingSystem: 'Windows 10',
        detectionMethod: 'Antivirus',
        location: 'Test Location',
        fileName: 'test.exe',
        name: 'Test Malware Report',
        systemAffected: 'Test System',
        alertSeverityLevel: 'High',
        alertLevels: '64e8b2c83c9f9c1e2aa1a333', // Test alert level ID
        date: DateTime.now(),
        isSynced: false,
        keycloackUserId: 'test_user_123',
        reportCategoryId: '64e8b0a13c9f9c1e2aa1a111',
        reportTypeId: '64e8b1b63c9f9c1e2aa1a222',
        deviceTypeId: '64e8b4d93c9f9c1e2aa1a444',
        detectTypeId: '64e8b5ea3c9f9c1e2aa1a555',
        operatingSystemName: '64e8b6fb3c9f9c1e2aa1a666',
        attackName: 'Test Attack',
        attackSystem: 'Test System',
        createdBy: 'test@example.com',
        isActive: true,
        description: 'Test malware description',
        incidentDate: DateTime.now(),
        reportOutcome: true,
        locationCoordinates: {
          'type': 'Point',
          'coordinates': [0.0, 0.0],
        },
        screenshots: [],
        voiceMessages: [],
        documents: [],
      );

      // Test sending to backend
      final success = await sendToBackend(testReport);

      if (success) {
        print('‚úÖ Malware payload structure test passed!');
        print('üìù Malware reports should now work like scam and fraud reports');
      } else {
        print('‚ùå Malware payload structure test failed');
        print('üîç Check the console logs for detailed error information');
      }
    } catch (e) {
      print('‚ùå Test failed: $e');
    }
  }

  // Test if malware endpoint exists
  static Future<void> testMalwareEndpoint() async {
    try {
      final url =
          '${ApiConfig.reportsBaseUrl}${ApiConfig.malwareReportsEndpoint}';

      // Test with GET request to see if endpoint exists
      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      );

      if (response.statusCode == 200 || response.statusCode == 404) {
        print('‚úÖ Malware endpoint exists (status: ${response.statusCode})');
      } else {
        print(
          '‚ùå Malware endpoint might not exist (status: ${response.statusCode})',
        );
      }
    } catch (e) {
      print('‚ùå Error testing malware endpoint: $e');
      print('üîç This might indicate the endpoint does not exist');
    }
  }

  // Test alternative malware endpoint
  static Future<void> testAlternativeMalwareEndpoint() async {
    try {
      // Try the general reports endpoint like scam and fraud
      final url =
          '${ApiConfig.reportsBaseUrl}${ApiConfig.reportSecurityIssueEndpoint}';

      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      );

      print(
        'üì• Alternative endpoint test response status: ${response.statusCode}',
      );

      if (response.statusCode == 200) {
        print(
          'üîç You might need to use the general reports endpoint for malware',
        );
      } else {
        print(
          '‚ùå Alternative endpoint also failed (status: ${response.statusCode})',
        );
      }
    } catch (e) {
      print('‚ùå Error testing alternative endpoint: $e');
    }
  }

  // Add method to get current location dynamically (same as scam reports)
  static Future<Map<String, dynamic>> _getCurrentLocation() async {
    try {
      // Check if location services are enabled
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
          'address': 'Location services disabled',
        };
      }

      // Check location permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          return {
            'type': 'Point',
            'coordinates': [0.0, 0.0], // Fallback coordinates
            'address': 'Location permission denied',
          };
        }
      }

      if (permission == LocationPermission.deniedForever) {
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
          'address': 'Location permission denied',
        };
      }

      // Get current position
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10),
      );

      print(
        '‚úÖ Location obtained for malware report: ${position.latitude}, ${position.longitude}',
      );

      // Get real address using geocoding
      String address = '${position.latitude}, ${position.longitude}';

      try {
        List<Placemark> placemarks = await placemarkFromCoordinates(
          position.latitude,
          position.longitude,
        );

        if (placemarks.isNotEmpty) {
          Placemark placemark = placemarks[0];
          address = [
            placemark.street,
            placemark.subLocality,
            placemark.locality,
            placemark.administrativeArea,
            placemark.country,
          ].where((e) => e != null && e.isNotEmpty).join(', ');
        }
      } catch (e) {
        // Keep the coordinates as fallback
      }

      return {
        'type': 'Point',
        'coordinates': [
          position.longitude,
          position.latitude,
        ], // [lng, lat] format
        'address': address,
      };
    } catch (e) {
      return {
        'type': 'Point',
        'coordinates': [0.0, 0.0], // Fallback coordinates
        'address': 'Location services disabled',
      };
    }
  }

  // Updated malware update method with dynamic location
  static Future<void> updateMalwareWithLocation(
    Map<String, dynamic> malwarePayload,
  ) async {
    try {
      // Get current location
      final location = await _getCurrentLocation();

      // Update payload with current location
      final updatedPayload = Map<String, dynamic>.from(malwarePayload);
      updatedPayload['location'] = location;

      // Extract the report ID from payload or generate one
      String reportId =
          malwarePayload['id'] ??
          DateTime.now().millisecondsSinceEpoch.toString();

      // Create or update the malware report
      final box = Hive.box<MalwareReportModel>('malware_reports');

      // Check if report exists
      final existingReport = box.get(reportId);

      if (existingReport != null) {
        // Update existing report
        final updatedReport = existingReport.copyWith(
          reportCategoryId: updatedPayload['reportCategoryId'],
          reportTypeId: updatedPayload['reportTypeId'],
          alertLevels: updatedPayload['alertLevels'],
          keycloackUserId: updatedPayload['keycloackUserId'],
          locationCoordinates: updatedPayload['location'],
          deviceTypeId: updatedPayload['deviceTypeId'],
          detectTypeId: updatedPayload['detectTypeId'],
          operatingSystemName: updatedPayload['operatingSystemName'],
          attackName: updatedPayload['attackName'],
          attackSystem: updatedPayload['attackSystem'],
          description: updatedPayload['description'],
          incidentDate: updatedPayload['incidentDate'] != null
              ? DateTime.parse(updatedPayload['incidentDate'])
              : null,
          createdBy: updatedPayload['createdBy'],
          reportOutcome: updatedPayload['reportOutcome'],
          screenshots: updatedPayload['screenshots'] ?? [],
          voiceMessages: updatedPayload['voiceMessages'] ?? [],
          documents: updatedPayload['documents'] ?? [],
        );

        await box.put(reportId, updatedReport);

        // Try to sync with backend
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.none) {
          final success = await sendToBackend(updatedReport);
          if (success) {
            final syncedReport = updatedReport.copyWith(isSynced: true);
            await box.put(reportId, syncedReport);
          }
        }
      } else {
        // Create new report from payload with location
        final newReport = MalwareReportModel(
          id: reportId,
          malwareType: updatedPayload['attackName'] ?? 'Unknown Malware',
          infectedDeviceType:
              updatedPayload['deviceTypeId'] ?? 'Unknown Device',
          operatingSystem: updatedPayload['attackSystem'] ?? 'Unknown OS',
          detectionMethod:
              updatedPayload['detectTypeId'] ?? 'Unknown Detection',
          location: _extractLocationString(updatedPayload['location']),
          fileName: updatedPayload['attackName'] ?? 'Unknown File',
          name: updatedPayload['attackName'] ?? 'Unknown Attack',
          systemAffected: updatedPayload['attackSystem'] ?? 'Unknown System',
          alertSeverityLevel: updatedPayload['alertLevels'] ?? 'Medium',
          date: DateTime.now(),
          isSynced: false,
          keycloackUserId: updatedPayload['keycloackUserId'],
          reportCategoryId: updatedPayload['reportCategoryId'],
          reportTypeId: updatedPayload['reportTypeId'],
          alertLevels: updatedPayload['alertLevels'],
          deviceTypeId: updatedPayload['deviceTypeId'],
          detectTypeId: updatedPayload['detectTypeId'],
          operatingSystemName: updatedPayload['operatingSystemName'],
          attackName: updatedPayload['attackName'],
          attackSystem: updatedPayload['attackSystem'],
          createdBy: updatedPayload['createdBy'],
          // Removed status field
          description: updatedPayload['description'],
          incidentDate: updatedPayload['incidentDate'] != null
              ? DateTime.parse(updatedPayload['incidentDate'])
              : null,
          reportOutcome: updatedPayload['reportOutcome'],
          locationCoordinates: updatedPayload['location'],
          screenshots: updatedPayload['screenshots'] ?? [],
          voiceMessages: updatedPayload['voiceMessages'] ?? [],
          documents: updatedPayload['documents'] ?? [],
        );

        await box.add(newReport);

        // Try to sync with backend
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.none) {
          final success = await sendToBackend(newReport);
          if (success) {
            final syncedReport = newReport.copyWith(isSynced: true);
            await box.put(reportId, syncedReport);
          }
        }
      }
    } catch (e) {
      print('‚ùå Error updating malware with location: $e');
    }
  }

  // Check if a report is a duplicate before saving (legacy method)
  static Future<bool> isDuplicateReport(MalwareReportModel newReport) async {
    return await checkForExactDuplicate(newReport);
  }

  // Force cleanup all duplicates immediately
  static Future<void> forceCleanupDuplicates() async {
    await removeDuplicateReports();
  }

  // AGGRESSIVE duplicate removal - removes ALL duplicates
  static Future<void> aggressiveDuplicateRemoval() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final uniqueReports = <String, MalwareReportModel>{};

    for (final report in reports) {
      final key =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';
      if (!uniqueReports.containsKey(key)) {
        uniqueReports[key] = report;
        print('‚úÖ KEEPING: ${report.name} (${report.malwareType})');
      } else {
        print('‚ùå REMOVING: ${report.name} (${report.malwareType})');
      }
    }

    // Clear everything and add only unique
    await box.clear();
    for (final report in uniqueReports.values) {
      await box.add(report);
    }

    print(
      '‚úÖ AGGRESSIVE CLEANUP COMPLETED! Kept ${uniqueReports.length} unique reports',
    );
  }

  // Clear all malware reports (for testing)
  static Future<void> clearAllReports() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.clear();
  }

  // Clear all duplicates and keep only unique reports
  static Future<void> clearAllDuplicates() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final uniqueReports = <String, MalwareReportModel>{};

    for (final report in reports) {
      final key =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';
      if (!uniqueReports.containsKey(key)) {
        uniqueReports[key] = report;
        print('‚úÖ KEEPING: ${report.name} (${report.malwareType})');
      } else {
        print('‚ùå REMOVING DUPLICATE: ${report.name} (${report.malwareType})');
      }
    }

    // Clear box and add only unique reports
    await box.clear();
    for (final report in uniqueReports.values) {
      await box.add(report);
    }

    print(
      '‚úÖ Duplicate cleanup completed. Kept ${uniqueReports.length} unique reports',
    );
  }

  // Test method to verify auto-sync
  static Future<void> testAutoSync() async {
    // Check connectivity
    final connectivity = await Connectivity().checkConnectivity();

    // Check unsynced reports
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final unsyncedReports = box.values
        .where((r) => r.isSynced != true)
        .toList();

    // Try to sync
    if (connectivity != ConnectivityResult.none) {
      await syncReports();
    }
  }

  static Future<List<Map<String, dynamic>>> fetchReportTypes() async {
    return await _apiService.fetchReportTypes();
  }

  static Future<List<Map<String, dynamic>>> fetchReportTypesByCategory(
    String categoryId,
  ) async {
    return await _apiService.fetchReportTypesByCategory(categoryId);
  }

  static Future<List<Map<String, dynamic>>> fetchReportCategories() async {
    final categories = await _apiService.fetchReportCategories();
    print('API returned: $categories'); // Debug print
    return categories;
  }

  // Test duplicate detection
  static Future<void> testDuplicateDetection() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();

    final seenKeys = <String>{};
    final duplicates = <String>[];

    for (final report in reports) {
      final key =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';
      if (seenKeys.contains(key)) {
        duplicates.add('${report.name} (${report.malwareType})');
        print('‚ùå DUPLICATE: ${report.name} (${report.malwareType})');
      } else {
        seenKeys.add(key);
        print('‚úÖ UNIQUE: ${report.name} (${report.malwareType})');
      }
    }

    if (duplicates.isNotEmpty) {
      print('‚ùå Duplicates found: ${duplicates.join(', ')}');
    }
  }

  // NUCLEAR OPTION - Clear everything and start fresh
  static Future<void> nuclearCleanup() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.clear();
  }

  // Debug method to test all endpoints and identify the issue
  static Future<void> debugMalwareBackendIssue() async {
    // Test 1: Check if malware endpoint exists
    await testMalwareEndpoint();

    // Test 2: Check if general endpoint works
    await testAlternativeMalwareEndpoint();

    // Test 3: Test payload structure
    await testMalwarePayloadStructure();
  }

  // Enhanced sync method that also handles offline file uploads
  static Future<Map<String, dynamic>> syncOfflineReportsWithFiles() async {
    try {
      print('üîÑ Starting comprehensive malware report sync with files...');

      // First, sync offline reports to server
      final reportSyncResult = await _syncOfflineReportsToServer();

      // Then, sync offline files
      final fileSyncResult =
          await custom.OfflineFileUploadService.syncOfflineFiles();

      print('üìä Sync Summary:');
      print('üìä - Reports synced: ${reportSyncResult['synced']}');
      print('üìä - Reports failed: ${reportSyncResult['failed']}');
      print('üìä - Files synced: ${fileSyncResult['synced']}');
      print('üìä - Files failed: ${fileSyncResult['failed']}');

      return {
        'success': reportSyncResult['success'] && fileSyncResult['success'],
        'reports': reportSyncResult,
        'files': fileSyncResult,
        'message': 'Comprehensive sync completed',
      };
    } catch (e) {
      print('‚ùå Error in comprehensive sync: $e');
      return {
        'success': false,
        'error': e.toString(),
        'message': 'Comprehensive sync failed',
      };
    }
  }

  // Sync offline reports to server
  static Future<Map<String, dynamic>> _syncOfflineReportsToServer() async {
    try {
      print('üîÑ Starting malware report sync to server...');

      // Check connectivity
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity == ConnectivityResult.none) {
        return {
          'success': false,
          'message': 'No internet connection',
          'synced': 0,
          'failed': 0,
        };
      }

      // Get all offline reports
      final box = Hive.box<MalwareReportModel>('malware_reports');
      final allReports = box.values.toList();
      final offlineReports = allReports
          .where((r) => r.isSynced != true)
          .toList();

      print(
        'üìä Found ${offlineReports.length} offline reports out of ${allReports.length} total',
      );

      if (offlineReports.isEmpty) {
        return {
          'success': true,
          'message': 'No offline reports to sync',
          'synced': 0,
          'failed': 0,
        };
      }

      // Sync each offline report
      int successCount = 0;
      int failureCount = 0;

      for (final report in offlineReports) {
        try {
          print('üì§ Syncing report ${report.id} - ${report.malwareType}');

          final success = await sendToBackend(report);
          if (success) {
            // Update report as synced
            final updated = report.copyWith(isSynced: true);
            await box.put(report.id, updated);
            successCount++;
            print('‚úÖ Successfully synced report ${report.id}');
          } else {
            failureCount++;
            print('‚ùå Failed to sync report ${report.id}');
          }
        } catch (e) {
          failureCount++;
          print('‚ùå Error syncing report ${report.id}: $e');
        }
      }

      print(
        'üìä Report sync completed - Success: $successCount, Failed: $failureCount',
      );

      return {
        'success': failureCount == 0,
        'message': 'Report sync completed',
        'synced': successCount,
        'failed': failureCount,
      };
    } catch (e) {
      print('‚ùå Error in report sync: $e');
      return {
        'success': false,
        'error': e.toString(),
        'message': 'Report sync failed',
        'synced': 0,
        'failed': 0,
      };
    }
  }

  // Handle offline file uploads for malware reports
  static Future<void> _handleOfflineFileUploads(
    MalwareReportModel report,
  ) async {
    try {
      print(
        'üìÅ Handling offline file uploads for malware report: ${report.id}',
      );

      // Check if there are any files to upload
      final files = await custom
          .OfflineFileUploadService.getOfflineFilesByReportId(report.id!);

      if (files.isEmpty) {
        print('üìÅ No offline files found for malware report: ${report.id}');
        return;
      }

      print(
        'üìÅ Found ${files.length} offline files for malware report: ${report.id}',
      );

      // Check connectivity
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity == ConnectivityResult.none) {
        print('üì± No internet connection - files will be uploaded when online');
        return;
      }

      // Sync offline files
      final syncResult =
          await custom.OfflineFileUploadService.syncOfflineFiles();

      if (syncResult['success'] == true) {
        print(
          '‚úÖ Offline files synced successfully for malware report: ${report.id}',
        );
        print(
          'üìä Synced: ${syncResult['synced']}, Failed: ${syncResult['failed']}',
        );
      } else {
        print(
          '‚ùå Failed to sync offline files for malware report: ${report.id}',
        );
      }
    } catch (e) {
      print('‚ùå Error handling offline file uploads: $e');
    }
  }

  // Remove duplicate malware reports
  static Future<void> removeDuplicateMalwareReports() async {
    try {
      print('üßπ Removing duplicate malware reports...');

      final box = Hive.box<MalwareReportModel>('malware_reports');
      final allReports = box.values.toList();

      print('üìä Before cleanup: ${allReports.length} malware reports');

      final uniqueReports = <String, MalwareReportModel>{};
      final duplicates = <String>[];

      for (final report in allReports) {
        // Create a unique key based on content
        final key =
            '${report.name}_${report.malwareType}_${report.date}_${report.location}';

        if (uniqueReports.containsKey(key)) {
          duplicates.add(key);
          // Keep the one with the latest timestamp
          final existing = uniqueReports[key]!;
          if (report.date.isAfter(existing.date)) {
            uniqueReports[key] = report;
          }
        } else {
          uniqueReports[key] = report;
        }
      }

      if (duplicates.isNotEmpty) {
        print('üßπ Found ${duplicates.length} duplicate malware reports');

        // Clear the box and add back only unique reports
        await box.clear();
        for (final report in uniqueReports.values) {
          await box.put(report.id, report);
        }

        print('üßπ Removed ${duplicates.length} duplicate malware reports');
      } else {
        print('‚úÖ No duplicate malware reports found');
      }

      print('üìä After cleanup: ${box.length} malware reports');
    } catch (e) {
      print('‚ùå Error removing duplicate malware reports: $e');
    }
  }
}
