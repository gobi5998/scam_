import 'package:hive/hive.dart';
import 'dart:convert';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';
import 'package:http/http.dart' as http;

import '../../models/malware_report_model.dart';
import '../../config/api_config.dart';
import '../../services/api_service.dart';
import '../../services/jwt_service.dart';
import '../../services/malware_reference_service.dart';
import '../../services/dio_service.dart';

class MalwareReportService {
  static final _box = Hive.box<MalwareReportModel>('malware_reports');
  static final ApiService _apiService = ApiService();

  static Future<void> saveReport(MalwareReportModel report) async {
    // Get current user ID from JWT token
    final keycloakUserId = await JwtService.getCurrentUserId();

    // Run diagnostics if no user ID found (device-specific issue)
    if (keycloakUserId == null) {
      await JwtService.diagnoseTokenStorage();
    }

    if (keycloakUserId != null) {
      report = report.copyWith(keycloackUserId: keycloakUserId);
    } else {
      // Fallback for device-specific issues
      report = report.copyWith(
        keycloackUserId: 'device_user_${DateTime.now().millisecondsSinceEpoch}',
      );
    }

    // Ensure unique timestamp for each report
    final now = DateTime.now().toUtc(); // Use UTC time consistently
    report = report.copyWith(date: now);

    // Always save to local storage first (offline-first approach)
    await _box.add(report);
    print(
      '‚úÖ Malware report saved locally with type ID: ${report.reportTypeId}',
    );

    // Try to sync if online
    final connectivity = await Connectivity().checkConnectivity();
    if (connectivity != ConnectivityResult.none) {
      try {
        // Initialize reference service before syncing
        await MalwareReferenceService.initialize();
        bool success = await sendToBackend(report);
        if (success) {
          // Mark as synced
          final key = _box.keyAt(
            _box.length - 1,
          ); // Get the key of the last added item
          final updated = report.copyWith(isSynced: true);
          await _box.put(key, updated);
        }
      } catch (e) {
        print('‚ùå Error syncing malware report: $e');
      }
    }

    // Remove duplicates immediately after saving
    await removeDuplicateReports();
  }

  static Future<void> saveReportOffline(MalwareReportModel report) async {
    // Get current user ID from JWT token
    final keycloakUserId = await JwtService.getCurrentUserId();
    if (keycloakUserId != null) {
      report = report.copyWith(keycloackUserId: keycloakUserId);
    }

    print('Saving malware report to local storage: ${report.toJson()}');
    await _box.add(report);

    // Remove duplicates immediately after saving (like scam/fraud)
    await removeDuplicateReports();
  }

  static Future<void> syncReports() async {
    final connectivity = await Connectivity().checkConnectivity();
    if (connectivity == ConnectivityResult.none) {
      print('üì± No internet connection, skipping malware sync');
      return;
    }

    print('üîÑ Starting malware reports sync...');

    try {
      final pendingReports = _box.values
          .where((report) => !report.isSynced)
          .toList();
      print(
        'üìã Found ${pendingReports.length} pending malware reports to sync',
      );

      int syncedCount = 0;
      int failedCount = 0;

      for (final report in pendingReports) {
        try {
          print('üîÑ Syncing malware report: ${report.id}');
          final success = await sendToBackend(report);

          if (success) {
            syncedCount++;
            print('‚úÖ Malware report ${report.id} synced successfully');
          } else {
            failedCount++;
            print('‚ùå Failed to sync malware report ${report.id}');
          }
        } catch (e) {
          failedCount++;
          print('‚ùå Error syncing malware report ${report.id}: $e');
        }
      }

      print('üìä Malware sync summary:');
      print('üìä - Total pending: ${pendingReports.length}');
      print('üìä - Synced: $syncedCount');
      print('üìä - Failed: $failedCount');
    } catch (e) {
      print('‚ùå Error during malware sync: $e');
    }
  }

  static Future<bool> sendToBackend(MalwareReportModel report) async {
    try {
      print('üîÑ Sending malware report to backend...');
      print('üìã Report data: ${report.toJson()}');

      // Get dynamic ObjectIds for missing fields
      final deviceTypeId = report.deviceTypeId?.isNotEmpty == true
          ? report.deviceTypeId!
          : await _getDynamicDeviceTypeId();
      final detectTypeId = report.detectTypeId?.isNotEmpty == true
          ? report.detectTypeId!
          : await _getDynamicDetectionTypeId();
      final operatingSystemId = report.operatingSystemName?.isNotEmpty == true
          ? report.operatingSystemName!
          : await _getDynamicOperatingSystemId();

      // Remove local-only fields from payload
      final reportData = report.toJson();
      reportData.remove('isSynced'); // Remove local-only field

      // Add missing fields dynamically
      if (deviceTypeId.isNotEmpty) {
        reportData['deviceTypeId'] = deviceTypeId;
        print('‚úÖ Added deviceTypeId: $deviceTypeId');
      }
      if (detectTypeId.isNotEmpty) {
        reportData['detectTypeId'] = detectTypeId;
        print('‚úÖ Added detectTypeId: $detectTypeId');
      }
      if (operatingSystemId.isNotEmpty) {
        reportData['operatingSystemName'] = operatingSystemId;
        print('‚úÖ Added operatingSystemName: $operatingSystemId');
      }

      // Ensure keycloackUserId is set
      if (reportData['keycloackUserId'] == null ||
          reportData['keycloackUserId'] == '') {
        final keycloakUserId = await JwtService.getCurrentUserId();
        if (keycloakUserId != null) {
          reportData['keycloackUserId'] = keycloakUserId;
          print('‚úÖ Added keycloackUserId: $keycloakUserId');
        }
      }

      print('üì§ Sending payload: $reportData');

      // Use dioService for authenticated requests
      final dioService = DioService();
      final dioResponse = await dioService.reportsPost(
        ApiConfig.reportSecurityIssueEndpoint,
        data: reportData,
      );

      print('üì• Response status: ${dioResponse.statusCode}');
      print('üì• Response body: ${dioResponse.data}');

      if (dioResponse.statusCode == 200 || dioResponse.statusCode == 201) {
        // Parse server response to get _id and timestamps
        final responseData = dioResponse.data;
        final serverId = responseData['_id'] ?? responseData['id'];
        final serverCreatedAt = responseData['createdAt'];
        final serverUpdatedAt = responseData['updatedAt'];

        print('‚úÖ Malware report synced successfully');
        print('üÜî Server ID: $serverId');
        print('üìÖ Server createdAt: $serverCreatedAt');
        print('üìÖ Server updatedAt: $serverUpdatedAt');

        // Update the report with server data
        final updated = report.copyWith(
          id: serverId,
          date: serverCreatedAt != null
              ? DateTime.parse(serverCreatedAt)
              : report.date,
          isSynced: true,
        );

        // Re-key the report in Hive to match server ID
        final previousLocalId = report.id;
        final targetKey = updated.id ?? previousLocalId;

        // Delete old record and add new one with server ID
        if (previousLocalId != targetKey) {
          await _box.delete(previousLocalId);
          print(
            'üîÅ Re-keyed local malware report from $previousLocalId to ${updated.id}',
          );
        }

        await _box.put(targetKey, updated);

        return true;
      } else {
        print('‚ùå Failed to sync malware report: ${dioResponse.statusCode}');
        return false;
      }
    } catch (e) {
      print('‚ùå Error sending malware report to backend: $e');
      return false;
    }
  }

  static Future<void> updateReport(MalwareReportModel report) async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.put(report.id, report);
  }

  // Dynamic methods to get ObjectIds from reference service
  static Future<String> _getDynamicReportCategoryId(String categoryName) async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getMalwareReportCategoryId();
    } catch (e) {
      return '';
    }
  }

  static Future<String> _getDynamicReportTypeId(String typeName) async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getMalwareReportTypeId();
    } catch (e) {
      return '';
    }
  }

  static Future<String> _getDynamicDeviceTypeId() async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getDeviceTypeId(
        'desktop',
      ); // Default to desktop
    } catch (e) {
      return '';
    }
  }

  static Future<String> _getDynamicDetectionTypeId() async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getDetectionTypeId(
        'antivirus',
      ); // Default to antivirus
    } catch (e) {
      return '';
    }
  }

  static Future<String> _getDynamicOperatingSystemId() async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getOperatingSystemId(
        'windows',
      ); // Default to windows
    } catch (e) {
      return '';
    }
  }

  static List<MalwareReportModel> getLocalReports() {
    final reports = _box.values.toList();
    return reports;
  }

  static Future<void> updateExistingReportsWithKeycloakUserId() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();

    for (int i = 0; i < reports.length; i++) {
      final report = reports[i];
      if (report.keycloackUserId == null) {
        final keycloakUserId = await JwtService.getCurrentUserId();
        if (keycloakUserId != null) {
          final updatedReport = report.copyWith(
            keycloackUserId: keycloakUserId,
          );
          final key = box.keyAt(i);
          await box.put(key, updatedReport);
        }
      }
    }
  }

  static Future<void> removeDuplicateReports() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final seenContent = <String>{};
    final toDelete = <int>[];

    for (int i = 0; i < reports.length; i++) {
      final report = reports[i];
      // Use content-based detection: name + type + device + location
      final contentKey =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';

      if (seenContent.contains(contentKey)) {
        toDelete.add(i);
        print(
          '‚ùå DUPLICATE FOUND: ${report.name} (${report.malwareType}) - ${report.infectedDeviceType} - ${report.location}',
        );
      } else {
        seenContent.add(contentKey);
        print(
          '‚úÖ KEEPING: ${report.name} (${report.malwareType}) - ${report.infectedDeviceType} - ${report.location}',
        );
      }
    }

    // Delete duplicates in reverse order to maintain indices
    for (int i = toDelete.length - 1; i >= 0; i--) {
      final key = box.keyAt(toDelete[i]);
      await box.delete(key);
    }

    final remainingReports = box.values.toList();
  }

  // STRICT duplicate check - Check for exact duplicates before saving
  static Future<bool> checkForExactDuplicate(
    MalwareReportModel newReport,
  ) async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final existingReports = box.values.toList();

    print(
      'üîç STRICT DUPLICATE CHECK: ${newReport.name} (${newReport.malwareType})',
    );

    for (final existingReport in existingReports) {
      // Check for EXACT match (name + type + device + location)
      if (existingReport.name == newReport.name &&
          existingReport.malwareType == newReport.malwareType &&
          existingReport.infectedDeviceType == newReport.infectedDeviceType &&
          existingReport.location == newReport.location) {
        print(
          '‚ùå EXACT DUPLICATE FOUND: ${newReport.name} (${newReport.malwareType}) - ${newReport.infectedDeviceType} - ${newReport.location}',
        );
        return true;
      }
    }

    print(
      '‚úÖ NO EXACT DUPLICATE: ${newReport.name} (${newReport.malwareType}) - ${newReport.infectedDeviceType} - ${newReport.location}',
    );
    return false;
  }

  // Convert payload format to MalwareReportModel
  static MalwareReportModel fromPayload(Map<String, dynamic> payload) {
    return MalwareReportModel(
      id: payload['id'] ?? DateTime.now().millisecondsSinceEpoch.toString(),
      malwareType: payload['attackName'] ?? 'Unknown Malware',
      infectedDeviceType: payload['deviceTypeId'] ?? 'Unknown Device',
      operatingSystem: payload['attackSystem'] ?? 'Unknown OS',
      detectionMethod: payload['detectTypeId'] ?? 'Unknown Detection',
      location: _extractLocationString(payload['location']),
      fileName: payload['attackName'] ?? 'Unknown File',
      name: payload['attackName'] ?? 'Unknown Attack',
      systemAffected: payload['attackSystem'] ?? 'Unknown System',
      alertSeverityLevel: payload['alertLevels'] ?? 'Medium',
      date: DateTime.now(),
      isSynced: false,
      keycloackUserId: payload['keycloackUserId'],
      reportCategoryId: payload['reportCategoryId'],
      reportTypeId: payload['reportTypeId'],
      alertLevels: payload['alertLevels'],
      deviceTypeId: payload['deviceTypeId'],
      detectTypeId: payload['detectTypeId'],
      operatingSystemName: payload['operatingSystemName'],
      attackName: payload['attackName'],
      attackSystem: payload['attackSystem'],
      createdBy: payload['createdBy'],
      // Removed status field
      description: payload['description'],
      incidentDate: payload['incidentDate'] != null
          ? DateTime.parse(payload['incidentDate'])
          : null,
      reportOutcome: payload['reportOutcome'],
      locationCoordinates: payload['location'],
      screenshots: payload['screenshots'] ?? [],
      voiceMessages: payload['voiceMessages'] ?? [],
      documents: payload['documents'] ?? [],
    );
  }

  // Helper function to extract location string from coordinates
  static String _extractLocationString(dynamic location) {
    if (location is Map<String, dynamic>) {
      if (location['coordinates'] is List &&
          location['coordinates'].length >= 2) {
        final lat = location['coordinates'][1];
        final lng = location['coordinates'][0];
        return '$lat, $lng';
      }
    }
    return 'Unknown Location';
  }

  // Create malware report from payload and save
  static Future<void> createFromPayload(Map<String, dynamic> payload) async {
    try {
      // Convert payload to model
      final report = fromPayload(payload);

      // Check for duplicates before saving
      final isDuplicate = await checkForExactDuplicate(report);
      if (isDuplicate) {
        return;
      }

      // Save the report
      await saveReport(report);
    } catch (e) {
      print('‚ùå Error creating malware report from payload: $e');
    }
  }

  // Update existing malware report with payload
  static Future<void> updateFromPayload(
    String reportId,
    Map<String, dynamic> payload,
  ) async {
    try {
      final box = Hive.box<MalwareReportModel>('malware_reports');
      final existingReport = box.get(reportId);

      if (existingReport == null) {
        return;
      }

      // Update the report with new payload data
      final updatedReport = existingReport.copyWith(
        reportCategoryId: payload['reportCategoryId'],
        reportTypeId: payload['reportTypeId'],
        alertLevels: payload['alertLevels'],
        deviceTypeId: payload['deviceTypeId'],
        detectTypeId: payload['detectTypeId'],
        operatingSystemName: payload['operatingSystemName'],
        attackName: payload['attackName'],
        attackSystem: payload['attackSystem'],

        description: payload['description'],
        incidentDate: payload['incidentDate'] != null
            ? DateTime.parse(payload['incidentDate'])
            : null,
        reportOutcome: payload['reportOutcome'],
        locationCoordinates: payload['location'],
        screenshots: payload['screenshots'] ?? [],
        voiceMessages: payload['voiceMessages'] ?? [],
        documents: payload['documents'] ?? [],
      );

      // Save updated report
      await box.put(reportId, updatedReport);

      // Try to sync with backend
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        final success = await sendToBackend(updatedReport);
        if (success) {
          final syncedReport = updatedReport.copyWith(isSynced: true);
          await box.put(reportId, syncedReport);
        }
      }
    } catch (e) {
      print('‚ùå Error updating malware report from payload: $e');
    }
  }

  // Malware-specific update method using your exact payload format
  static Future<void> updateMalwareWithPayload(
    Map<String, dynamic> malwarePayload,
  ) async {
    try {
      // Extract the report ID from payload or generate one
      String reportId =
          malwarePayload['id'] ??
          DateTime.now().millisecondsSinceEpoch.toString();

      // Create or update the malware report
      final box = Hive.box<MalwareReportModel>('malware_reports');

      // Check if report exists
      final existingReport = box.get(reportId);

      if (existingReport != null) {
        // Update existing report
        final updatedReport = existingReport.copyWith(
          reportCategoryId: malwarePayload['reportCategoryId'],
          reportTypeId: malwarePayload['reportTypeId'],
          alertLevels: malwarePayload['alertLevels'],
          keycloackUserId: malwarePayload['keycloackUserId'],
          locationCoordinates: malwarePayload['location'],
          deviceTypeId: malwarePayload['deviceTypeId'],
          detectTypeId: malwarePayload['detectTypeId'],
          operatingSystemName: malwarePayload['operatingSystemName'],
          attackName: malwarePayload['attackName'],
          attackSystem: malwarePayload['attackSystem'],
          description: malwarePayload['description'],
          incidentDate: malwarePayload['incidentDate'] != null
              ? DateTime.parse(malwarePayload['incidentDate'])
              : null,
          createdBy: malwarePayload['createdBy'],
          reportOutcome: malwarePayload['reportOutcome'],
          screenshots: malwarePayload['screenshots'] ?? [],
          voiceMessages: malwarePayload['voiceMessages'] ?? [],
          documents: malwarePayload['documents'] ?? [],
        );

        await box.put(reportId, updatedReport);

        // Try to sync with backend
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.none) {
          final success = await sendToBackend(updatedReport);
          if (success) {
            final syncedReport = updatedReport.copyWith(isSynced: true);
            await box.put(reportId, syncedReport);
          }
        }
      } else {
        // Create new report from payload
        final newReport = MalwareReportModel(
          id: reportId,
          malwareType: malwarePayload['attackName'] ?? 'Unknown Malware',
          infectedDeviceType:
              malwarePayload['deviceTypeId'] ?? 'Unknown Device',
          operatingSystem: malwarePayload['attackSystem'] ?? 'Unknown OS',
          detectionMethod:
              malwarePayload['detectTypeId'] ?? 'Unknown Detection',
          location: _extractLocationString(malwarePayload['location']),
          fileName: malwarePayload['attackName'] ?? 'Unknown File',
          name: malwarePayload['attackName'] ?? 'Unknown Attack',
          systemAffected: malwarePayload['attackSystem'] ?? 'Unknown System',
          alertSeverityLevel: malwarePayload['alertLevels'] ?? 'Medium',
          date: DateTime.now(),
          isSynced: false,
          keycloackUserId: malwarePayload['keycloackUserId'],
          reportCategoryId: malwarePayload['reportCategoryId'],
          reportTypeId: malwarePayload['reportTypeId'],
          alertLevels: malwarePayload['alertLevels'],
          deviceTypeId: malwarePayload['deviceTypeId'],
          detectTypeId: malwarePayload['detectTypeId'],
          operatingSystemName: malwarePayload['operatingSystemName'],
          attackName: malwarePayload['attackName'],
          attackSystem: malwarePayload['attackSystem'],
          createdBy: malwarePayload['createdBy'],
          description: malwarePayload['description'],
          incidentDate: malwarePayload['incidentDate'] != null
              ? DateTime.parse(malwarePayload['incidentDate'])
              : null,
          reportOutcome: malwarePayload['reportOutcome'],
          locationCoordinates: malwarePayload['location'],
          screenshots: malwarePayload['screenshots'] ?? [],
          voiceMessages: malwarePayload['voiceMessages'] ?? [],
          documents: malwarePayload['documents'] ?? [],
        );

        await box.add(newReport);

        // Try to sync with backend
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.none) {
          final success = await sendToBackend(newReport);
          if (success) {
            final syncedReport = newReport.copyWith(isSynced: true);
            await box.put(reportId, syncedReport);
          }
        }
      }
    } catch (e) {
      print('‚ùå Error updating malware with payload: $e');
    }
  }

  // Test your specific malware payload
  static Future<void> testYourMalwarePayload() async {
    try {
      // Your exact payload structure
      final yourPayload = {
        "reportCategoryId": "64e8b0a13c9f9c1e2aa1a111",
        "reportTypeId": "64e8b1b63c9f9c1e2aa1a222",
        "alertLevels": "64e8b2c83c9f9c1e2aa1a333",
        "keycloackUserId": "123e4567-e89b-12d3-a456-426614174000",
        "location": {
          "type": "Point",
          "coordinates": [77.5946, 12.9716], // Bangalore
        },
        "deviceTypeId": "64e8b4d93c9f9c1e2aa1a444",
        "detectTypeId": "64e8b5ea3c9f9c1e2aa1a555",
        "operatingSystemName": "64e8b6fb3c9f9c1e2aa1a666",
        "attackName": "Remote Access Trojan",
        "attackSystem": "Windows 10",
        "description":
            "Suspicious executable running in background. Data being sent to unknown IP.",
        "incidentDate": "2025-07-25T00:00:00.000Z",
        "createdBy": "security.admin@example.com",
        "reportOutcome": false,
        "screenshots": [],
        "voiceMessages": [],
        "documents": [],
      };

      // Update malware report with your payload
      await updateMalwareWithPayload(yourPayload);

      print(
        'üìù You can now use updateMalwareWithPayload() with your exact payload format',
      );
    } catch (e) {
      print('‚ùå Test failed: $e');
    }
  }

  // Test malware payload structure (like scam and fraud)
  static Future<void> testMalwarePayloadStructure() async {
    try {
      print('üß™ Testing malware payload structure (like scam and fraud)...');

      // Create a test malware report
      final testReport = MalwareReportModel(
        id: 'test_malware_${DateTime.now().millisecondsSinceEpoch}',
        malwareType: 'Test Malware',
        infectedDeviceType: 'Desktop',
        operatingSystem: 'Windows 10',
        detectionMethod: 'Antivirus',
        location: 'Test Location',
        fileName: 'test.exe',
        name: 'Test Malware Report',
        systemAffected: 'Test System',
        alertSeverityLevel: 'High',
        alertLevels: '64e8b2c83c9f9c1e2aa1a333', // Test alert level ID
        date: DateTime.now(),
        isSynced: false,
        keycloackUserId: 'test_user_123',
        reportCategoryId: '64e8b0a13c9f9c1e2aa1a111',
        reportTypeId: '64e8b1b63c9f9c1e2aa1a222',
        deviceTypeId: '64e8b4d93c9f9c1e2aa1a444',
        detectTypeId: '64e8b5ea3c9f9c1e2aa1a555',
        operatingSystemName: '64e8b6fb3c9f9c1e2aa1a666',
        attackName: 'Test Attack',
        attackSystem: 'Test System',
        createdBy: 'test@example.com',
        isActive: true,
        description: 'Test malware description',
        incidentDate: DateTime.now(),
        reportOutcome: true,
        locationCoordinates: {
          'type': 'Point',
          'coordinates': [0.0, 0.0],
        },
        screenshots: [],
        voiceMessages: [],
        documents: [],
      );

      // Test sending to backend
      final success = await sendToBackend(testReport);

      if (success) {
        print('‚úÖ Malware payload structure test passed!');
        print('üìù Malware reports should now work like scam and fraud reports');
      } else {
        print('‚ùå Malware payload structure test failed');
        print('üîç Check the console logs for detailed error information');
      }
    } catch (e) {
      print('‚ùå Test failed: $e');
    }
  }

  // Test if malware endpoint exists
  static Future<void> testMalwareEndpoint() async {
    try {
      final url =
          '${ApiConfig.reportsBaseUrl}${ApiConfig.malwareReportsEndpoint}';

      // Test with GET request to see if endpoint exists
      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      );

      if (response.statusCode == 200 || response.statusCode == 404) {
        print('‚úÖ Malware endpoint exists (status: ${response.statusCode})');
      } else {
        print(
          '‚ùå Malware endpoint might not exist (status: ${response.statusCode})',
        );
      }
    } catch (e) {
      print('‚ùå Error testing malware endpoint: $e');
      print('üîç This might indicate the endpoint does not exist');
    }
  }

  // Test alternative malware endpoint
  static Future<void> testAlternativeMalwareEndpoint() async {
    try {
      // Try the general reports endpoint like scam and fraud
      final url =
          '${ApiConfig.reportsBaseUrl}${ApiConfig.reportSecurityIssueEndpoint}';

      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      );

      print(
        'üì• Alternative endpoint test response status: ${response.statusCode}',
      );

      if (response.statusCode == 200) {
        print(
          'üîç You might need to use the general reports endpoint for malware',
        );
      } else {
        print(
          '‚ùå Alternative endpoint also failed (status: ${response.statusCode})',
        );
      }
    } catch (e) {
      print('‚ùå Error testing alternative endpoint: $e');
    }
  }

  // Add method to get current location dynamically (same as scam reports)
  static Future<Map<String, dynamic>> _getCurrentLocation() async {
    try {
      // Check if location services are enabled
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
          'address': 'Location services disabled',
        };
      }

      // Check location permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          return {
            'type': 'Point',
            'coordinates': [0.0, 0.0], // Fallback coordinates
            'address': 'Location permission denied',
          };
        }
      }

      if (permission == LocationPermission.deniedForever) {
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
          'address': 'Location permission denied',
        };
      }

      // Get current position
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10),
      );

      print(
        '‚úÖ Location obtained for malware report: ${position.latitude}, ${position.longitude}',
      );

      // Get real address using geocoding
      String address = '${position.latitude}, ${position.longitude}';

      try {
        List<Placemark> placemarks = await placemarkFromCoordinates(
          position.latitude,
          position.longitude,
        );

        if (placemarks.isNotEmpty) {
          Placemark placemark = placemarks[0];
          address = [
            placemark.street,
            placemark.subLocality,
            placemark.locality,
            placemark.administrativeArea,
            placemark.country,
          ].where((e) => e != null && e.isNotEmpty).join(', ');
        }
      } catch (e) {
        // Keep the coordinates as fallback
      }

      return {
        'type': 'Point',
        'coordinates': [
          position.longitude,
          position.latitude,
        ], // [lng, lat] format
        'address': address,
      };
    } catch (e) {
      return {
        'type': 'Point',
        'coordinates': [0.0, 0.0], // Fallback coordinates
        'address': 'Location services disabled',
      };
    }
  }

  // Updated malware update method with dynamic location
  static Future<void> updateMalwareWithLocation(
    Map<String, dynamic> malwarePayload,
  ) async {
    try {
      // Get current location
      final location = await _getCurrentLocation();

      // Update payload with current location
      final updatedPayload = Map<String, dynamic>.from(malwarePayload);
      updatedPayload['location'] = location;

      // Extract the report ID from payload or generate one
      String reportId =
          malwarePayload['id'] ??
          DateTime.now().millisecondsSinceEpoch.toString();

      // Create or update the malware report
      final box = Hive.box<MalwareReportModel>('malware_reports');

      // Check if report exists
      final existingReport = box.get(reportId);

      if (existingReport != null) {
        // Update existing report
        final updatedReport = existingReport.copyWith(
          reportCategoryId: updatedPayload['reportCategoryId'],
          reportTypeId: updatedPayload['reportTypeId'],
          alertLevels: updatedPayload['alertLevels'],
          keycloackUserId: updatedPayload['keycloackUserId'],
          locationCoordinates: updatedPayload['location'],
          deviceTypeId: updatedPayload['deviceTypeId'],
          detectTypeId: updatedPayload['detectTypeId'],
          operatingSystemName: updatedPayload['operatingSystemName'],
          attackName: updatedPayload['attackName'],
          attackSystem: updatedPayload['attackSystem'],
          description: updatedPayload['description'],
          incidentDate: updatedPayload['incidentDate'] != null
              ? DateTime.parse(updatedPayload['incidentDate'])
              : null,
          createdBy: updatedPayload['createdBy'],
          reportOutcome: updatedPayload['reportOutcome'],
          screenshots: updatedPayload['screenshots'] ?? [],
          voiceMessages: updatedPayload['voiceMessages'] ?? [],
          documents: updatedPayload['documents'] ?? [],
        );

        await box.put(reportId, updatedReport);

        // Try to sync with backend
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.none) {
          final success = await sendToBackend(updatedReport);
          if (success) {
            final syncedReport = updatedReport.copyWith(isSynced: true);
            await box.put(reportId, syncedReport);
          }
        }
      } else {
        // Create new report from payload with location
        final newReport = MalwareReportModel(
          id: reportId,
          malwareType: updatedPayload['attackName'] ?? 'Unknown Malware',
          infectedDeviceType:
              updatedPayload['deviceTypeId'] ?? 'Unknown Device',
          operatingSystem: updatedPayload['attackSystem'] ?? 'Unknown OS',
          detectionMethod:
              updatedPayload['detectTypeId'] ?? 'Unknown Detection',
          location: _extractLocationString(updatedPayload['location']),
          fileName: updatedPayload['attackName'] ?? 'Unknown File',
          name: updatedPayload['attackName'] ?? 'Unknown Attack',
          systemAffected: updatedPayload['attackSystem'] ?? 'Unknown System',
          alertSeverityLevel: updatedPayload['alertLevels'] ?? 'Medium',
          date: DateTime.now(),
          isSynced: false,
          keycloackUserId: updatedPayload['keycloackUserId'],
          reportCategoryId: updatedPayload['reportCategoryId'],
          reportTypeId: updatedPayload['reportTypeId'],
          alertLevels: updatedPayload['alertLevels'],
          deviceTypeId: updatedPayload['deviceTypeId'],
          detectTypeId: updatedPayload['detectTypeId'],
          operatingSystemName: updatedPayload['operatingSystemName'],
          attackName: updatedPayload['attackName'],
          attackSystem: updatedPayload['attackSystem'],
          createdBy: updatedPayload['createdBy'],
          // Removed status field
          description: updatedPayload['description'],
          incidentDate: updatedPayload['incidentDate'] != null
              ? DateTime.parse(updatedPayload['incidentDate'])
              : null,
          reportOutcome: updatedPayload['reportOutcome'],
          locationCoordinates: updatedPayload['location'],
          screenshots: updatedPayload['screenshots'] ?? [],
          voiceMessages: updatedPayload['voiceMessages'] ?? [],
          documents: updatedPayload['documents'] ?? [],
        );

        await box.add(newReport);

        // Try to sync with backend
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.none) {
          final success = await sendToBackend(newReport);
          if (success) {
            final syncedReport = newReport.copyWith(isSynced: true);
            await box.put(reportId, syncedReport);
          }
        }
      }
    } catch (e) {
      print('‚ùå Error updating malware with location: $e');
    }
  }

  // Check if a report is a duplicate before saving (legacy method)
  static Future<bool> isDuplicateReport(MalwareReportModel newReport) async {
    return await checkForExactDuplicate(newReport);
  }

  // Force cleanup all duplicates immediately
  static Future<void> forceCleanupDuplicates() async {
    await removeDuplicateReports();
  }

  // AGGRESSIVE duplicate removal - removes ALL duplicates
  static Future<void> aggressiveDuplicateRemoval() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final uniqueReports = <String, MalwareReportModel>{};

    for (final report in reports) {
      final key =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';
      if (!uniqueReports.containsKey(key)) {
        uniqueReports[key] = report;
        print('‚úÖ KEEPING: ${report.name} (${report.malwareType})');
      } else {
        print('‚ùå REMOVING: ${report.name} (${report.malwareType})');
      }
    }

    // Clear everything and add only unique
    await box.clear();
    for (final report in uniqueReports.values) {
      await box.add(report);
    }

    print(
      '‚úÖ AGGRESSIVE CLEANUP COMPLETED! Kept ${uniqueReports.length} unique reports',
    );
  }

  // Clear all malware reports (for testing)
  static Future<void> clearAllReports() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.clear();
  }

  // Clear all duplicates and keep only unique reports
  static Future<void> clearAllDuplicates() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final uniqueReports = <String, MalwareReportModel>{};

    for (final report in reports) {
      final key =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';
      if (!uniqueReports.containsKey(key)) {
        uniqueReports[key] = report;
        print('‚úÖ KEEPING: ${report.name} (${report.malwareType})');
      } else {
        print('‚ùå REMOVING DUPLICATE: ${report.name} (${report.malwareType})');
      }
    }

    // Clear box and add only unique reports
    await box.clear();
    for (final report in uniqueReports.values) {
      await box.add(report);
    }

    print(
      '‚úÖ Duplicate cleanup completed. Kept ${uniqueReports.length} unique reports',
    );
  }

  // Test method to verify auto-sync
  static Future<void> testAutoSync() async {
    // Check connectivity
    final connectivity = await Connectivity().checkConnectivity();

    // Check unsynced reports
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final unsyncedReports = box.values
        .where((r) => r.isSynced != true)
        .toList();

    // Try to sync
    if (connectivity != ConnectivityResult.none) {
      await syncReports();
    }
  }

  static Future<List<Map<String, dynamic>>> fetchReportTypes() async {
    return await _apiService.fetchReportTypes();
  }

  static Future<List<Map<String, dynamic>>> fetchReportTypesByCategory(
    String categoryId,
  ) async {
    return await _apiService.fetchReportTypesByCategory(categoryId);
  }

  static Future<List<Map<String, dynamic>>> fetchReportCategories() async {
    final categories = await _apiService.fetchReportCategories();
    print('API returned: $categories'); // Debug print
    return categories;
  }

  // Test duplicate detection
  static Future<void> testDuplicateDetection() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();

    final seenKeys = <String>{};
    final duplicates = <String>[];

    for (final report in reports) {
      final key =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';
      if (seenKeys.contains(key)) {
        duplicates.add('${report.name} (${report.malwareType})');
        print('‚ùå DUPLICATE: ${report.name} (${report.malwareType})');
      } else {
        seenKeys.add(key);
        print('‚úÖ UNIQUE: ${report.name} (${report.malwareType})');
      }
    }

    if (duplicates.isNotEmpty) {
      print('‚ùå Duplicates found: ${duplicates.join(', ')}');
    }
  }

  // NUCLEAR OPTION - Clear everything and start fresh
  static Future<void> nuclearCleanup() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.clear();
  }

  // Debug method to test all endpoints and identify the issue
  static Future<void> debugMalwareBackendIssue() async {
    // Test 1: Check if malware endpoint exists
    await testMalwareEndpoint();

    // Test 2: Check if general endpoint works
    await testAlternativeMalwareEndpoint();

    // Test 3: Test payload structure
    await testMalwarePayloadStructure();
  }

  // Comprehensive offline sync method with retry mechanism
  static Future<void> syncOfflineReports() async {
    try {
      // Step 1: Check connectivity
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity == ConnectivityResult.none) {
        throw Exception('No internet connection available');
      }

      // Step 2: Initialize reference service
      await MalwareReferenceService.initialize();
      await MalwareReferenceService.refresh();

      // Step 3: Get all offline reports
      final box = Hive.box<MalwareReportModel>('malware_reports');
      final allReports = box.values.toList();
      final offlineReports = allReports
          .where((r) => r.isSynced != true)
          .toList();

      print(
        'üìä MALWARE-SYNC: Found ${offlineReports.length} offline reports out of ${allReports.length} total',
      );

      if (offlineReports.isEmpty) {
        return;
      }

      // Step 4: Sync each offline report with retry mechanism
      int successCount = 0;
      int failureCount = 0;
      List<String> failedReports = [];

      for (final report in offlineReports) {
        print(
          'üì§ MALWARE-SYNC: Syncing report ${report.id} - ${report.malwareType}',
        );

        bool reportSynced = false;
        int retryCount = 0;
        const maxRetries = 3;

        while (!reportSynced && retryCount < maxRetries) {
          try {
            if (retryCount > 0) {
              print(
                'üîÑ MALWARE-SYNC: Retry attempt ${retryCount + 1} for report ${report.id}',
              );
              // Wait before retry
              await Future.delayed(Duration(seconds: retryCount * 2));
            }

            final success = await sendToBackend(report);
            if (success) {
              // Mark as synced in local storage
              final key = report.id;
              final updated = report.copyWith(isSynced: true);
              await box.put(key, updated);
              successCount++;
              reportSynced = true;
            } else {
              retryCount++;
              print(
                '‚ùå MALWARE-SYNC: Failed to sync report ${report.id} (attempt ${retryCount})',
              );
            }
          } catch (e) {
            retryCount++;
            print(
              '‚ùå MALWARE-SYNC: Error syncing report ${report.id} (attempt ${retryCount}): $e',
            );
          }
        }

        if (!reportSynced) {
          failureCount++;
          failedReports.add('${report.malwareType} (${report.id})');
          print(
            '‚ùå MALWARE-SYNC: Failed to sync report ${report.id} after $maxRetries attempts',
          );
        }
      }

      print(
        'üìä MALWARE-SYNC: Sync completed - Success: $successCount, Failed: $failureCount',
      );

      if (failedReports.isNotEmpty) {
        print('‚ùå MALWARE-SYNC: Failed reports: ${failedReports.join(', ')}');
      }

      if (failureCount > 0) {
        throw Exception(
          'Some reports failed to sync: $failureCount failed, $successCount succeeded',
        );
      }

      print(
        '‚úÖ MALWARE-SYNC: Comprehensive offline sync completed successfully',
      );
    } catch (e) {
      rethrow;
    }
  }
}
