import 'package:hive/hive.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';

import '../../models/malware_report_model.dart';
import '../../config/api_config.dart';
import '../../services/api_service.dart';
import '../../services/jwt_service.dart';
import '../../services/malware_reference_service.dart';

class MalwareReportService {
  static final _box = Hive.box<MalwareReportModel>('malware_reports');
  static final ApiService _apiService = ApiService();

  static Future<void> saveReport(MalwareReportModel report) async {
    // Get current user ID from JWT token
    final keycloakUserId = await JwtService.getCurrentUserId();

    // Run diagnostics if no user ID found (device-specific issue)
    if (keycloakUserId == null) {
      print('‚ö†Ô∏è No user ID found - running token storage diagnostics...');
      await JwtService.diagnoseTokenStorage();
    }

    if (keycloakUserId != null) {
      report = report.copyWith(keycloakUserId: keycloakUserId);
    } else {
      // Fallback for device-specific issues
      print('‚ö†Ô∏è Using fallback user ID for device compatibility');
      report = report.copyWith(
        keycloakUserId: 'device_user_${DateTime.now().millisecondsSinceEpoch}',
      );
    }

    // Ensure unique timestamp for each report
    final now = DateTime.now().toUtc(); // Use UTC time consistently
    // Remove unique offset to prevent future timestamps
    // final uniqueOffset = (report.id.hashCode) % 1000;
    // final uniqueTimestamp = now.add(Duration(milliseconds: uniqueOffset));
    report = report.copyWith(date: now);

    // Always save to local storage first (offline-first approach)
    await _box.add(report);
    print(
      '‚úÖ Malware report saved locally with type ID: ${report.reportTypeId}',
    );

    // Try to sync if online
    final connectivity = await Connectivity().checkConnectivity();
    if (connectivity != ConnectivityResult.none) {
      print('üåê Online - attempting to sync report...');
      try {
        // Initialize reference service before syncing
        await MalwareReferenceService.initialize();
        bool success = await sendToBackend(report);
        if (success) {
          // Mark as synced
          final key = _box.keyAt(
            _box.length - 1,
          ); // Get the key of the last added item
          final updated = report.copyWith(isSynced: true);
          await _box.put(key, updated);
          print('‚úÖ Malware report synced successfully!');
        } else {
          print('‚ö†Ô∏è Failed to sync report - will retry later');
        }
      } catch (e) {
        print('‚ùå Error syncing report: $e - will retry later');
      }
    } else {
      print('üì± Offline - report saved locally for later sync');
    }

    // Remove duplicates immediately after saving
    await removeDuplicateReports();
  }

  static Future<void> saveReportOffline(MalwareReportModel report) async {
    // Get current user ID from JWT token
    final keycloakUserId = await JwtService.getCurrentUserId();
    if (keycloakUserId != null) {
      report = report.copyWith(keycloakUserId: keycloakUserId);
    }

    print('Saving malware report to local storage: ${report.toJson()}');
    await _box.add(report);

    // Remove duplicates immediately after saving (like scam/fraud)
    await removeDuplicateReports();

    print('Malware report saved successfully. Box length: ${_box.length}');
  }

  static Future<void> syncReports() async {
    final connectivity = await Connectivity().checkConnectivity();
    if (connectivity == ConnectivityResult.none) {
      print('üì± No internet connection - cannot sync');
      return;
    }

    // Initialize reference service before syncing
    print('üîÑ Initializing malware reference service...');
    await MalwareReferenceService.initialize();

    // Force refresh reference data before syncing
    print('üîÑ Refreshing malware reference data before sync...');
    await MalwareReferenceService.refresh();

    final box = Hive.box<MalwareReportModel>('malware_reports');
    final unsyncedReports = box.values
        .where((r) => r.isSynced != true)
        .toList();

    print('üîÑ Syncing ${unsyncedReports.length} unsynced malware reports...');

    for (var report in unsyncedReports) {
      try {
        print('üì§ Syncing report: ${report.name}');
        final success = await MalwareReportService.sendToBackend(report);
        if (success) {
          // Mark as synced
          final key = box.keyAt(box.values.toList().indexOf(report));
          final updated = report.copyWith(isSynced: true);
          await box.put(key, updated);
          print('‚úÖ Successfully synced: ${report.name}');
        } else {
          print('‚ùå Failed to sync: ${report.name}');
        }
      } catch (e) {
        print('‚ùå Error syncing report ${report.name}: $e');
      }
    }

    print('‚úÖ Sync completed for malware reports');
  }

  // Auto-sync when coming back online
  static Future<void> autoSyncWhenOnline() async {
    final connectivity = await Connectivity().checkConnectivity();
    if (connectivity != ConnectivityResult.none) {
      print('üåê Internet detected - auto-syncing malware reports...');
      await syncReports();
    }
  }

  // Test method to debug sync issues
  static Future<void> debugSync() async {
    print('üîç DEBUG: Testing malware sync process...');

    // Test all endpoints
    await MalwareReferenceService.testAllEndpoints();

    // Force refresh reference data
    await MalwareReferenceService.refresh();

    // Check if data is available
    print(
      '‚úÖ Has all required data: ${MalwareReferenceService.hasAllRequiredData}',
    );

    // Try to sync one report
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final unsyncedReports = box.values.where((r) => !r.isSynced).toList();

    if (unsyncedReports.isNotEmpty) {
      print(
        'üì§ Testing sync with first unsynced report: ${unsyncedReports.first.name}',
      );
      final success = await sendToBackend(unsyncedReports.first);
      print('üì§ Sync test result: $success');
    } else {
      print('üì§ No unsynced reports to test');
    }
  }

  // Force sync a specific report
  static Future<bool> forceSyncReport(MalwareReportModel report) async {
    print('üîÑ Force syncing report: ${report.name}');

    // Initialize reference service before syncing
    print('üîÑ Initializing malware reference service...');
    await MalwareReferenceService.initialize();

    // Force refresh reference data
    await MalwareReferenceService.refresh();

    final success = await sendToBackend(report);
    if (success) {
      // Mark as synced
      final box = Hive.box<MalwareReportModel>('malware_reports');
      final key = box.keyAt(box.values.toList().indexOf(report));
      final updated = report.copyWith(isSynced: true);
      await box.put(key, updated);
      print('‚úÖ Successfully force synced: ${report.name}');
    } else {
      print('‚ùå Failed to force sync: ${report.name}');
    }

    return success;
  }

  // Clear all malware reports (for testing)
  static Future<void> clearAllMalwareReports() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.clear();
    print('üóëÔ∏è Cleared all malware reports');
  }

  static Future<bool> sendToBackend(MalwareReportModel report) async {
    // Try the specific malware endpoint first
    final success = await _sendToMalwareEndpoint(report);
    if (success) {
      return true;
    }

    // If malware endpoint fails, try the general reports endpoint
    print('üîÑ Malware endpoint failed, trying general reports endpoint...');
    return await _sendToGeneralEndpoint(report);
  }

  static Future<bool> _sendToMalwareEndpoint(MalwareReportModel report) async {
    try {
      print('üîÑ Sending malware report to backend...');

      // Get actual ObjectId values from reference service
      final reportCategoryId =
          MalwareReferenceService.getMalwareReportCategoryId();
      final deviceTypeId = MalwareReferenceService.getDeviceTypeId(
        report.infectedDeviceType,
      );
      final detectTypeId = MalwareReferenceService.getDetectionTypeId(
        report.detectionMethod,
      );
      final operatingSystemId = MalwareReferenceService.getOperatingSystemId(
        report.operatingSystem,
      );

      print('üîÑ Using ObjectId values:');
      print('  - reportCategoryId: $reportCategoryId');
      print(
        '  - reportTypeId: ${report.reportTypeId} (from selected dropdown)',
      );
      print('  - deviceTypeId: $deviceTypeId');
      print('  - detectTypeId: $detectTypeId');
      print('  - operatingSystemId: $operatingSystemId');

      // Prepare data with actual ObjectId values (like scam and fraud reports)
      final reportData = {
        'reportCategoryId': reportCategoryId.isNotEmpty
            ? reportCategoryId
            : (report.reportCategoryId ?? 'malware_category_id'),
        'reportTypeId': report.reportTypeId ?? 'malware_type_id',
        'alertLevels': report.alertLevels ?? '',
        'deviceTypeId': deviceTypeId.isNotEmpty
            ? deviceTypeId
            : await _getDynamicDeviceTypeId(),
        'detectTypeId': detectTypeId.isNotEmpty
            ? detectTypeId
            : await _getDynamicDetectionTypeId(),
        'operatingSystemName': operatingSystemId.isNotEmpty
            ? operatingSystemId
            : await _getDynamicOperatingSystemId(),
        'location':
            report.locationCoordinates ??
            {
              'type': 'Point',
              'coordinates': [0.0, 0.0], // Fallback coordinates
            },
        'attackName': report.name ?? 'Malware Report',
        'attackSystem': report.systemAffected ?? '',
        'fileName': report.fileName ?? '',
        'description': report.description ?? '',
        'incidentDate':
            report.incidentDate?.toIso8601String() ??
            DateTime.now().toIso8601String(),
        'createdAt':
            report.createdAt?.toIso8601String() ??
            DateTime.now().toIso8601String(),
        'updatedAt':
            report.updatedAt?.toIso8601String() ??
            DateTime.now().toIso8601String(),
        'keycloackUserId':
            report.keycloakUserId ?? 'anonymous_user', // Fallback for no auth
        'createdBy': report.keycloakUserId ?? 'anonymous_user',
        'isActive': true,
        'reportOutcome': false, // Changed to false as requested
        'screenshots': report.screenshotUrls ?? [],
        'documents': report.documentUrls ?? [],
        'voiceMessages': report.voiceMessageUrls ?? [],
      };

      print('üì§ Sending malware report to backend...');
      print('üì§ Report data: ${jsonEncode(reportData)}');
      print('üîç Final alert level being sent: ${reportData['alertLevels']}');
      print('üîç Original report alert level: ${report.alertLevels}');
      print('üîç Report ID: ${report.id}');
      print('üîç Alert level in reportData: "${reportData['alertLevels']}"');
      print(
        'üîç Alert level in reportData type: ${reportData['alertLevels'].runtimeType}',
      );
      print(
        'üîç Alert level in reportData is null: ${reportData['alertLevels'] == null}',
      );
      print(
        'üîç Alert level in reportData is empty: ${(reportData['alertLevels'] as String?)?.isEmpty}',
      );
      print('üîç Full reportData keys: ${reportData.keys.toList()}');
      print('üîç Full reportData values: ${reportData.values.toList()}');
      print('üîç Alert level in report object: ${report.alertLevels}');
      print('üîç Alert level type in report: ${report.alertLevels.runtimeType}');
      print('üîç Alert level is null in report: ${report.alertLevels == null}');
      print(
        'üîç Alert level is empty in report: ${report.alertLevels?.isEmpty}',
      );

      final url =
          '${ApiConfig.reportsBaseUrl}${ApiConfig.malwareReportsEndpoint}';
      print('üîç DEBUG - Full URL: $url');
      print(
        'üîç DEBUG - Request headers: ${jsonEncode({'Content-Type': 'application/json', 'Accept': 'application/json'})}',
      );
      print('üîç DEBUG - Request body length: ${jsonEncode(reportData).length}');

      final response = await http.post(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: jsonEncode(reportData),
      );

      print('üì• Send to backend response status: ${response.statusCode}');
      print('üì• Send to backend response headers: ${response.headers}');
      print('üì• Send to backend response body: ${response.body}');
      print(
        'üîç DEBUG - Response content-type: ${response.headers['content-type']}',
      );
      print(
        'üîç DEBUG - Response content-length: ${response.headers['content-length']}',
      );
      print('üîç DEBUG - Response URL: ${response.request?.url}');
      print('üîç DEBUG - Response method: ${response.request?.method}');

      if (response.statusCode == 200 || response.statusCode == 201) {
        print('‚úÖ Malware report sent successfully!');
        return true;
      } else {
        print('‚ùå Malware report failed with status: ${response.statusCode}');
        return false;
      }
    } catch (e) {
      print('‚ùå Error sending malware report to backend: $e');
      print('üîç This might be due to:');
      print('   - Backend server is offline');
      print('   - Network connectivity issues');
      print('   - Incorrect API endpoint');
      print('   - Invalid request format');
      return false;
    }
  }

  static Future<bool> _sendToGeneralEndpoint(MalwareReportModel report) async {
    try {
      print('üîÑ Sending malware report to general reports endpoint...');

      // Get actual ObjectId values from reference service
      final reportCategoryId =
          MalwareReferenceService.getMalwareReportCategoryId();
      final deviceTypeId = MalwareReferenceService.getDeviceTypeId(
        report.infectedDeviceType,
      );
      final detectTypeId = MalwareReferenceService.getDetectionTypeId(
        report.detectionMethod,
      );
      final operatingSystemId = MalwareReferenceService.getOperatingSystemId(
        report.operatingSystem,
      );

      print('üîÑ Using ObjectId values for general endpoint:');
      print('  - reportCategoryId: $reportCategoryId');
      print('  - reportTypeId: ${report.reportTypeId}');
      print('  - deviceTypeId: $deviceTypeId');
      print('  - detectTypeId: $detectTypeId');
      print('  - operatingSystemId: $operatingSystemId');

      // Prepare data for general reports endpoint (like scam and fraud)
      final reportData = {
        'reportCategoryId': reportCategoryId.isNotEmpty
            ? reportCategoryId
            : (report.reportCategoryId ?? 'malware_category_id'),
        'reportTypeId': report.reportTypeId ?? 'malware_type_id',
        'alertLevels': report.alertLevels ?? '',
        'deviceTypeId': deviceTypeId.isNotEmpty
            ? deviceTypeId
            : await _getDynamicDeviceTypeId(),
        'detectTypeId': detectTypeId.isNotEmpty
            ? detectTypeId
            : await _getDynamicDetectionTypeId(),
        'operatingSystemName': operatingSystemId.isNotEmpty
            ? operatingSystemId
            : await _getDynamicOperatingSystemId(),
        'location':
            report.locationCoordinates ??
            {
              'type': 'Point',
              'coordinates': [0.0, 0.0],
            },
        'attackName': report.name ?? 'Malware Report',
        'attackSystem': report.systemAffected ?? '',
        'fileName': report.fileName ?? '',
        'description': report.description ?? '',
        'incidentDate':
            report.incidentDate?.toIso8601String() ??
            DateTime.now().toIso8601String(),
        'createdAt':
            report.createdAt?.toIso8601String() ??
            DateTime.now().toIso8601String(),
        'updatedAt':
            report.updatedAt?.toIso8601String() ??
            DateTime.now().toIso8601String(),
        'keycloackUserId': report.keycloakUserId ?? 'anonymous_user',
        'createdBy': report.keycloakUserId ?? 'anonymous_user',
        'isActive': true,
        'reportOutcome': false, // Changed to false as requested
        'screenshots': report.screenshotUrls ?? [],
        'documents': report.documentUrls ?? [],
        'voiceMessages': report.voiceMessageUrls ?? [],
      };

      final url =
          '${ApiConfig.reportsBaseUrl}${ApiConfig.reportSecurityIssueEndpoint}';
      print('üîç DEBUG - General endpoint URL: $url');
      print('üì§ Sending to general endpoint: ${jsonEncode(reportData)}');

      final response = await http.post(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: jsonEncode(reportData),
      );

      print('üì• General endpoint response status: ${response.statusCode}');
      print('üì• General endpoint response body: ${response.body}');

      if (response.statusCode == 200 || response.statusCode == 201) {
        print('‚úÖ Malware report sent successfully via general endpoint!');
        return true;
      } else {
        print('‚ùå General endpoint failed with status: ${response.statusCode}');
        return false;
      }
    } catch (e) {
      print('‚ùå Error sending to general endpoint: $e');
      return false;
    }
  }

  static Future<void> updateReport(MalwareReportModel report) async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.put(report.id, report);
  }

  // Dynamic methods to get ObjectIds from reference service
  static Future<String> _getDynamicReportCategoryId(String categoryName) async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getMalwareReportCategoryId();
    } catch (e) {
      print('‚ùå Error getting dynamic report category ID: $e');
      return '';
    }
  }

  static Future<String> _getDynamicReportTypeId(String typeName) async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getMalwareReportTypeId();
    } catch (e) {
      print('‚ùå Error getting dynamic report type ID: $e');
      return '';
    }
  }

  static Future<String> _getDynamicDeviceTypeId() async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getDeviceTypeId(
        'desktop',
      ); // Default to desktop
    } catch (e) {
      print('‚ùå Error getting dynamic device type ID: $e');
      return '';
    }
  }

  static Future<String> _getDynamicDetectionTypeId() async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getDetectionTypeId(
        'antivirus',
      ); // Default to antivirus
    } catch (e) {
      print('‚ùå Error getting dynamic detection type ID: $e');
      return '';
    }
  }

  static Future<String> _getDynamicOperatingSystemId() async {
    try {
      await MalwareReferenceService.initialize();
      return MalwareReferenceService.getOperatingSystemId(
        'windows',
      ); // Default to windows
    } catch (e) {
      print('‚ùå Error getting dynamic operating system ID: $e');
      return '';
    }
  }

  static List<MalwareReportModel> getLocalReports() {
    print('Getting local malware reports. Box length: ${_box.length}');
    final reports = _box.values.toList();
    print('Retrieved ${reports.length} malware reports from local storage');
    return reports;
  }

  static Future<void> updateExistingReportsWithKeycloakUserId() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();

    for (int i = 0; i < reports.length; i++) {
      final report = reports[i];
      if (report.keycloakUserId == null) {
        final keycloakUserId = await JwtService.getCurrentUserId();
        if (keycloakUserId != null) {
          final updatedReport = report.copyWith(keycloakUserId: keycloakUserId);
          final key = box.keyAt(i);
          await box.put(key, updatedReport);
        }
      }
    }
  }

  static Future<void> removeDuplicateReports() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final seenContent = <String>{};
    final toDelete = <int>[];

    print('=== CLEARING MALWARE DUPLICATES ===');
    print('Before cleanup: ${reports.length} malware reports');

    for (int i = 0; i < reports.length; i++) {
      final report = reports[i];
      // Use content-based detection: name + type + device + location
      final contentKey =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';

      if (seenContent.contains(contentKey)) {
        toDelete.add(i);
        print(
          '‚ùå DUPLICATE FOUND: ${report.name} (${report.malwareType}) - ${report.infectedDeviceType} - ${report.location}',
        );
      } else {
        seenContent.add(contentKey);
        print(
          '‚úÖ KEEPING: ${report.name} (${report.malwareType}) - ${report.infectedDeviceType} - ${report.location}',
        );
      }
    }

    // Delete duplicates in reverse order to maintain indices
    for (int i = toDelete.length - 1; i >= 0; i--) {
      final key = box.keyAt(toDelete[i]);
      await box.delete(key);
      print('üóëÔ∏è DELETED: ${reports[toDelete[i]].name}');
    }

    final remainingReports = box.values.toList();
    print('After cleanup: ${remainingReports.length} malware reports');
    print('Removed ${toDelete.length} duplicate malware reports');
    print('=== END MALWARE DUPLICATE CLEANUP ===');
  }

  // STRICT duplicate check - Check for exact duplicates before saving
  static Future<bool> checkForExactDuplicate(
    MalwareReportModel newReport,
  ) async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final existingReports = box.values.toList();

    print(
      'üîç STRICT DUPLICATE CHECK: ${newReport.name} (${newReport.malwareType})',
    );

    for (final existingReport in existingReports) {
      // Check for EXACT match (name + type + device + location)
      if (existingReport.name == newReport.name &&
          existingReport.malwareType == newReport.malwareType &&
          existingReport.infectedDeviceType == newReport.infectedDeviceType &&
          existingReport.location == newReport.location) {
        print(
          '‚ùå EXACT DUPLICATE FOUND: ${newReport.name} (${newReport.malwareType}) - ${newReport.infectedDeviceType} - ${newReport.location}',
        );
        return true;
      }
    }

    print(
      '‚úÖ NO EXACT DUPLICATE: ${newReport.name} (${newReport.malwareType}) - ${newReport.infectedDeviceType} - ${newReport.location}',
    );
    return false;
  }

  // Convert payload format to MalwareReportModel
  static MalwareReportModel fromPayload(Map<String, dynamic> payload) {
    return MalwareReportModel(
      id: payload['id'] ?? DateTime.now().millisecondsSinceEpoch.toString(),
      malwareType: payload['attackName'] ?? 'Unknown Malware',
      infectedDeviceType: payload['deviceTypeId'] ?? 'Unknown Device',
      operatingSystem: payload['attackSystem'] ?? 'Unknown OS',
      detectionMethod: payload['detectTypeId'] ?? 'Unknown Detection',
      location: _extractLocationString(payload['location']),
      fileName: payload['attackName'] ?? 'Unknown File',
      name: payload['attackName'] ?? 'Unknown Attack',
      systemAffected: payload['attackSystem'] ?? 'Unknown System',
      alertSeverityLevel: payload['alertLevels'] ?? 'Medium',
      date: DateTime.now(),
      isSynced: false,
      keycloakUserId: payload['keycloackUserId'],
      reportCategoryId: payload['reportCategoryId'],
      reportTypeId: payload['reportTypeId'],
      alertLevels: payload['alertLevels'],
      deviceTypeId: payload['deviceTypeId'],
      detectTypeId: payload['detectTypeId'],
      operatingSystemName: payload['operatingSystemName'],
      attackName: payload['attackName'],
      attackSystem: payload['attackSystem'],
      createdBy: payload['createdBy'],
      // Removed status field
      description: payload['description'],
      incidentDate: payload['incidentDate'] != null
          ? DateTime.parse(payload['incidentDate'])
          : null,
      reportOutcome: payload['reportOutcome'],
      locationCoordinates: payload['location'],
      screenshots: payload['screenshots'] ?? [],
      voiceMessages: payload['voiceMessages'] ?? [],
      documents: payload['documents'] ?? [],
    );
  }

  // Helper function to extract location string from coordinates
  static String _extractLocationString(dynamic location) {
    if (location is Map<String, dynamic>) {
      if (location['coordinates'] is List &&
          location['coordinates'].length >= 2) {
        final lat = location['coordinates'][1];
        final lng = location['coordinates'][0];
        return '$lat, $lng';
      }
    }
    return 'Unknown Location';
  }

  // Create malware report from payload and save
  static Future<void> createFromPayload(Map<String, dynamic> payload) async {
    try {
      print('üîÑ Creating malware report from payload...');

      // Convert payload to model
      final report = fromPayload(payload);

      // Check for duplicates before saving
      final isDuplicate = await checkForExactDuplicate(report);
      if (isDuplicate) {
        print('‚ö†Ô∏è Duplicate report detected - skipping save');
        return;
      }

      // Save the report
      await saveReport(report);

      print('‚úÖ Malware report created and saved successfully');
    } catch (e) {
      print('‚ùå Error creating malware report from payload: $e');
    }
  }

  // Update existing malware report with payload
  static Future<void> updateFromPayload(
    String reportId,
    Map<String, dynamic> payload,
  ) async {
    try {
      print('üîÑ Updating malware report with payload...');

      final box = Hive.box<MalwareReportModel>('malware_reports');
      final existingReport = box.get(reportId);

      if (existingReport == null) {
        print('‚ùå Report not found with ID: $reportId');
        return;
      }

      // Update the report with new payload data
      final updatedReport = existingReport.copyWith(
        reportCategoryId: payload['reportCategoryId'],
        reportTypeId: payload['reportTypeId'],
        alertLevels: payload['alertLevels'],
        deviceTypeId: payload['deviceTypeId'],
        detectTypeId: payload['detectTypeId'],
        operatingSystemName: payload['operatingSystemName'],
        attackName: payload['attackName'],
        attackSystem: payload['attackSystem'],

        description: payload['description'],
        incidentDate: payload['incidentDate'] != null
            ? DateTime.parse(payload['incidentDate'])
            : null,
        reportOutcome: payload['reportOutcome'],
        locationCoordinates: payload['location'],
        screenshots: payload['screenshots'] ?? [],
        voiceMessages: payload['voiceMessages'] ?? [],
        documents: payload['documents'] ?? [],
      );

      // Save updated report
      await box.put(reportId, updatedReport);

      // Try to sync with backend
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        final success = await sendToBackend(updatedReport);
        if (success) {
          final syncedReport = updatedReport.copyWith(isSynced: true);
          await box.put(reportId, syncedReport);
          print('‚úÖ Malware report updated and synced successfully');
        } else {
          print('‚ö†Ô∏è Failed to sync updated report - will retry later');
        }
      } else {
        print('üì± Offline - updated report saved locally for later sync');
      }
    } catch (e) {
      print('‚ùå Error updating malware report from payload: $e');
    }
  }

  // Malware-specific update method using your exact payload format
  static Future<void> updateMalwareWithPayload(
    Map<String, dynamic> malwarePayload,
  ) async {
    try {
      print('üîÑ Updating malware report with your payload format...');

      // Extract the report ID from payload or generate one
      String reportId =
          malwarePayload['id'] ??
          DateTime.now().millisecondsSinceEpoch.toString();

      // Create or update the malware report
      final box = Hive.box<MalwareReportModel>('malware_reports');

      // Check if report exists
      final existingReport = box.get(reportId);

      if (existingReport != null) {
        // Update existing report
        final updatedReport = existingReport.copyWith(
          reportCategoryId: malwarePayload['reportCategoryId'],
          reportTypeId: malwarePayload['reportTypeId'],
          alertLevels: malwarePayload['alertLevels'],
          keycloakUserId: malwarePayload['keycloackUserId'],
          locationCoordinates: malwarePayload['location'],
          deviceTypeId: malwarePayload['deviceTypeId'],
          detectTypeId: malwarePayload['detectTypeId'],
          operatingSystemName: malwarePayload['operatingSystemName'],
          attackName: malwarePayload['attackName'],
          attackSystem: malwarePayload['attackSystem'],
          description: malwarePayload['description'],
          incidentDate: malwarePayload['incidentDate'] != null
              ? DateTime.parse(malwarePayload['incidentDate'])
              : null,
          createdBy: malwarePayload['createdBy'],
          reportOutcome: malwarePayload['reportOutcome'],
          screenshots: malwarePayload['screenshots'] ?? [],
          voiceMessages: malwarePayload['voiceMessages'] ?? [],
          documents: malwarePayload['documents'] ?? [],
        );

        await box.put(reportId, updatedReport);
        print('‚úÖ Existing malware report updated successfully');

        // Try to sync with backend
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.none) {
          final success = await sendToBackend(updatedReport);
          if (success) {
            final syncedReport = updatedReport.copyWith(isSynced: true);
            await box.put(reportId, syncedReport);
            print('‚úÖ Malware report synced to backend');
          }
        }
      } else {
        // Create new report from payload
        final newReport = MalwareReportModel(
          id: reportId,
          malwareType: malwarePayload['attackName'] ?? 'Unknown Malware',
          infectedDeviceType:
              malwarePayload['deviceTypeId'] ?? 'Unknown Device',
          operatingSystem: malwarePayload['attackSystem'] ?? 'Unknown OS',
          detectionMethod:
              malwarePayload['detectTypeId'] ?? 'Unknown Detection',
          location: _extractLocationString(malwarePayload['location']),
          fileName: malwarePayload['attackName'] ?? 'Unknown File',
          name: malwarePayload['attackName'] ?? 'Unknown Attack',
          systemAffected: malwarePayload['attackSystem'] ?? 'Unknown System',
          alertSeverityLevel: malwarePayload['alertLevels'] ?? 'Medium',
          date: DateTime.now(),
          isSynced: false,
          keycloakUserId: malwarePayload['keycloackUserId'],
          reportCategoryId: malwarePayload['reportCategoryId'],
          reportTypeId: malwarePayload['reportTypeId'],
          alertLevels: malwarePayload['alertLevels'],
          deviceTypeId: malwarePayload['deviceTypeId'],
          detectTypeId: malwarePayload['detectTypeId'],
          operatingSystemName: malwarePayload['operatingSystemName'],
          attackName: malwarePayload['attackName'],
          attackSystem: malwarePayload['attackSystem'],
          createdBy: malwarePayload['createdBy'],
          description: malwarePayload['description'],
          incidentDate: malwarePayload['incidentDate'] != null
              ? DateTime.parse(malwarePayload['incidentDate'])
              : null,
          reportOutcome: malwarePayload['reportOutcome'],
          locationCoordinates: malwarePayload['location'],
          screenshots: malwarePayload['screenshots'] ?? [],
          voiceMessages: malwarePayload['voiceMessages'] ?? [],
          documents: malwarePayload['documents'] ?? [],
        );

        await box.add(newReport);
        print('‚úÖ New malware report created from payload');

        // Try to sync with backend
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.none) {
          final success = await sendToBackend(newReport);
          if (success) {
            final syncedReport = newReport.copyWith(isSynced: true);
            await box.put(reportId, syncedReport);
            print('‚úÖ New malware report synced to backend');
          }
        }
      }
    } catch (e) {
      print('‚ùå Error updating malware with payload: $e');
    }
  }

  // Test your specific malware payload
  static Future<void> testYourMalwarePayload() async {
    try {
      print('üß™ Testing your malware payload format...');

      // Your exact payload structure
      final yourPayload = {
        "reportCategoryId": "64e8b0a13c9f9c1e2aa1a111",
        "reportTypeId": "64e8b1b63c9f9c1e2aa1a222",
        "alertLevels": "64e8b2c83c9f9c1e2aa1a333",
        "keycloackUserId": "123e4567-e89b-12d3-a456-426614174000",
        "location": {
          "type": "Point",
          "coordinates": [77.5946, 12.9716], // Bangalore
        },
        "deviceTypeId": "64e8b4d93c9f9c1e2aa1a444",
        "detectTypeId": "64e8b5ea3c9f9c1e2aa1a555",
        "operatingSystemName": "64e8b6fb3c9f9c1e2aa1a666",
        "attackName": "Remote Access Trojan",
        "attackSystem": "Windows 10",
        "description":
            "Suspicious executable running in background. Data being sent to unknown IP.",
        "incidentDate": "2025-07-25T00:00:00.000Z",
        "createdBy": "security.admin@example.com",
        "reportOutcome": false,
        "screenshots": [],
        "voiceMessages": [],
        "documents": [],
      };

      // Update malware report with your payload
      await updateMalwareWithPayload(yourPayload);

      print('‚úÖ Your malware payload test completed successfully!');
      print(
        'üìù You can now use updateMalwareWithPayload() with your exact payload format',
      );
    } catch (e) {
      print('‚ùå Test failed: $e');
    }
  }

  // Test malware payload structure (like scam and fraud)
  static Future<void> testMalwarePayloadStructure() async {
    try {
      print('üß™ Testing malware payload structure (like scam and fraud)...');

      // Create a test malware report
      final testReport = MalwareReportModel(
        id: 'test_malware_${DateTime.now().millisecondsSinceEpoch}',
        malwareType: 'Test Malware',
        infectedDeviceType: 'Desktop',
        operatingSystem: 'Windows 10',
        detectionMethod: 'Antivirus',
        location: 'Test Location',
        fileName: 'test.exe',
        name: 'Test Malware Report',
        systemAffected: 'Test System',
        alertSeverityLevel: 'High',
        alertLevels: '64e8b2c83c9f9c1e2aa1a333', // Test alert level ID
        date: DateTime.now(),
        isSynced: false,
        keycloakUserId: 'test_user_123',
        reportCategoryId: '64e8b0a13c9f9c1e2aa1a111',
        reportTypeId: '64e8b1b63c9f9c1e2aa1a222',
        deviceTypeId: '64e8b4d93c9f9c1e2aa1a444',
        detectTypeId: '64e8b5ea3c9f9c1e2aa1a555',
        operatingSystemName: '64e8b6fb3c9f9c1e2aa1a666',
        attackName: 'Test Attack',
        attackSystem: 'Test System',
        createdBy: 'test@example.com',
        isActive: true,
        description: 'Test malware description',
        incidentDate: DateTime.now(),
        reportOutcome: true,
        locationCoordinates: {
          'type': 'Point',
          'coordinates': [0.0, 0.0],
        },
        screenshotUrls: [],
        voiceMessageUrls: [],
        documentUrls: [],
      );

      // Test sending to backend
      final success = await sendToBackend(testReport);
      print('üì§ Test malware payload result: $success');

      if (success) {
        print('‚úÖ Malware payload structure test passed!');
        print('üìù Malware reports should now work like scam and fraud reports');
      } else {
        print('‚ùå Malware payload structure test failed');
        print('üîç Check the console logs for detailed error information');
      }
    } catch (e) {
      print('‚ùå Test failed: $e');
    }
  }

  // Test if malware endpoint exists
  static Future<void> testMalwareEndpoint() async {
    try {
      print('üß™ Testing if malware endpoint exists...');

      final url =
          '${ApiConfig.reportsBaseUrl}${ApiConfig.malwareReportsEndpoint}';
      print('üîç Testing URL: $url');

      // Test with GET request to see if endpoint exists
      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      );

      print('üì• Endpoint test response status: ${response.statusCode}');
      print('üì• Endpoint test response body: ${response.body}');

      if (response.statusCode == 200 || response.statusCode == 404) {
        print('‚úÖ Malware endpoint exists (status: ${response.statusCode})');
      } else {
        print(
          '‚ùå Malware endpoint might not exist (status: ${response.statusCode})',
        );
      }
    } catch (e) {
      print('‚ùå Error testing malware endpoint: $e');
      print('üîç This might indicate the endpoint does not exist');
    }
  }

  // Test alternative malware endpoint
  static Future<void> testAlternativeMalwareEndpoint() async {
    try {
      print('üß™ Testing alternative malware endpoint...');

      // Try the general reports endpoint like scam and fraud
      final url =
          '${ApiConfig.reportsBaseUrl}${ApiConfig.reportSecurityIssueEndpoint}';
      print('üîç Testing alternative URL: $url');

      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      );

      print(
        'üì• Alternative endpoint test response status: ${response.statusCode}',
      );
      print('üì• Alternative endpoint test response body: ${response.body}');

      if (response.statusCode == 200) {
        print('‚úÖ Alternative endpoint works!');
        print(
          'üîç You might need to use the general reports endpoint for malware',
        );
      } else {
        print(
          '‚ùå Alternative endpoint also failed (status: ${response.statusCode})',
        );
      }
    } catch (e) {
      print('‚ùå Error testing alternative endpoint: $e');
    }
  }

  // Add method to get current location dynamically (same as scam reports)
  static Future<Map<String, dynamic>> _getCurrentLocation() async {
    try {
      print('üìç Getting current location for malware report...');

      // Check if location services are enabled
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        print('‚ùå Location services are disabled');
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
          'address': 'Location services disabled',
        };
      }

      // Check location permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          print('‚ùå Location permission denied');
          return {
            'type': 'Point',
            'coordinates': [0.0, 0.0], // Fallback coordinates
            'address': 'Location permission denied',
          };
        }
      }

      if (permission == LocationPermission.deniedForever) {
        print('‚ùå Location permission denied forever');
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
          'address': 'Location permission denied',
        };
      }

      // Get current position
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10),
      );

      print(
        '‚úÖ Location obtained for malware report: ${position.latitude}, ${position.longitude}',
      );

      // Get real address using geocoding
      String address = '${position.latitude}, ${position.longitude}';

      try {
        List<Placemark> placemarks = await placemarkFromCoordinates(
          position.latitude,
          position.longitude,
        );

        if (placemarks.isNotEmpty) {
          Placemark placemark = placemarks[0];
          address = [
            placemark.street,
            placemark.subLocality,
            placemark.locality,
            placemark.administrativeArea,
            placemark.country,
          ].where((e) => e != null && e.isNotEmpty).join(', ');
        }
      } catch (e) {
        print('‚ùå Error getting address from coordinates: $e');
        // Keep the coordinates as fallback
      }

      return {
        'type': 'Point',
        'coordinates': [
          position.longitude,
          position.latitude,
        ], // [lng, lat] format
        'address': address,
      };
    } catch (e) {
      print('‚ùå Error getting location for malware report: $e');
      return {
        'type': 'Point',
        'coordinates': [0.0, 0.0], // Fallback coordinates
        'address': 'Location services disabled',
      };
    }
  }

  // Updated malware update method with dynamic location
  static Future<void> updateMalwareWithLocation(
    Map<String, dynamic> malwarePayload,
  ) async {
    try {
      print('üîÑ Updating malware report with location...');

      // Get current location
      final location = await _getCurrentLocation();

      // Update payload with current location
      final updatedPayload = Map<String, dynamic>.from(malwarePayload);
      updatedPayload['location'] = location;

      // Extract the report ID from payload or generate one
      String reportId =
          malwarePayload['id'] ??
          DateTime.now().millisecondsSinceEpoch.toString();

      // Create or update the malware report
      final box = Hive.box<MalwareReportModel>('malware_reports');

      // Check if report exists
      final existingReport = box.get(reportId);

      if (existingReport != null) {
        // Update existing report
        final updatedReport = existingReport.copyWith(
          reportCategoryId: updatedPayload['reportCategoryId'],
          reportTypeId: updatedPayload['reportTypeId'],
          alertLevels: updatedPayload['alertLevels'],
          keycloakUserId: updatedPayload['keycloackUserId'],
          locationCoordinates: updatedPayload['location'],
          deviceTypeId: updatedPayload['deviceTypeId'],
          detectTypeId: updatedPayload['detectTypeId'],
          operatingSystemName: updatedPayload['operatingSystemName'],
          attackName: updatedPayload['attackName'],
          attackSystem: updatedPayload['attackSystem'],
          description: updatedPayload['description'],
          incidentDate: updatedPayload['incidentDate'] != null
              ? DateTime.parse(updatedPayload['incidentDate'])
              : null,
          createdBy: updatedPayload['createdBy'],
          reportOutcome: updatedPayload['reportOutcome'],
          screenshots: updatedPayload['screenshots'] ?? [],
          voiceMessages: updatedPayload['voiceMessages'] ?? [],
          documents: updatedPayload['documents'] ?? [],
        );

        await box.put(reportId, updatedReport);
        print('‚úÖ Existing malware report updated with location');

        // Try to sync with backend
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.none) {
          final success = await sendToBackend(updatedReport);
          if (success) {
            final syncedReport = updatedReport.copyWith(isSynced: true);
            await box.put(reportId, syncedReport);
            print('‚úÖ Malware report with location synced to backend');
          }
        }
      } else {
        // Create new report from payload with location
        final newReport = MalwareReportModel(
          id: reportId,
          malwareType: updatedPayload['attackName'] ?? 'Unknown Malware',
          infectedDeviceType:
              updatedPayload['deviceTypeId'] ?? 'Unknown Device',
          operatingSystem: updatedPayload['attackSystem'] ?? 'Unknown OS',
          detectionMethod:
              updatedPayload['detectTypeId'] ?? 'Unknown Detection',
          location: _extractLocationString(updatedPayload['location']),
          fileName: updatedPayload['attackName'] ?? 'Unknown File',
          name: updatedPayload['attackName'] ?? 'Unknown Attack',
          systemAffected: updatedPayload['attackSystem'] ?? 'Unknown System',
          alertSeverityLevel: updatedPayload['alertLevels'] ?? 'Medium',
          date: DateTime.now(),
          isSynced: false,
          keycloakUserId: updatedPayload['keycloackUserId'],
          reportCategoryId: updatedPayload['reportCategoryId'],
          reportTypeId: updatedPayload['reportTypeId'],
          alertLevels: updatedPayload['alertLevels'],
          deviceTypeId: updatedPayload['deviceTypeId'],
          detectTypeId: updatedPayload['detectTypeId'],
          operatingSystemName: updatedPayload['operatingSystemName'],
          attackName: updatedPayload['attackName'],
          attackSystem: updatedPayload['attackSystem'],
          createdBy: updatedPayload['createdBy'],
          // Removed status field
          description: updatedPayload['description'],
          incidentDate: updatedPayload['incidentDate'] != null
              ? DateTime.parse(updatedPayload['incidentDate'])
              : null,
          reportOutcome: updatedPayload['reportOutcome'],
          locationCoordinates: updatedPayload['location'],
          screenshots: updatedPayload['screenshots'] ?? [],
          voiceMessages: updatedPayload['voiceMessages'] ?? [],
          documents: updatedPayload['documents'] ?? [],
        );

        await box.add(newReport);
        print('‚úÖ New malware report created with location');

        // Try to sync with backend
        final connectivity = await Connectivity().checkConnectivity();
        if (connectivity != ConnectivityResult.none) {
          final success = await sendToBackend(newReport);
          if (success) {
            final syncedReport = newReport.copyWith(isSynced: true);
            await box.put(reportId, syncedReport);
            print('‚úÖ New malware report with location synced to backend');
          }
        }
      }
    } catch (e) {
      print('‚ùå Error updating malware with location: $e');
    }
  }

  // Check if a report is a duplicate before saving (legacy method)
  static Future<bool> isDuplicateReport(MalwareReportModel newReport) async {
    return await checkForExactDuplicate(newReport);
  }

  // Force cleanup all duplicates immediately
  static Future<void> forceCleanupDuplicates() async {
    print('üßπ FORCE CLEANING ALL MALWARE DUPLICATES...');
    await removeDuplicateReports();
    print('‚úÖ Force cleanup completed');
  }

  // AGGRESSIVE duplicate removal - removes ALL duplicates
  static Future<void> aggressiveDuplicateRemoval() async {
    print('üî• AGGRESSIVE DUPLICATE REMOVAL...');
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final uniqueReports = <String, MalwareReportModel>{};

    print('üìä Total reports before: ${reports.length}');

    for (final report in reports) {
      final key =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';
      if (!uniqueReports.containsKey(key)) {
        uniqueReports[key] = report;
        print('‚úÖ KEEPING: ${report.name} (${report.malwareType})');
      } else {
        print('‚ùå REMOVING: ${report.name} (${report.malwareType})');
      }
    }

    // Clear everything and add only unique
    await box.clear();
    for (final report in uniqueReports.values) {
      await box.add(report);
    }

    print(
      '‚úÖ AGGRESSIVE CLEANUP COMPLETED! Kept ${uniqueReports.length} unique reports',
    );
  }

  // Clear all malware reports (for testing)
  static Future<void> clearAllReports() async {
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.clear();
    print('üóëÔ∏è All malware reports cleared');
  }

  // Clear all duplicates and keep only unique reports
  static Future<void> clearAllDuplicates() async {
    print('üßπ CLEARING ALL DUPLICATES AND KEEPING ONLY UNIQUE REPORTS...');
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();
    final uniqueReports = <String, MalwareReportModel>{};

    for (final report in reports) {
      final key =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';
      if (!uniqueReports.containsKey(key)) {
        uniqueReports[key] = report;
        print('‚úÖ KEEPING: ${report.name} (${report.malwareType})');
      } else {
        print('‚ùå REMOVING DUPLICATE: ${report.name} (${report.malwareType})');
      }
    }

    // Clear box and add only unique reports
    await box.clear();
    for (final report in uniqueReports.values) {
      await box.add(report);
    }

    print(
      '‚úÖ Duplicate cleanup completed. Kept ${uniqueReports.length} unique reports',
    );
  }

  // Test method to verify auto-sync
  static Future<void> testAutoSync() async {
    print('üß™ TESTING AUTO SYNC...');

    // Check connectivity
    final connectivity = await Connectivity().checkConnectivity();
    print('üåê Connectivity: $connectivity');

    // Check unsynced reports
    final box = Hive.box<MalwareReportModel>('malware_reports');
    final unsyncedReports = box.values
        .where((r) => r.isSynced != true)
        .toList();
    print('üìä Unsynced reports: ${unsyncedReports.length}');

    // Try to sync
    if (connectivity != ConnectivityResult.none) {
      await syncReports();
    } else {
      print('‚ùå No internet connection for testing');
    }
  }

  static Future<List<Map<String, dynamic>>> fetchReportTypes() async {
    return await _apiService.fetchReportTypes();
  }

  static Future<List<Map<String, dynamic>>> fetchReportTypesByCategory(
    String categoryId,
  ) async {
    return await _apiService.fetchReportTypesByCategory(categoryId);
  }

  static Future<List<Map<String, dynamic>>> fetchReportCategories() async {
    final categories = await _apiService.fetchReportCategories();
    print('API returned: $categories'); // Debug print
    return categories;
  }

  // Test duplicate detection
  static Future<void> testDuplicateDetection() async {
    print('üß™ TESTING DUPLICATE DETECTION...');

    final box = Hive.box<MalwareReportModel>('malware_reports');
    final reports = box.values.toList();

    print('üìä Total reports: ${reports.length}');

    final seenKeys = <String>{};
    final duplicates = <String>[];

    for (final report in reports) {
      final key =
          '${report.name}_${report.malwareType}_${report.infectedDeviceType}_${report.location}';
      if (seenKeys.contains(key)) {
        duplicates.add('${report.name} (${report.malwareType})');
        print('‚ùå DUPLICATE: ${report.name} (${report.malwareType})');
      } else {
        seenKeys.add(key);
        print('‚úÖ UNIQUE: ${report.name} (${report.malwareType})');
      }
    }

    print('üìä Found ${duplicates.length} duplicates');
    if (duplicates.isNotEmpty) {
      print('‚ùå Duplicates found: ${duplicates.join(', ')}');
    } else {
      print('‚úÖ No duplicates found!');
    }
  }

  // NUCLEAR OPTION - Clear everything and start fresh
  static Future<void> nuclearCleanup() async {
    print('‚ò¢Ô∏è NUCLEAR CLEANUP - CLEARING ALL MALWARE DATA...');
    final box = Hive.box<MalwareReportModel>('malware_reports');
    await box.clear();
    print('‚úÖ ALL MALWARE DATA CLEARED - FRESH START');
  }

  // Debug method to test all endpoints and identify the issue
  static Future<void> debugMalwareBackendIssue() async {
    print('üîç DEBUGGING MALWARE BACKEND ISSUE...');
    print('=' * 50);

    // Test 1: Check if malware endpoint exists
    print('üß™ Test 1: Checking malware endpoint...');
    await testMalwareEndpoint();

    print('=' * 50);

    // Test 2: Check if general endpoint works
    print('üß™ Test 2: Checking general endpoint...');
    await testAlternativeMalwareEndpoint();

    print('=' * 50);

    // Test 3: Test payload structure
    print('üß™ Test 3: Testing payload structure...');
    await testMalwarePayloadStructure();

    print('=' * 50);
    print('üîç DEBUG COMPLETE - Check console logs above for issues');
  }
}
