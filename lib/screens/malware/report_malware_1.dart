import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:hive/hive.dart';
import 'package:path_provider/path_provider.dart';
import 'package:security_alert/custom/CustomDropdown.dart';
import 'package:security_alert/custom/customButton.dart';
import 'package:security_alert/custom/customTextfield.dart';
import '../../utils/responsive_helper.dart';
import '../../widgets/responsive_widget.dart';

import '../../models/malware_report_model.dart';
import 'report_malware_2.dart';
import 'view_pending_reports.dart';
import 'malware_report_service.dart';
import 'dart:convert';
import 'package:http/http.dart' as http;
import '../../services/api_service.dart';
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';
import '../../custom/location_picker_screen.dart';

// Operating system input formatter
class OperatingSystemInputFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
    TextEditingValue oldValue,
    TextEditingValue newValue,
  ) {
    // Allow letters, numbers, spaces, and common OS characters
    final validOSRegex = RegExp(r'^[a-zA-Z0-9\s\-\.]+$');
    if (!validOSRegex.hasMatch(newValue.text)) {
      return oldValue;
    }
    return newValue;
  }
}

// Location input formatter
class LocationInputFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
    TextEditingValue oldValue,
    TextEditingValue newValue,
  ) {
    // Allow letters, numbers, spaces, and common location characters
    final validLocationRegex = RegExp(r'^[a-zA-Z0-9\s\-\.\,]+$');
    if (!validLocationRegex.hasMatch(newValue.text)) {
      return oldValue;
    }
    return newValue;
  }
}

// Validation functions
String? validateLocation(String? value) {
  if (value == null || value.trim().isEmpty) {
    return 'Location is required';
  }

  if (value.trim().length < 2) {
    return 'Location should be at least 2 characters';
  }

  return null;
}

// Get current location with real address
Future<Map<String, dynamic>> _getCurrentLocation() async {
  try {
    print('üìç Getting current location for malware report...');

    // Check if location services are enabled
    bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      print('‚ùå Location services are disabled');
      return {
        'type': 'Point',
        'coordinates': [0.0, 0.0], // Fallback coordinates
        'address': 'Location services disabled',
      };
    }

    // Check location permission
    LocationPermission permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        print('‚ùå Location permission denied');
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
          'address': 'Location permission denied',
        };
      }
    }

    if (permission == LocationPermission.deniedForever) {
      print('‚ùå Location permission denied forever');
      return {
        'type': 'Point',
        'coordinates': [0.0, 0.0], // Fallback coordinates
        'address': 'Location permission denied',
      };
    }

    // Get current position
    Position position = await Geolocator.getCurrentPosition(
      desiredAccuracy: LocationAccuracy.high,
      timeLimit: const Duration(seconds: 10),
    );

    print(
      '‚úÖ Location obtained for malware report: ${position.latitude}, ${position.longitude}',
    );

    // Get real address using geocoding
    String address = '${position.latitude}, ${position.longitude}';

    try {
      List<Placemark> placemarks = await placemarkFromCoordinates(
        position.latitude,
        position.longitude,
      );

      if (placemarks.isNotEmpty) {
        Placemark placemark = placemarks[0];
        address = [
          placemark.street,
          placemark.subLocality,
          placemark.locality,
          placemark.administrativeArea,
          placemark.country,
        ].where((e) => e != null && e.isNotEmpty).join(', ');
      }
    } catch (e) {
      print('‚ùå Error getting address from coordinates: $e');
      // Keep the coordinates as fallback
    }

    return {
      'type': 'Point',
      'coordinates': [
        position.longitude,
        position.latitude,
      ], // [lng, lat] format
      'address': address,
    };
  } catch (e) {
    print('‚ùå Error getting location for malware report: $e');
    return {
      'type': 'Point',
      'coordinates': [0.0, 0.0], // Fallback coordinates
      'address': 'Location services disabled',
    };
  }
}

class ReportMalware1 extends StatefulWidget {
  final String categoryId;
  const ReportMalware1({required this.categoryId});

  @override
  State<ReportMalware1> createState() => _ReportMalware1State();
}

class _ReportMalware1State extends State<ReportMalware1> {
  final _formKey = GlobalKey<FormState>();
  String? _Malwaretype, _infectedSystem, _DetectedSeverity;
  String? malwareTypeId;
  String? operatingSystemId;
  String? selectedLocation;
  String? selectedAddress;
  List<Map<String, dynamic>> malwareTypes = [];
  List<Map<String, dynamic>> deviceTypes = [];
  List<Map<String, dynamic>> operatingSystems = [];
  List<Map<String, dynamic>> detectionMethods = [];
  bool isOnline = true;
  bool isLoadingMalwareTypes = false;
  bool isLoadingDeviceTypes = false;
  bool isLoadingOperatingSystems = false;
  bool isLoadingDetectionMethods = false;
  String? malwareTypesError;
  String? deviceTypesError;
  String? operatingSystemsError;
  String? detectionMethodsError;
  bool isFormValid = false;

  // Controllers for real-time validation
  final TextEditingController _operatingSystemController =
      TextEditingController();

  @override
  void initState() {
    super.initState();
    _loadMalwareTypes();
    _loadDeviceTypes();
    _loadOperatingSystems();
    _loadDetectionMethods();
    _setupNetworkListener();
    _setupValidationListeners();
  }

  void _setupValidationListeners() {
    // Location validation handled by location picker
  }

  @override
  void dispose() {
    _operatingSystemController.dispose();
    super.dispose();
  }

  bool _isFormValid() {
    return selectedLocation != null &&
        _Malwaretype != null &&
        _infectedSystem != null &&
        _DetectedSeverity != null &&
        operatingSystemId != null;
    // Alert level validation moved to Step 2
  }

  void _setupNetworkListener() {
    Connectivity().onConnectivityChanged.listen((result) {
      setState(() => isOnline = result != ConnectivityResult.none);
      if (isOnline) MalwareReportService.syncReports();
    });
  }

  Future<void> _loadMalwareTypes() async {
    setState(() {
      isLoadingMalwareTypes = true;
    });

    try {
      final apiService = ApiService();
      // Use the malware category ID for malware types
      final malwareTypesData = await apiService.fetchReportTypesByCategory(
        widget.categoryId,
      );

      if (malwareTypesData.isNotEmpty) {
        setState(() {
          malwareTypes = malwareTypesData;
          isLoadingMalwareTypes = false;
        });
        print(
          '‚úÖ Loaded ${malwareTypesData.length} malware types from backend for category: ${widget.categoryId}',
        );
      } else {
        setState(() {
          isLoadingMalwareTypes = false;
        });
        print(
          '‚ùå No malware types available from backend for category: ${widget.categoryId}',
        );
      }
    } catch (e) {
      print('Failed to fetch malware types: $e');
      setState(() {
        isLoadingMalwareTypes = false;
      });
    }
  }

  Future<void> _loadDeviceTypes() async {
    setState(() {
      isLoadingDeviceTypes = true;
      deviceTypesError = null;
    });

    try {
      final apiService = ApiService();
      // Use the malware category ID for device types
      final deviceTypesData = await apiService.fetchDropdownByType(
        'device',
        widget.categoryId,
      );

      if (deviceTypesData.isNotEmpty) {
        // Capitalize the first letter of each option name
        final capitalizedOptions = deviceTypesData.map((option) {
          final name = option['name'] as String? ?? '';
          if (name.isNotEmpty) {
            return {
              ...option,
              'name': name[0].toUpperCase() + name.substring(1).toLowerCase(),
            };
          }
          return option;
        }).toList();

        setState(() {
          deviceTypes = capitalizedOptions;
          isLoadingDeviceTypes = false;
        });
        print(
          '‚úÖ Loaded ${deviceTypesData.length} device types from backend for category: ${widget.categoryId}',
        );
      } else {
        setState(() {
          isLoadingDeviceTypes = false;
          deviceTypesError = 'No device types available from backend';
        });
        print(
          '‚ùå No device types available from backend for category: ${widget.categoryId}',
        );
      }
    } catch (e) {
      print('Failed to fetch device types: $e');
      setState(() {
        isLoadingDeviceTypes = false;
        deviceTypesError = 'Failed to load device types: ${e.toString()}';
      });
    }
  }

  Future<void> _loadOperatingSystems() async {
    setState(() {
      isLoadingOperatingSystems = true;
      operatingSystemsError = null;
    });

    try {
      final apiService = ApiService();
      // Use the malware category ID for operating systems
      final operatingSystemsData = await apiService.fetchDropdownByType(
        'operating System',
        widget.categoryId,
      );

      if (operatingSystemsData.isNotEmpty) {
        // Capitalize the first letter of each option name
        final capitalizedOptions = operatingSystemsData.map((option) {
          final name = option['name'] as String? ?? '';
          if (name.isNotEmpty) {
            return {
              ...option,
              'name': name[0].toUpperCase() + name.substring(1).toLowerCase(),
            };
          }
          return option;
        }).toList();

        setState(() {
          operatingSystems = capitalizedOptions;
          isLoadingOperatingSystems = false;
        });
        print(
          '‚úÖ Loaded ${operatingSystemsData.length} operating systems from backend for category: ${widget.categoryId}',
        );
      } else {
        setState(() {
          isLoadingOperatingSystems = false;
          operatingSystemsError = 'No operating systems available from backend';
        });
        print(
          '‚ùå No operating systems available from backend for category: ${widget.categoryId}',
        );
      }
    } catch (e) {
      print('Failed to fetch operating systems: $e');
      setState(() {
        isLoadingOperatingSystems = false;
        operatingSystemsError =
            'Failed to load operating systems: ${e.toString()}';
      });
    }
  }

  Future<void> _loadDetectionMethods() async {
    setState(() {
      isLoadingDetectionMethods = true;
      detectionMethodsError = null;
    });

    try {
      final apiService = ApiService();
      // Use the malware category ID for detection methods
      final detectionMethodsData = await apiService.fetchDropdownByType(
        'detect',
        widget.categoryId,
      );

      if (detectionMethodsData.isNotEmpty) {
        // Capitalize the first letter of each option name
        final capitalizedOptions = detectionMethodsData.map((option) {
          final name = option['name'] as String? ?? '';
          if (name.isNotEmpty) {
            return {
              ...option,
              'name': name[0].toUpperCase() + name.substring(1).toLowerCase(),
            };
          }
          return option;
        }).toList();

        setState(() {
          detectionMethods = capitalizedOptions;
          isLoadingDetectionMethods = false;
        });
        print(
          '‚úÖ Loaded ${detectionMethodsData.length} detection methods from backend for category: ${widget.categoryId}',
        );
      } else {
        setState(() {
          isLoadingDetectionMethods = false;
          detectionMethodsError = 'No detection methods available from backend';
        });
        print(
          '‚ùå No detection methods available from backend for category: ${widget.categoryId}',
        );
      }
    } catch (e) {
      print('Failed to fetch detection methods: $e');
      setState(() {
        isLoadingDetectionMethods = false;
        detectionMethodsError =
            'Failed to load detection methods: ${e.toString()}';
      });
    }
  }

  // Add method to get current location dynamically
  Future<Map<String, dynamic>> _getCurrentLocation() async {
    try {
      print('üìç Getting current location...');

      // Check if location services are enabled
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        print('‚ùå Location services are disabled');
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
        };
      }

      // Check location permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          print('‚ùå Location permission denied');
          return {
            'type': 'Point',
            'coordinates': [0.0, 0.0], // Fallback coordinates
          };
        }
      }

      if (permission == LocationPermission.deniedForever) {
        print('‚ùå Location permission denied forever');
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
        };
      }

      // Get current position
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10),
      );

      print('‚úÖ Location obtained: ${position.latitude}, ${position.longitude}');

      return {
        'type': 'Point',
        'coordinates': [
          position.longitude,
          position.latitude,
        ], // [lng, lat] format
      };
    } catch (e) {
      print('‚ùå Error getting location: $e');
      return {
        'type': 'Point',
        'coordinates': [0.0, 0.0], // Fallback coordinates
      };
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: const Color(0xFF064FAD),
        foregroundColor: Colors.white,
        title: const Text(
          'Report Malware',
          style: TextStyle(
            fontFamily: 'Poppins',
            fontWeight: FontWeight.w600,
            color: Colors.white,
          ),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh, color: Colors.white),
            onPressed: () {
              _loadMalwareTypes();
              _loadDeviceTypes();
              _loadOperatingSystems();
              _loadDetectionMethods();
            },
          ),
        ],
      ),
      body: Form(
        key: _formKey,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 8),
              CustomDropdown(
                hint: isLoadingMalwareTypes
                    ? "Loading malware types..."
                    : "Select a Malware Type",
                value: malwareTypes.isNotEmpty
                    ? malwareTypes.firstWhere(
                        (e) => e['_id'] == malwareTypeId,
                        orElse: () => {'name': null},
                      )['name']
                    : _Malwaretype,
                items: malwareTypes.isNotEmpty
                    ? malwareTypes.map((e) => e['name'] as String).toList()
                    : const [],
                onChanged: (val) {
                  setState(() {
                    _Malwaretype = val;
                    if (malwareTypes.isNotEmpty && val != null) {
                      try {
                        final selectedType = malwareTypes.firstWhere(
                          (e) => e['name'] == val,
                          orElse: () => {'_id': null, 'name': val},
                        );
                        malwareTypeId = selectedType['_id'];
                        print(
                          'Selected malware type: $val with ID: $malwareTypeId',
                        );
                      } catch (e) {
                        print('Error setting malware type ID: $e');
                        malwareTypeId = null;
                      }
                    } else {
                      malwareTypeId = null;
                    }
                  });
                },
                label: "Malware Type*",
              ),
              if (malwareTypes.isEmpty && !isLoadingMalwareTypes)
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Text(
                    'No malware types available from backend',
                    style: TextStyle(color: Colors.red, fontSize: 12),
                  ),
                ),
              const SizedBox(height: 8),
              CustomDropdown(
                hint: isLoadingDeviceTypes
                    ? "Loading device types..."
                    : deviceTypesError != null
                    ? "Error loading device types"
                    : "Select a Device Type",
                value: deviceTypes.isNotEmpty
                    ? deviceTypes.firstWhere(
                        (e) => e['name'] == _infectedSystem,
                        orElse: () => {'name': null},
                      )['name']
                    : _infectedSystem,
                items: deviceTypes.isNotEmpty
                    ? deviceTypes.map((e) => e['name'] as String).toList()
                    : const [],
                onChanged: isLoadingDeviceTypes
                    ? (val) {}
                    : (val) {
                        setState(() {
                          _infectedSystem = val;
                          if (deviceTypes.isNotEmpty && val != null) {
                            try {
                              final selectedType = deviceTypes.firstWhere(
                                (e) => e['name'] == val,
                                orElse: () => {'_id': null, 'name': val},
                              );
                              print(
                                'Selected device type: $val with ID: ${selectedType['_id']}',
                              );
                            } catch (e) {
                              print('Error setting device type ID: $e');
                            }
                          }
                        });
                      },
                label: 'Infected Device Type*',
              ),
              if (deviceTypesError != null)
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Text(
                    deviceTypesError!,
                    style: TextStyle(color: Colors.red, fontSize: 12),
                  ),
                ),
              const SizedBox(height: 23),

              CustomDropdown(
                hint: isLoadingOperatingSystems
                    ? "Loading operating systems..."
                    : operatingSystemsError != null
                    ? "Error loading operating systems"
                    : "Select Operating System",
                value: operatingSystems.isNotEmpty
                    ? operatingSystems.firstWhere(
                        (e) => e['name'] == _operatingSystemController.text,
                        orElse: () => {'name': null},
                      )['name']
                    : _operatingSystemController.text,
                items: operatingSystems.isNotEmpty
                    ? operatingSystems.map((e) => e['name'] as String).toList()
                    : const [],
                onChanged: isLoadingOperatingSystems
                    ? (val) {}
                    : (val) {
                        setState(() {
                          _operatingSystemController.text = val!;
                          if (operatingSystems.isNotEmpty && val != null) {
                            try {
                              final selectedType = operatingSystems.firstWhere(
                                (e) => e['name'] == val,
                                orElse: () => {'_id': null, 'name': val},
                              );
                              operatingSystemId = selectedType['_id'];
                              print(
                                'Selected operating system: $val with ID: $operatingSystemId',
                              );
                            } catch (e) {
                              print('Error setting operating system ID: $e');
                              operatingSystemId = null;
                            }
                          } else {
                            operatingSystemId = null;
                          }
                        });
                      },
                label: 'Operating System*',
              ),
              if (operatingSystemsError != null)
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Text(
                    operatingSystemsError!,
                    style: TextStyle(color: Colors.red, fontSize: 12),
                  ),
                ),
              const SizedBox(height: 23),
              CustomDropdown(
                hint: isLoadingDetectionMethods
                    ? "Loading detection methods..."
                    : detectionMethodsError != null
                    ? "Error loading detection methods"
                    : "Select Detection Method",
                value: detectionMethods.isNotEmpty
                    ? detectionMethods.firstWhere(
                        (e) => e['name'] == _DetectedSeverity,
                        orElse: () => {'name': null},
                      )['name']
                    : _DetectedSeverity,
                items: detectionMethods.isNotEmpty
                    ? detectionMethods.map((e) => e['name'] as String).toList()
                    : const [],
                onChanged: isLoadingDetectionMethods
                    ? (val) {}
                    : (val) {
                        setState(() {
                          _DetectedSeverity = val;
                          if (detectionMethods.isNotEmpty && val != null) {
                            try {
                              final selectedType = detectionMethods.firstWhere(
                                (e) => e['name'] == val,
                                orElse: () => {'_id': null, 'name': val},
                              );
                              print(
                                'Selected detection method: $val with ID: ${selectedType['_id']}',
                              );
                            } catch (e) {
                              print('Error setting detection method ID: $e');
                            }
                          }
                        });
                      },
                label: 'How was it Detected',
              ),
              const SizedBox(height: 23),

              // Location
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  // color: Colors.white,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.black),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        // Icon(Icons.location_on, color: Colors.grey[600]),
                        // const SizedBox(width: 8),
                        Text(
                          'Location*',
                          style: TextStyle(
                            fontWeight: FontWeight.w600,
                            color: Colors.black,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    InkWell(
                      onTap: () {
                        LocationPickerBottomSheet.show(
                          context,
                          onLocationSelected: (location, address) {
                            setState(() {
                              selectedLocation = location;
                              selectedAddress = address;
                            });
                          },
                        );
                      },
                      child: Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          // color: Colors.white,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.black),
                        ),
                        child: Row(
                          children: [
                            Icon(Icons.search, color: Colors.black, size: 20),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                selectedLocation != null
                                    ? selectedLocation!
                                    : 'Select location',
                                style: TextStyle(
                                  color: selectedLocation != null
                                      ? Colors.grey[600]
                                      : Colors.black,
                                  fontSize: 16,
                                ),
                              ),
                            ),
                            Icon(
                              Icons.arrow_forward_ios,
                              color: Colors.black,
                              size: 16,
                            ),
                          ],
                        ),
                      ),
                    ),
                    if (selectedAddress != null) ...[
                      const SizedBox(height: 8),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.blue[50],
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.blue[200]!),
                        ),
                        child: Row(
                          children: [
                            Icon(
                              Icons.location_on,
                              color: Colors.blue[600],
                              size: 16,
                            ),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Text(
                                selectedAddress!,
                                style: TextStyle(
                                  color: Colors.blue[700],
                                  fontSize: 14,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              if (detectionMethodsError != null)
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Text(
                    detectionMethodsError!,
                    style: TextStyle(color: Colors.red, fontSize: 12),
                  ),
                ),
              const SizedBox(height: 23),

              // Alert Level field moved to Step 2 (report_malware_2.dart)
              // This will be handled dynamically in the next step
              const SizedBox(height: 20),

              // ElevatedButton(
              //   onPressed: () => Navigator.push(
              //         context,
              //         MaterialPageRoute(builder: (_) => const MalwareReportPage2()),
              //       ),
              //
              //   style: ElevatedButton.styleFrom(
              //         shape: RoundedRectangleBorder(
              //           borderRadius: BorderRadius.circular(6),
              //         ),
              //         backgroundColor: const Color(0xFF064FAD),
              //         minimumSize: const Size(double.infinity, 48),
              //       ),
              //   child: const Text("Next", style: TextStyle(color: Colors.white)),
              // ),
              CustomButton(
                text: 'Next',
                onPressed: () async {
                  // Trigger validation manually to show errors
                  if (_formKey.currentState!.validate()) {
                    // Validate required fields (alert level validation moved to Step 2)
                    if (_Malwaretype == null ||
                        _infectedSystem == null ||
                        operatingSystemId == null ||
                        _DetectedSeverity == null ||
                        selectedLocation == null) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Please fill all required fields'),
                        ),
                      );
                      return;
                    }

                    // Get current location with real address
                    final locationData = await _getCurrentLocation();

                    // Create malware report model
                    final malwareReport = MalwareReportModel(
                      id: DateTime.now().millisecondsSinceEpoch.toString(),
                      malwareType: _Malwaretype!,
                      infectedDeviceType: _infectedSystem!,
                      operatingSystem: _operatingSystemController.text,
                      detectionMethod: _DetectedSeverity!,
                      location:
                          selectedLocation ?? locationData['address'] ?? '',
                      fileName: _Malwaretype ?? 'Unknown File',
                      name: _Malwaretype ?? 'Unknown Attack',
                      systemAffected: _infectedSystem ?? 'Unknown System',
                      alertSeverityLevel: 'Medium',
                      alertLevels: 'Medium', // Set default alert level
                      date: DateTime.now(),
                      reportTypeId:
                          malwareTypeId, // Set the selected malware type ID
                      reportCategoryId:
                          widget.categoryId, // Add report category ID
                      deviceTypeId: _infectedSystem, // Add device type ID
                      detectTypeId: _DetectedSeverity, // Add detection type ID
                      operatingSystemName:
                          _operatingSystemController.text, // Add OS name
                      attackName: _Malwaretype, // Add attack name
                      attackSystem: _infectedSystem, // Add attack system
                      createdBy: null, // Will be set by service
                      isActive: true,
                      createdAt: DateTime.now(),
                      updatedAt: DateTime.now(),
                      description:
                          'Malware detected on ${_infectedSystem}', // Set initial description
                      incidentDate: DateTime.now(),
                      reportOutcome: false,
                      locationCoordinates:
                          locationData, // Use real location data
                      screenshotUrls: [],
                      voiceMessageUrls: [],
                      documentUrls: [],
                      screenshots: [],
                      voiceMessages: [],
                      documents: [],
                    );

                    print('Debug - Malware Report Data:');
                    print('Malware Type: ${_Malwaretype}');
                    print('Infected Device Type: ${_infectedSystem}');
                    print(
                      'Operating System: ${_operatingSystemController.text}',
                    );
                    print('Detection Method: ${_DetectedSeverity}');
                    print('Location: $selectedLocation');

                    // Don't save here - save only in Step 2 with complete data
                    print('üìù Malware report data prepared for Step 2');

                    try {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) =>
                              MalwareReportPage2(report: malwareReport),
                        ),
                      ).then((_) {
                        // Refresh the thread database list when returning
                        setState(() {});
                      });
                    } catch (e) {
                      print('Error navigating to MalwareReportPage2: $e');
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text('Error navigating to next page: $e'),
                          backgroundColor: Colors.red,
                        ),
                      );
                    }
                  } else {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text(
                          'Please fill all required fields correctly',
                        ),
                        backgroundColor: Colors.red,
                      ),
                    );
                  }
                },
                fontSize: 20,
                borderCircular: 6,
                fontWeight: FontWeight.bold,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
