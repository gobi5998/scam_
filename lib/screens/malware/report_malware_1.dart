import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:hive/hive.dart';
import 'package:path_provider/path_provider.dart';
import 'package:security_alert/custom/CustomDropdown.dart';
import 'package:security_alert/custom/customButton.dart';
import 'package:security_alert/custom/customTextfield.dart';
import '../../utils/responsive_helper.dart';
import '../../widgets/responsive_widget.dart';

import '../../models/malware_report_model.dart';
import 'report_malware_2.dart';
import 'view_pending_reports.dart';
import 'malware_report_service.dart';
import 'dart:convert';
import 'package:http/http.dart' as http;
import '../../services/api_service.dart';
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';
import '../../custom/location_picker_screen.dart';
import '../../services/location_storage_service.dart';

// Operating system input formatter
class OperatingSystemInputFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
    TextEditingValue oldValue,
    TextEditingValue newValue,
  ) {
    // Allow letters, numbers, spaces, and common OS characters
    final validOSRegex = RegExp(r'^[a-zA-Z0-9\s\-\.]+$');
    if (!validOSRegex.hasMatch(newValue.text)) {
      return oldValue;
    }
    return newValue;
  }
}

// Location input formatter
class LocationInputFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
    TextEditingValue oldValue,
    TextEditingValue newValue,
  ) {
    // Allow letters, numbers, spaces, and common location characters
    final validLocationRegex = RegExp(r'^[a-zA-Z0-9\s\-\.\,]+$');
    if (!validLocationRegex.hasMatch(newValue.text)) {
      return oldValue;
    }
    return newValue;
  }
}

// Validation functions
String? validateLocation(String? value) {
  if (value == null || value.trim().isEmpty) {
    return 'Location is required';
  }

  if (value.trim().length < 2) {
    return 'Location should be at least 2 characters';
  }

  return null;
}

// Get current location with real address
Future<Map<String, dynamic>> _getCurrentLocation() async {
  try {
    // Check if location services are enabled
    bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      return {
        'type': 'Point',
        'coordinates': [0.0, 0.0], // Fallback coordinates
        'address': 'Location services disabled',
      };
    }

    // Check location permission
    LocationPermission permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
          'address': 'Location permission denied',
        };
      }
    }

    if (permission == LocationPermission.deniedForever) {
      return {
        'type': 'Point',
        'coordinates': [0.0, 0.0], // Fallback coordinates
        'address': 'Location permission denied',
      };
    }

    // Get current position
    Position position = await Geolocator.getCurrentPosition(
      desiredAccuracy: LocationAccuracy.high,
      timeLimit: const Duration(seconds: 10),
    );

    print(
      '‚úÖ Location obtained for malware report: ${position.latitude}, ${position.longitude}',
    );

    // Get real address using geocoding
    String address = '${position.latitude}, ${position.longitude}';

    try {
      List<Placemark> placemarks = await placemarkFromCoordinates(
        position.latitude,
        position.longitude,
      );

      if (placemarks.isNotEmpty) {
        Placemark placemark = placemarks[0];
        address = [
          placemark.street,
          placemark.subLocality,
          placemark.locality,
          placemark.administrativeArea,
          placemark.country,
        ].where((e) => e != null && e.isNotEmpty).join(', ');
      }
    } catch (e) {
      // Keep the coordinates as fallback
    }

    return {
      'type': 'Point',
      'coordinates': [
        position.longitude,
        position.latitude,
      ], // [lng, lat] format
      'address': address,
    };
  } catch (e) {
    return {
      'type': 'Point',
      'coordinates': [0.0, 0.0], // Fallback coordinates
      'address': 'Location services disabled',
    };
  }
}

class ReportMalware1 extends StatefulWidget {
  final String categoryId;
  const ReportMalware1({required this.categoryId});

  @override
  State<ReportMalware1> createState() => _ReportMalware1State();
}

class _ReportMalware1State extends State<ReportMalware1> {
  final _formKey = GlobalKey<FormState>();
  String? _Malwaretype, _infectedSystem, _DetectedSeverity;
  String? malwareTypeId;
  String? operatingSystemId;
  String? selectedLocation;
  String? selectedAddress;
  List<Map<String, dynamic>> malwareTypes = [];
  List<Map<String, dynamic>> deviceTypes = [];
  List<Map<String, dynamic>> operatingSystems = [];
  List<Map<String, dynamic>> detectionMethods = [];
  bool isOnline = true;
  bool isLoadingMalwareTypes = false;
  bool isLoadingDeviceTypes = false;
  bool isLoadingOperatingSystems = false;
  bool isLoadingDetectionMethods = false;
  String? malwareTypesError;
  String? deviceTypesError;
  String? operatingSystemsError;
  String? detectionMethodsError;
  bool isFormValid = false;

  // Age range variables
  RangeValues _ageRange = const RangeValues(10, 100);
  int? minAge;
  int? maxAge;

  // Controllers for real-time validation
  final TextEditingController _operatingSystemController =
      TextEditingController();

  @override
  void initState() {
    super.initState();
    _loadMalwareTypes();
    _loadDeviceTypes();
    _loadOperatingSystems();
    _loadDetectionMethods();
    _setupNetworkListener();
    _setupValidationListeners();

    // Initialize age range with dynamic values
    minAge = _ageRange.start.round();
    maxAge = _ageRange.end.round();
  }

  void _setupValidationListeners() {
    // Location validation handled by location picker
  }

  @override
  void dispose() {
    _operatingSystemController.dispose();
    super.dispose();
  }

  bool _isFormValid() {
    return selectedLocation != null &&
        _Malwaretype != null &&
        _infectedSystem != null &&
        _DetectedSeverity != null &&
        operatingSystemId != null;
    // Alert level validation moved to Step 2
  }

  void _setupNetworkListener() {
    Connectivity().onConnectivityChanged.listen((result) {
      setState(() => isOnline = result != ConnectivityResult.none);
      if (isOnline) {
        print(
          'üåê Network connection restored - triggering comprehensive sync...',
        );
        // Use the new comprehensive sync method
        MalwareReportService.syncOfflineReports().catchError((error) {});
      }
    });
  }

  Future<void> _loadMalwareTypes() async {
    setState(() {
      isLoadingMalwareTypes = true;
    });

    try {
      final apiService = ApiService();
      // Use the malware category ID for malware types
      final malwareTypesData = await apiService.fetchReportTypesByCategory(
        widget.categoryId,
      );

      if (malwareTypesData.isNotEmpty) {
        setState(() {
          malwareTypes = malwareTypesData;
          isLoadingMalwareTypes = false;
        });
        print(
          '‚úÖ Loaded ${malwareTypesData.length} malware types from backend for category: ${widget.categoryId}',
        );
      } else {
        setState(() {
          isLoadingMalwareTypes = false;
        });
        print(
          '‚ùå No malware types available from backend for category: ${widget.categoryId}',
        );
      }
    } catch (e) {
      setState(() {
        isLoadingMalwareTypes = false;
      });
    }
  }

  Future<void> _loadDeviceTypes() async {
    setState(() {
      isLoadingDeviceTypes = true;
      deviceTypesError = null;
    });

    try {
      final apiService = ApiService();
      // Use the malware category ID for device types
      final deviceTypesData = await apiService.fetchDropdownByType(
        'device',
        widget.categoryId,
      );

      if (deviceTypesData.isNotEmpty) {
        // Capitalize the first letter of each option name
        final capitalizedOptions = deviceTypesData.map((option) {
          final name = option['name'] as String? ?? '';
          if (name.isNotEmpty) {
            return {
              ...option,
              'name': name[0].toUpperCase() + name.substring(1).toLowerCase(),
            };
          }
          return option;
        }).toList();

        setState(() {
          deviceTypes = capitalizedOptions;
          isLoadingDeviceTypes = false;
        });
        print(
          '‚úÖ Loaded ${deviceTypesData.length} device types from backend for category: ${widget.categoryId}',
        );
      } else {
        setState(() {
          isLoadingDeviceTypes = false;
          deviceTypesError = 'No device types available from backend';
        });
        print(
          '‚ùå No device types available from backend for category: ${widget.categoryId}',
        );
      }
    } catch (e) {
      setState(() {
        isLoadingDeviceTypes = false;
        deviceTypesError = 'Failed to load device types: ${e.toString()}';
      });
    }
  }

  Future<void> _loadOperatingSystems() async {
    setState(() {
      isLoadingOperatingSystems = true;
      operatingSystemsError = null;
    });

    try {
      final apiService = ApiService();
      // Use the malware category ID for operating systems
      final operatingSystemsData = await apiService.fetchDropdownByType(
        'operating System',
        widget.categoryId,
      );

      if (operatingSystemsData.isNotEmpty) {
        // Capitalize the first letter of each option name
        final capitalizedOptions = operatingSystemsData.map((option) {
          final name = option['name'] as String? ?? '';
          if (name.isNotEmpty) {
            return {
              ...option,
              'name': name[0].toUpperCase() + name.substring(1).toLowerCase(),
            };
          }
          return option;
        }).toList();

        setState(() {
          operatingSystems = capitalizedOptions;
          isLoadingOperatingSystems = false;
        });
        print(
          '‚úÖ Loaded ${operatingSystemsData.length} operating systems from backend for category: ${widget.categoryId}',
        );
      } else {
        setState(() {
          isLoadingOperatingSystems = false;
          operatingSystemsError = 'No operating systems available from backend';
        });
        print(
          '‚ùå No operating systems available from backend for category: ${widget.categoryId}',
        );
      }
    } catch (e) {
      setState(() {
        isLoadingOperatingSystems = false;
        operatingSystemsError =
            'Failed to load operating systems: ${e.toString()}';
      });
    }
  }

  Future<void> _loadDetectionMethods() async {
    setState(() {
      isLoadingDetectionMethods = true;
      detectionMethodsError = null;
    });

    try {
      final apiService = ApiService();
      // Use the malware category ID for detection methods
      final detectionMethodsData = await apiService.fetchDropdownByType(
        'detect',
        widget.categoryId,
      );

      if (detectionMethodsData.isNotEmpty) {
        // Capitalize the first letter of each option name
        final capitalizedOptions = detectionMethodsData.map((option) {
          final name = option['name'] as String? ?? '';
          if (name.isNotEmpty) {
            return {
              ...option,
              'name': name[0].toUpperCase() + name.substring(1).toLowerCase(),
            };
          }
          return option;
        }).toList();

        setState(() {
          detectionMethods = capitalizedOptions;
          isLoadingDetectionMethods = false;
        });
        print(
          '‚úÖ Loaded ${detectionMethodsData.length} detection methods from backend for category: ${widget.categoryId}',
        );
      } else {
        setState(() {
          isLoadingDetectionMethods = false;
          detectionMethodsError = 'No detection methods available from backend';
        });
        print(
          '‚ùå No detection methods available from backend for category: ${widget.categoryId}',
        );
      }
    } catch (e) {
      setState(() {
        isLoadingDetectionMethods = false;
        detectionMethodsError =
            'Failed to load detection methods: ${e.toString()}';
      });
    }
  }

  // Add method to get current location dynamically
  Future<Map<String, dynamic>> _getCurrentLocation() async {
    try {
      // Check if location services are enabled
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
        };
      }

      // Check location permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          return {
            'type': 'Point',
            'coordinates': [0.0, 0.0], // Fallback coordinates
          };
        }
      }

      if (permission == LocationPermission.deniedForever) {
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
        };
      }

      // Get current position
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10),
      );

      return {
        'type': 'Point',
        'coordinates': [
          position.longitude,
          position.latitude,
        ], // [lng, lat] format
      };
    } catch (e) {
      return {
        'type': 'Point',
        'coordinates': [0.0, 0.0], // Fallback coordinates
      };
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: const Color(0xFF064FAD),
        foregroundColor: Colors.white,
        title: const Text(
          'Report Malware',
          style: TextStyle(
            fontFamily: 'Poppins',
            fontWeight: FontWeight.w600,
            color: Colors.white,
          ),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh, color: Colors.white),
            onPressed: () {
              _loadMalwareTypes();
              _loadDeviceTypes();
              _loadOperatingSystems();
              _loadDetectionMethods();
            },
          ),
        ],
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Form(
            key: _formKey,
            child: Column(
              children: [
                // Scrollable content area
                Expanded(
                  child: SingleChildScrollView(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const SizedBox(height: 8),
                        CustomDropdown(
                          hint: isLoadingMalwareTypes
                              ? "Loading malware types..."
                              : "Select a Malware Type",
                          value: malwareTypes.isNotEmpty
                              ? malwareTypes.firstWhere(
                                  (e) => e['_id'] == malwareTypeId,
                                  orElse: () => {'name': null},
                                )['name']
                              : _Malwaretype,
                          items: malwareTypes.isNotEmpty
                              ? malwareTypes
                                    .map((e) => e['name'] as String)
                                    .toList()
                              : const [],
                          onChanged: (val) {
                            setState(() {
                              _Malwaretype = val;
                              if (malwareTypes.isNotEmpty && val != null) {
                                try {
                                  final selectedType = malwareTypes.firstWhere(
                                    (e) => e['name'] == val,
                                    orElse: () => {'_id': null, 'name': val},
                                  );
                                  malwareTypeId = selectedType['_id'];
                                  print(
                                    'Selected malware type: $val with ID: $malwareTypeId',
                                  );
                                } catch (e) {
                                  malwareTypeId = null;
                                }
                              } else {
                                malwareTypeId = null;
                              }
                            });
                          },
                          label: "Malware Type*",
                        ),
                        if (malwareTypes.isEmpty && !isLoadingMalwareTypes)
                          Padding(
                            padding: const EdgeInsets.only(top: 8.0),
                            child: Text(
                              'No malware types available from backend',
                              style: TextStyle(color: Colors.red, fontSize: 12),
                            ),
                          ),
                        const SizedBox(height: 8),
                        CustomDropdown(
                          hint: isLoadingDeviceTypes
                              ? "Loading device types..."
                              : deviceTypesError != null
                              ? "Error loading device types"
                              : "Select a Device Type",
                          value: deviceTypes.isNotEmpty
                              ? deviceTypes.firstWhere(
                                  (e) => e['name'] == _infectedSystem,
                                  orElse: () => {'name': null},
                                )['name']
                              : _infectedSystem,
                          items: deviceTypes.isNotEmpty
                              ? deviceTypes
                                    .map((e) => e['name'] as String)
                                    .toList()
                              : const [],
                          onChanged: isLoadingDeviceTypes
                              ? (val) {}
                              : (val) {
                                  setState(() {
                                    _infectedSystem = val;
                                    if (deviceTypes.isNotEmpty && val != null) {
                                      try {
                                        final selectedType = deviceTypes
                                            .firstWhere(
                                              (e) => e['name'] == val,
                                              orElse: () => {
                                                '_id': null,
                                                'name': val,
                                              },
                                            );
                                        print(
                                          'Selected device type: $val with ID: ${selectedType['_id']}',
                                        );
                                      } catch (e) {}
                                    }
                                  });
                                },
                          label: 'Infected Device Type*',
                        ),
                        if (deviceTypesError != null)
                          Padding(
                            padding: const EdgeInsets.only(top: 8.0),
                            child: Text(
                              deviceTypesError!,
                              style: TextStyle(color: Colors.red, fontSize: 12),
                            ),
                          ),
                        const SizedBox(height: 8),
                        CustomDropdown(
                          hint: isLoadingOperatingSystems
                              ? "Loading operating systems..."
                              : operatingSystemsError != null
                              ? "Error loading operating systems"
                              : "Select an Operating System",
                          value: operatingSystems.isNotEmpty
                              ? operatingSystems.firstWhere(
                                  (e) => e['_id'] == operatingSystemId,
                                  orElse: () => {'name': null},
                                )['name']
                              : _operatingSystemController.text.isNotEmpty
                              ? _operatingSystemController.text
                              : null,
                          items: operatingSystems.isNotEmpty
                              ? operatingSystems
                                    .map((e) => e['name'] as String)
                                    .toList()
                              : const [],
                          onChanged: isLoadingOperatingSystems
                              ? (val) {}
                              : (val) {
                                  setState(() {
                                    _operatingSystemController.text = val ?? '';
                                    if (operatingSystems.isNotEmpty &&
                                        val != null) {
                                      try {
                                        final selectedOS = operatingSystems
                                            .firstWhere(
                                              (e) => e['name'] == val,
                                              orElse: () => {
                                                '_id': null,
                                                'name': val,
                                              },
                                            );
                                        operatingSystemId = selectedOS['_id'];
                                        print(
                                          'Selected operating system: $val with ID: $operatingSystemId',
                                        );
                                      } catch (e) {
                                        operatingSystemId = null;
                                      }
                                    } else {
                                      operatingSystemId = null;
                                    }
                                  });
                                },
                          label: 'Operating System*',
                        ),
                        if (operatingSystemsError != null)
                          Padding(
                            padding: const EdgeInsets.only(top: 8.0),
                            child: Text(
                              operatingSystemsError!,
                              style: TextStyle(color: Colors.red, fontSize: 12),
                            ),
                          ),
                        const SizedBox(height: 8),
                        CustomDropdown(
                          hint: isLoadingDetectionMethods
                              ? "Loading detection methods..."
                              : detectionMethodsError != null
                              ? "Error loading detection methods"
                              : "Select a Detection Method",
                          value: detectionMethods.isNotEmpty
                              ? detectionMethods.firstWhere(
                                  (e) => e['name'] == _DetectedSeverity,
                                  orElse: () => {'name': null},
                                )['name']
                              : _DetectedSeverity,
                          items: detectionMethods.isNotEmpty
                              ? detectionMethods
                                    .map((e) => e['name'] as String)
                                    .toList()
                              : const [],
                          onChanged: isLoadingDetectionMethods
                              ? (val) {}
                              : (val) {
                                  setState(() {
                                    _DetectedSeverity = val;
                                    if (detectionMethods.isNotEmpty &&
                                        val != null) {
                                      try {
                                        final selectedMethod = detectionMethods
                                            .firstWhere(
                                              (e) => e['name'] == val,
                                              orElse: () => {
                                                '_id': null,
                                                'name': val,
                                              },
                                            );
                                        print(
                                          'Selected detection method: $val with ID: ${selectedMethod['_id']}',
                                        );
                                      } catch (e) {}
                                    }
                                  });
                                },
                          label: 'How was it Detected*',
                        ),
                        if (detectionMethodsError != null)
                          Padding(
                            padding: const EdgeInsets.only(top: 8.0),
                            child: Text(
                              detectionMethodsError!,
                              style: TextStyle(color: Colors.red, fontSize: 12),
                            ),
                          ),
                        const SizedBox(height: 16),
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'Age Range (if known)',
                              style: TextStyle(
                                fontSize: 14,
                                fontWeight: FontWeight.w600,
                                color: Colors.black,
                              ),
                            ),
                            const SizedBox(height: 8),
                            Container(
                              padding: EdgeInsets.all(16),
                              decoration: BoxDecoration(
                                border: Border.all(color: Colors.black),
                                borderRadius: BorderRadius.circular(8),
                              ),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Row(
                                    mainAxisAlignment:
                                        MainAxisAlignment.spaceBetween,
                                    children: [
                                      Text(
                                        'Age: ${_ageRange.start.round()} - ${_ageRange.end.round()}',
                                        style: TextStyle(
                                          fontSize: 16,
                                          fontWeight: FontWeight.w500,
                                          color: Colors.black,
                                        ),
                                      ),
                                      Icon(
                                        Icons.person,
                                        color: const Color(0xFF064FAD),
                                        size: 20,
                                      ),
                                    ],
                                  ),
                                  const SizedBox(height: 16),
                                  RangeSlider(
                                    values: _ageRange,
                                    min: 10,
                                    max: 100,
                                    divisions: 90,
                                    activeColor: const Color(0xFF064FAD),
                                    inactiveColor: Colors.grey.shade300,
                                    labels: RangeLabels(
                                      _ageRange.start.round().toString(),
                                      _ageRange.end.round().toString(),
                                    ),
                                    onChanged: (RangeValues values) {
                                      setState(() {
                                        _ageRange = values;
                                        minAge = values.start.round();
                                        maxAge = values.end.round();
                                      });
                                    },
                                  ),
                                  const SizedBox(height: 8),
                                  Row(
                                    mainAxisAlignment:
                                        MainAxisAlignment.spaceBetween,
                                    children: [
                                      Text(
                                        '10',
                                        style: TextStyle(
                                          fontSize: 12,
                                          color: Colors.grey[600],
                                        ),
                                      ),
                                      Text(
                                        '100',
                                        style: TextStyle(
                                          fontSize: 12,
                                          color: Colors.grey[600],
                                        ),
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),

                        const SizedBox(height: 16),
                        Container(
                          padding: const EdgeInsets.all(16),
                          decoration: BoxDecoration(
                            // color: Colors.white,
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(color: Colors.black),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  // Icon(Icons.location_on, color: Colors.black),
                                  // const SizedBox(width: 8),
                                  Text(
                                    'Location',
                                    style: TextStyle(
                                      fontWeight: FontWeight.w600,
                                      color: Colors.black,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 12),
                              InkWell(
                                onTap: () {
                                  LocationPickerBottomSheet.show(
                                    context,
                                    onLocationSelected: (location, address) {
                                      setState(() {
                                        selectedLocation = location;
                                        selectedAddress = address;
                                      });
                                      // Persist for offline reuse
                                      LocationStorageService.saveLastSelectedAddress(
                                        label: location,
                                        address: address,
                                      );
                                    },
                                  );
                                },
                                child: Container(
                                  padding: const EdgeInsets.all(16),
                                  decoration: BoxDecoration(
                                    // color: Colors.white,
                                    borderRadius: BorderRadius.circular(8),
                                    border: Border.all(color: Colors.black),
                                  ),
                                  child: Row(
                                    children: [
                                      Icon(
                                        Icons.search,
                                        color: Colors.black,
                                        size: 20,
                                      ),
                                      const SizedBox(width: 12),
                                      Expanded(
                                        child: Text(
                                          selectedLocation != null
                                              ? selectedLocation!
                                              : 'Select location',
                                          style: TextStyle(
                                            color: selectedLocation != null
                                                ? Colors.grey[600]
                                                : Colors.black,
                                            fontSize: 16,
                                          ),
                                        ),
                                      ),
                                      Icon(
                                        Icons.arrow_forward_ios,
                                        color: Colors.black,
                                        size: 16,
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                              if (selectedAddress != null) ...[
                                const SizedBox(height: 8),
                                Container(
                                  padding: const EdgeInsets.all(12),
                                  decoration: BoxDecoration(
                                    color: Colors.blue[50],
                                    borderRadius: BorderRadius.circular(8),
                                    border: Border.all(color: Colors.black),
                                  ),
                                  child: Row(
                                    children: [
                                      Icon(
                                        Icons.location_on,
                                        color: const Color(0xFF064FAD),
                                        size: 16,
                                      ),
                                      const SizedBox(width: 8),
                                      Expanded(
                                        child: Text(
                                          selectedAddress!,
                                          style: TextStyle(
                                            color: const Color(0xFF064FAD),
                                            fontSize: 14,
                                          ),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ],
                          ),
                        ),
                        const SizedBox(height: 24),
                      ],
                    ),
                  ),
                ),

                // Fixed Next button at bottom
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  child: CustomButton(
                    text: 'Next',
                    onPressed: () async {
                      // Trigger validation manually to show errors
                      if (_formKey.currentState!.validate()) {
                        // Validate required fields (alert level validation moved to Step 2)
                        if (_Malwaretype == null ||
                            _infectedSystem == null ||
                            operatingSystemId == null ||
                            _DetectedSeverity == null ||
                            selectedLocation == null) {
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                              content: Text('Please fill all required fields'),
                            ),
                          );
                          return;
                        }

                        // Get current location with real address
                        final locationData = await _getCurrentLocation();

                        // Create malware report model
                        final malwareReport = MalwareReportModel(
                          id: DateTime.now().millisecondsSinceEpoch.toString(),
                          malwareType: _Malwaretype!,
                          infectedDeviceType: _infectedSystem!,
                          operatingSystem: _operatingSystemController.text,
                          detectionMethod: _DetectedSeverity!,
                          location:
                              selectedLocation ?? locationData['address'] ?? '',
                          fileName: _Malwaretype ?? 'Unknown File',
                          name: _Malwaretype ?? 'Unknown Attack',
                          systemAffected: _infectedSystem ?? 'Unknown System',
                          alertSeverityLevel: 'Medium',
                          alertLevels: 'Medium', // Set default alert level
                          date: DateTime.now(),
                          reportTypeId:
                              malwareTypeId, // Set the selected malware type ID
                          reportCategoryId:
                              widget.categoryId, // Add report category ID
                          deviceTypeId: _infectedSystem, // Add device type ID
                          detectTypeId:
                              _DetectedSeverity, // Add detection type ID
                          operatingSystemName:
                              _operatingSystemController.text, // Add OS name
                          attackName: _Malwaretype, // Add attack name
                          attackSystem: _infectedSystem, // Add attack system
                          createdBy: null, // Will be set by service
                          isActive: true,
                          createdAt: DateTime.now(),
                          updatedAt: DateTime.now(),
                          description:
                              'Malware detected on ${_infectedSystem}', // Set initial description
                          incidentDate: DateTime.now(),
                          reportOutcome: false,
                          locationCoordinates:
                              locationData, // Use real location data
                          videofiles: [],
                          screenshots: [],
                          voiceMessages: [],
                          documents: [],
                          minAge: minAge,
                          maxAge: maxAge,
                        );

                        print(
                          'Operating System: ${_operatingSystemController.text}',
                        );

                        print(
                          'Age Range Type: ${minAge.runtimeType} - ${maxAge.runtimeType}',
                        );
                        print(
                          'Age Range Null Check: ${minAge == null} - ${maxAge == null}',
                        );
                        print(
                          'Age Range Values: ${_ageRange.start.round()} - ${_ageRange.end.round()}',
                        );

                        // Don't save here - save only in Step 2 with complete data

                        try {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                              builder: (context) =>
                                  MalwareReportPage2(report: malwareReport),
                            ),
                          ).then((_) {
                            // Refresh the thread database list when returning
                            setState(() {});
                          });
                        } catch (e) {
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text(
                                'Error navigating to next page: $e',
                              ),
                              backgroundColor: Colors.red,
                            ),
                          );
                        }
                      } else {
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text(
                              'Please fill all required fields correctly',
                            ),
                            backgroundColor: Colors.red,
                          ),
                        );
                      }
                    },
                    fontSize: 20,
                    borderCircular: 6,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
