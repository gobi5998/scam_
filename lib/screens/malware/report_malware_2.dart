import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:security_alert/custom/CustomDropdown.dart';
import 'package:security_alert/custom/fileUpload.dart';
import '../../custom/Success_page.dart';
import '../../custom/customButton.dart';
import '../../custom/customTextfield.dart';
import '../../models/malware_report_model.dart';
import 'malware_report_service.dart';
import '../../services/api_service.dart';
import '../../config/api_config.dart';
import 'package:hive/hive.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import '../../services/jwt_service.dart';
import 'package:geolocator/geolocator.dart';
import '../../services/token_storage.dart';
import 'dart:convert';
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';

class MalwareReportPage2 extends StatefulWidget {
  final MalwareReportModel report;
  const MalwareReportPage2({super.key, required this.report});

  @override
  State<MalwareReportPage2> createState() => _MalwareReportPageState();
}

class _MalwareReportPageState extends State<MalwareReportPage2> {
  final _formKey = GlobalKey<FormState>();
  final GlobalKey<FileUploadWidgetState> _fileUploadKey =
      GlobalKey<FileUploadWidgetState>(debugLabel: 'malware_file_upload_${DateTime.now().millisecondsSinceEpoch}');
  Map<String, dynamic>? uploadedFilesData;
  bool filesUploaded = false;

  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _systemAffectedController =
      TextEditingController();
  String? _selectedSeverity;
  String? _selectedSeverityId; // Add ID field for backend compatibility
  List<Map<String, dynamic>> alertLevelOptions = []; // Add alert level options

  @override
  void initState() {
    super.initState();
    _loadAlertLevels();
  }

  Future<void> _loadAlertLevels() async {
    try {
      print('üîç Loading alert levels from API...');
      print(
        'üîç Backend URL: ${ApiConfig.mainBaseUrl}${ApiConfig.alertLevelsEndpoint}',
      );

      // Try to fetch alert levels from backend
      try {
        final apiService = ApiService();
        final alertLevels = await apiService.fetchAlertLevels();

        if (alertLevels.isNotEmpty) {
          if (mounted) {
            setState(() {
              alertLevelOptions = alertLevels;
            });
            print('‚úÖ Loaded ${alertLevels.length} alert levels from API');
            print(
              '‚úÖ Alert levels: ${alertLevels.map((level) => '${level['name']} (${level['_id']})').join(', ')}',
            );
          }
        } else {
          print('‚ùå No alert levels returned from API');
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('No alert levels available from server'),
                backgroundColor: Colors.orange,
                duration: Duration(seconds: 3),
              ),
            );
          }
        }
      } catch (e) {
        print('‚ùå Error loading alert levels from API: $e');
        print('üîç Showing error message to user...');

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'Failed to load alert levels from server. Please check your connection and try again.',
              ),
              backgroundColor: Colors.orange,
              duration: Duration(seconds: 5),
            ),
          );
        }
      }
    } catch (e) {
      print('‚ùå Error loading alert levels: $e');
    }
  }

  // Note: deviceTypeId, detectTypeId, operatingSystemName need ObjectIds from backend
  // For now, we'll submit without these fields to avoid casting errors

  // Get current location with real address
  Future<Map<String, dynamic>> _getCurrentLocation() async {
    try {
      print('üìç Getting current location for malware report...');

      // Check if location services are enabled
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        print('‚ùå Location services are disabled');
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
          'address': 'Location services disabled',
        };
      }

      // Check location permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          print('‚ùå Location permission denied');
          return {
            'type': 'Point',
            'coordinates': [0.0, 0.0], // Fallback coordinates
            'address': 'Location permission denied',
          };
        }
      }

      if (permission == LocationPermission.deniedForever) {
        print('‚ùå Location permission denied forever');
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
          'address': 'Location permission denied',
        };
      }

      // Get current position
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10),
      );

      print(
        '‚úÖ Location obtained for malware report: ${position.latitude}, ${position.longitude}',
      );

      // Get real address using geocoding
      String address = '${position.latitude}, ${position.longitude}';

      try {
        List<Placemark> placemarks = await placemarkFromCoordinates(
          position.latitude,
          position.longitude,
        );

        if (placemarks.isNotEmpty) {
          Placemark placemark = placemarks[0];
          address = [
            placemark.street,
            placemark.subLocality,
            placemark.locality,
            placemark.administrativeArea,
            placemark.country,
          ].where((e) => e != null && e.isNotEmpty).join(', ');
        }
      } catch (e) {
        print('‚ùå Error getting address from coordinates: $e');
        // Keep the coordinates as fallback
      }

      return {
        'type': 'Point',
        'coordinates': [
          position.longitude,
          position.latitude,
        ], // [lng, lat] format
        'address': address,
      };
    } catch (e) {
      print('‚ùå Error getting location for malware report: $e');
      return {
        'type': 'Point',
        'coordinates': [0.0, 0.0], // Fallback coordinates
        'address': 'Location services disabled',
      };
    }
  }

  // File upload is now handled by FileUploadWidget

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Report Malware')),
      body: LayoutBuilder(
        builder: (context, constraints) {
          return SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: ConstrainedBox(
              constraints: BoxConstraints(minHeight: constraints.maxHeight),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      "Upload infected files",
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 8),
                    FileUploadWidget(
                      key: _fileUploadKey,
                      config: FileUploadConfig(
                        reportType: 'malware',
                        reportId: widget.report.id ?? FileUploadService.generateObjectId(),
                        autoUpload: true, // Enable auto-upload
                        showProgress: true,
                        allowMultipleFiles: true,
                      ),
                      onFilesUploaded: (files) {
                        setState(() {
                          uploadedFilesData = files;
                          filesUploaded = true;
                        });
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text('Files uploaded successfully!'),
                            backgroundColor: Colors.green,
                          ),
                        );
                      },
                      onError: (error) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text('File upload error: $error'),
                            backgroundColor: Colors.red,
                          ),
                        );
                      },
                    ),

                    // FileUploadWidget(
                    //   key: _fileUploadKey,
                    //   config: FileUploadConfig(
                    //     reportId: widget.report.id ?? '123',
                    //     reportType: 'malware',
                    //     autoUpload: true,
                    //     showProgress: true,
                    //     maxFileSize: 10,
                    //   ),
                    //   onFilesUploaded: (files) {
                    //     print('üü° Files uploaded successfully:');
                    //     print(
                    //       'üü° - Screenshots: ${files['screenshots'].length}',
                    //     );
                    //     print('üü° - Documents: ${files['documents'].length}');
                    //     print(
                    //       'üü° - Voice Messages: ${files['voiceMessages'].length}',
                    //     );
                    //
                    //     // Show success message
                    //     ScaffoldMessenger.of(context).showSnackBar(
                    //       SnackBar(
                    //         content: Text('Files uploaded successfully!'),
                    //         backgroundColor: Colors.green,
                    //         duration: Duration(seconds: 2),
                    //       ),
                    //     );
                    //   },
                    //   onError: (error) {
                    //     ScaffoldMessenger.of(context).showSnackBar(
                    //       SnackBar(
                    //         content: Text('Upload failed: $error'),
                    //         backgroundColor: Colors.red,
                    //       ),
                    //     );
                    //   },
                    // ),
                    const SizedBox(height: 24),

                    const Text(
                      "Report malware attack details",
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 16),

                    CustomTextField(
                      controller: _nameController,
                      hintText: "Enter name",
                      label: 'Name',
                      validator: (val) =>
                          val == null || val.isEmpty ? 'Required' : null,
                    ),
                    const SizedBox(height: 16),

                    CustomTextField(
                      controller: _systemAffectedController,
                      hintText: "Enter system name",
                      label: 'System Affected',
                      validator: (val) =>
                          val == null || val.isEmpty ? 'Required' : null,
                    ),
                    const SizedBox(height: 16),

                    Row(
                      children: [
                        Expanded(
                          child: CustomDropdown(
                            hint: "Select Severity Level",
                            value: _selectedSeverity,
                            items: alertLevelOptions.isNotEmpty
                                ? alertLevelOptions
                                      .map((level) => level['name'] as String)
                                      .toList()
                                : ['Loading...'],
                            onChanged: (val) {
                              if (val != null && alertLevelOptions.isNotEmpty) {
                                try {
                                  final selectedLevel = alertLevelOptions
                                      .firstWhere(
                                        (level) => level['name'] == val,
                                        orElse: () => <String, dynamic>{},
                                      );
                                  if (selectedLevel.isNotEmpty) {
                                    _selectedSeverityId = selectedLevel['_id'];
                                    print(
                                      '‚úÖ Selected alert level: $val with ID: $_selectedSeverityId',
                                    );
                                  } else {
                                    print(
                                      '‚ùå Could not find alert level ID for: $val',
                                    );
                                    print(
                                      '‚ùå Available options: ${alertLevelOptions.map((e) => e['name']).toList()}',
                                    );
                                    _selectedSeverityId = null;
                                  }
                                } catch (e) {
                                  print('‚ùå Error finding alert level ID: $e');
                                  _selectedSeverityId = null;
                                }
                              } else {
                                _selectedSeverityId = null;
                                print('üîç Alert level cleared');
                              }
                              setState(() {
                                _selectedSeverity = val;
                              });
                            },
                            label: 'Alert Severity Levels',
                          ),
                        ),
                      ],
                    ),

                    // Debug info for alert levels
                    if (alertLevelOptions.isEmpty)
                      Container(
                        margin: const EdgeInsets.only(top: 8),
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.orange[50],
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.orange[200]!),
                        ),
                        child: Row(
                          children: [
                            Icon(
                              Icons.info_outline,
                              color: Colors.orange[600],
                              size: 16,
                            ),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Text(
                                'Alert levels not loaded. Tap refresh button to retry.',
                                style: TextStyle(
                                  color: Colors.orange[700],
                                  fontSize: 12,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),

                    const SizedBox(height: 24),
                    CustomButton(
                      text: 'Submit',
                      onPressed: () async {
                        // Validate required fields
                        if (_nameController.text.isEmpty ||
                            _systemAffectedController.text.isEmpty ||
                            _selectedSeverity == null) {
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                              content: Text('Please fill all required fields'),
                            ),
                          );
                          return;
                        }

                        try {
                          // Upload files first
                          Map<String, dynamic> uploadedFiles = {
                            'screenshots': [],
                            'documents': [],
                            'voiceMessages': [],
                          };

                          if (_fileUploadKey.currentState != null) {
                            uploadedFiles = await _fileUploadKey.currentState!
                                .triggerUpload();
                          }

                          // Extract file objects for backend and URLs for local model
                          final screenshots = (uploadedFiles['screenshots'] as List)
                              .cast<Map<String, dynamic>>();
                          final documents = (uploadedFiles['documents'] as List)
                              .cast<Map<String, dynamic>>();
                          final voiceMessages = (uploadedFiles['voiceMessages'] as List)
                              .cast<Map<String, dynamic>>();
                          final videofiles = (uploadedFiles['videofiles'] as List)
                              .cast<Map<String, dynamic>>();

                          // Also keep URL arrays for local storage if needed elsewhere
                          List<String> screenshotUrls = screenshots
                              .map((f) => f['url']?.toString() ?? '')
                              .where((url) => url.isNotEmpty)
                              .toList();
                          List<String> documentUrls = documents
                              .map((f) => f['url']?.toString() ?? '')
                              .where((url) => url.isNotEmpty)
                              .toList();
                          List<String> voiceMessageUrls = voiceMessages
                              .map((f) => f['url']?.toString() ?? '')
                              .where((url) => url.isNotEmpty)
                              .toList();

                          // Update the report with final data
                          final updatedReport = widget.report.copyWith(
                            name: _nameController.text,
                            systemAffected: _systemAffectedController.text,
                            alertSeverityLevel: _selectedSeverity!,
                            alertLevels:
                                _selectedSeverityId, // Add the alert level ID for backend
                            fileName:
                                '', // File name will be extracted from uploaded files
                            screenshotUrls: screenshotUrls,
                            voiceMessageUrls: voiceMessageUrls,
                            documentUrls: documentUrls,
                          );

                          // Save to local database FIRST (offline-first approach)
                          print('üíæ Starting local database save...');
                          final box = Hive.box<MalwareReportModel>(
                            'malware_reports',
                          );
                          print('üíæ Box length before save: ${box.length}');
                          print('üíæ Report to save: ${updatedReport.toJson()}');

                          if (updatedReport.isInBox) {
                            await MalwareReportService.updateReport(
                              updatedReport,
                            );
                            print(
                              '‚úÖ Updated existing report in local database',
                            );
                          } else {
                            await MalwareReportService.saveReportOffline(
                              updatedReport,
                            );
                            print('‚úÖ Saved new report to local database');
                          }

                          print('üíæ Box length after save: ${box.length}');

                          // Verify the save by reading back the data
                          final allReports = box.values.toList();
                          print(
                            'üíæ Total reports in database: ${allReports.length}',
                          );
                          if (allReports.isNotEmpty) {
                            final lastReport = allReports.last;
                            print(
                              'üíæ Last saved report: ${lastReport.toJson()}',
                            );
                          }

                          // Submit to backend if online
                          final connectivity = await Connectivity()
                              .checkConnectivity();
                          final isOnline =
                              connectivity != ConnectivityResult.none;

                          if (isOnline) {
                            try {
                              print('üåê Starting backend submission...');
                              print(
                                'üåê Updated report data: ${updatedReport.toJson()}',
                              );

                              // Get current location with real address
                              final locationData = await _getCurrentLocation();

                              // Prepare the payload for backend submission
                              final malwarePayload = {
                                'reportCategoryId':
                                    updatedReport.reportCategoryId,
                                'reportTypeId': updatedReport.reportTypeId,
                                'alertLevels': updatedReport.alertLevels,
                                'keycloackUserId':
                                    await JwtService.getCurrentUserId() ??
                                    updatedReport.keycloakUserId ??
                                    '',
                                'createdBy':
                                    await JwtService.getCurrentUserEmail() ??
                                    await JwtService.getCurrentUserId() ??
                                    updatedReport.keycloakUserId ??
                                    '',
                                'isActive': true,
                                'location':
                                    locationData, // Use real location data
                                'attackName': updatedReport.name,
                                'attackSystem': updatedReport.systemAffected,
                                'fileName': updatedReport.fileName,
                                'screenshots': screenshots,
                                'documents': documents,
                                'voiceMessages': voiceMessages,
                                  'videofiles': videofiles,
                                // Removed deviceTypeId, detectTypeId, operatingSystemName to avoid ObjectId casting errors
                                'description': updatedReport.description,
                                'incidentDate':
                                    updatedReport.incidentDate
                                        ?.toUtc().toIso8601String() ??
                                    DateTime.now().toUtc().toIso8601String(),
                                'createdAt':
                                    updatedReport.createdAt
                                        ?.toUtc().toIso8601String() ??
                                    DateTime.now().toUtc().toIso8601String(),
                                'updatedAt': DateTime.now().toUtc().toIso8601String(),
                                'reportOutcome': false,
                              };

                              print(
                                'üì§ Malware payload: ${jsonEncode(malwarePayload)}',
                              );
                              print(
                                'üì§ Payload keys: ${malwarePayload.keys.toList()}',
                              );
                              print(
                                'üì§ Report Category ID: ${malwarePayload['reportCategoryId']}',
                              );
                              print(
                                'üì§ Report Type ID: ${malwarePayload['reportTypeId']}',
                              );
                              print(
                                'üì§ Alert Levels: ${malwarePayload['alertLevels']}',
                              );
                              print(
                                'üì§ Keycloak User ID: ${malwarePayload['keycloackUserId']}',
                              );
                              print(
                                'üì§ Created By: ${malwarePayload['createdBy']}',
                              );
                              print(
                                'üì§ Attack Name: ${malwarePayload['attackName']}',
                              );
                              print(
                                'üì§ Attack System: ${malwarePayload['attackSystem']}',
                              );
                              print(
                                'üì§ Description: ${malwarePayload['description']}',
                              );

                              print(
                                'üöÄ About to submit malware report to backend...',
                              );
                              final success = await ApiService()
                                  .createMalwareReport(malwarePayload);

                              if (success) {
                                print(
                                  '‚úÖ Malware report submitted to backend successfully',
                                );

                                // Update local report to mark as synced
                                final syncedReport = updatedReport.copyWith(
                                  isSynced: true,
                                );
                                if (syncedReport.isInBox) {
                                  await MalwareReportService.updateReport(
                                    syncedReport,
                                  );
                                  print('‚úÖ Updated local report as synced');
                                } else {
                                  await MalwareReportService.saveReportOffline(
                                    syncedReport,
                                  );
                                  print(
                                    '‚úÖ Saved synced report to local database',
                                  );
                                }
                              } else {
                                print(
                                  '‚ö†Ô∏è Malware report backend submission failed',
                                );
                                print(
                                  'üì± Report saved locally, will sync when online',
                                );
                              }
                            } catch (e) {
                              print('‚ùå Error syncing with backend: $e');
                              print(
                                '‚ùå Error stack trace: ${StackTrace.current}',
                              );
                              print(
                                'üì± Report saved locally, will sync when online',
                              );
                            }
                          } else {
                            print(
                              'üì± Offline mode - report saved locally for later sync',
                            );
                          }

                          // Show success message and navigate
                          if (mounted) {
                            print(
                              'üéâ Malware report submission completed successfully!',
                            );

                            // Debug: Check if report was saved
                            try {
                              final box = Hive.box<MalwareReportModel>(
                                'malware_reports',
                              );
                              final savedReports = box.values.toList();
                              print(
                                'üîç Debug: Total malware reports in database: ${savedReports.length}',
                              );
                              if (savedReports.isNotEmpty) {
                                final latestReport = savedReports.last;
                                print(
                                  'üîç Debug: Latest report ID: ${latestReport.id}',
                                );
                                print(
                                  'üîç Debug: Latest report name: ${latestReport.name}',
                                );
                                print(
                                  'üîç Debug: Latest report synced: ${latestReport.isSynced}',
                                );
                              }
                            } catch (e) {
                              print('‚ùå Debug error: $e');
                            }

                            Navigator.pushAndRemoveUntil(
                              context,
                              MaterialPageRoute(
                                builder: (context) => const ReportSuccess(
                                  label: 'Malware Report',
                                ),
                              ),
                              (route) => false,
                            );

                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                content: Text(
                                  isOnline
                                      ? 'Malware report successfully submitted and saved locally!'
                                      : 'Malware report saved locally. Will sync when online.',
                                ),
                                duration: Duration(seconds: 3),
                                backgroundColor: Colors.green,
                              ),
                            );
                          }
                        } catch (e) {
                          print('Error saving malware report: $e');
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(content: Text('Error saving report: $e')),
                          );
                        }
                      },
                      fontSize: 20,
                      borderCircular: 6,
                      fontWeight: FontWeight.bold,
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}
