import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'dart:io';
import 'package:security_alert/custom/CustomDropdown.dart';
import 'package:security_alert/custom/fileUpload.dart';
import '../../custom/Success_page.dart';
import '../../custom/customButton.dart';
import '../../custom/customTextfield.dart';
import '../../models/malware_report_model.dart';
import 'malware_report_service.dart';
import '../../services/api_service.dart';
import '../../custom/offline_file_upload.dart' as custom;
import '../../config/api_config.dart';
import 'package:hive/hive.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import '../../services/jwt_service.dart';
import 'package:geolocator/geolocator.dart';
import '../../services/token_storage.dart';
import 'dart:convert';
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';

class MalwareReportPage2 extends StatefulWidget {
  final MalwareReportModel report;
  const MalwareReportPage2({super.key, required this.report});

  @override
  State<MalwareReportPage2> createState() => _MalwareReportPageState();
}

class _MalwareReportPageState extends State<MalwareReportPage2> {
  final _formKey = GlobalKey<FormState>();
  final GlobalKey<FileUploadWidgetState> _fileUploadKey =
      GlobalKey<FileUploadWidgetState>();
  Map<String, dynamic>? uploadedFilesData;
  bool filesUploaded = false;

  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _systemAffectedController =
      TextEditingController();
  String? _selectedSeverity;
  String? _selectedSeverityId; // Add ID field for backend compatibility
  List<Map<String, dynamic>> alertLevelOptions = []; // Add alert level options

  @override
  void initState() {
    super.initState();
    _loadAlertLevels();
  }

  // Add comprehensive form validation method
  bool _validateForm() {
    // Check connectivity first
    bool isOffline = false;
    Connectivity().checkConnectivity().then((result) {
      isOffline = result == ConnectivityResult.none;
    });

    // Always validate required fields regardless of connectivity
    List<String> missingFields = [];

    // Validate required text fields
    if (_nameController.text.trim().isEmpty) {
      missingFields.add('Name');
    }

    if (_systemAffectedController.text.trim().isEmpty) {
      missingFields.add('System Affected');
    }

    // Validate alert severity
    if (_selectedSeverity == null || _selectedSeverity!.isEmpty) {
      missingFields.add('Alert Severity Level');
    }

    // Check if we have any files uploaded
    bool hasFiles = false;
    if (_fileUploadKey.currentState != null) {
      final state = _fileUploadKey.currentState!;
      final uploadedFiles = state.getCurrentUploadedFiles();
      final totalFiles =
          (uploadedFiles['screenshots']?.length ?? 0) +
          (uploadedFiles['documents']?.length ?? 0) +
          (uploadedFiles['voiceMessages']?.length ?? 0) +
          (uploadedFiles['videofiles']?.length ?? 0);
      hasFiles = totalFiles > 0;
    }

    if (!hasFiles) {
      missingFields.add('Evidence Files (at least one file required)');
    }

    // Show appropriate error message
    if (missingFields.isNotEmpty) {
      String errorMessage = 'Please provide the following required fields:\n';
      errorMessage += missingFields.map((field) => '‚Ä¢ $field').join('\n');

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(errorMessage),
          backgroundColor: Colors.red,
          duration: Duration(seconds: 5),
        ),
      );
      return false;
    }

    return true;
  }

  Future<void> _loadAlertLevels() async {
    try {
      print('üîç Loading alert levels from API...');
      print(
        'üîç Backend URL: ${ApiConfig.mainBaseUrl}${ApiConfig.alertLevelsEndpoint}',
      );

      // Try to fetch alert levels from backend
      try {
        final apiService = ApiService();
        final alertLevels = await apiService.fetchAlertLevels();

        if (alertLevels.isNotEmpty) {
          if (mounted) {
            setState(() {
              alertLevelOptions = alertLevels;
            });
            print('‚úÖ Loaded ${alertLevels.length} alert levels from API');
            print(
              '‚úÖ Alert levels: ${alertLevels.map((level) => '${level['name']} (${level['_id']})').join(', ')}',
            );
          }
        } else {
          print('‚ùå No alert levels returned from API');
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('No alert levels available from server'),
                backgroundColor: Colors.orange,
                duration: Duration(seconds: 3),
              ),
            );
          }
        }
      } catch (e) {
        print('‚ùå Error loading alert levels from API: $e');
        print('üîç Showing error message to user...');

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'Failed to load alert levels from server. Please check your connection and try again.',
              ),
              backgroundColor: Colors.orange,
              duration: Duration(seconds: 5),
            ),
          );
        }
      }
    } catch (e) {
      print('‚ùå Error loading alert levels: $e');
    }
  }

  // Get current location with real address
  Future<Map<String, dynamic>> _getCurrentLocation() async {
    try {
      print('üìç Getting current location for malware report...');

      // Check if location services are enabled
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        print('‚ùå Location services are disabled');
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
          'address': 'Location services disabled',
        };
      }

      // Check location permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          print('‚ùå Location permission denied');
          return {
            'type': 'Point',
            'coordinates': [0.0, 0.0], // Fallback coordinates
            'address': 'Location permission denied',
          };
        }
      }

      if (permission == LocationPermission.deniedForever) {
        print('‚ùå Location permission denied forever');
        return {
          'type': 'Point',
          'coordinates': [0.0, 0.0], // Fallback coordinates
          'address': 'Location permission denied',
        };
      }

      // Get current position
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10),
      );

      print(
        '‚úÖ Location obtained for malware report: ${position.latitude}, ${position.longitude}',
      );

      // Get real address using geocoding
      String address = '${position.latitude}, ${position.longitude}';

      try {
        List<Placemark> placemarks = await placemarkFromCoordinates(
          position.latitude,
          position.longitude,
        );

        if (placemarks.isNotEmpty) {
          Placemark placemark = placemarks[0];
          address = [
            placemark.street,
            placemark.subLocality,
            placemark.locality,
            placemark.administrativeArea,
            placemark.country,
          ].where((e) => e != null && e.isNotEmpty).join(', ');
        }
      } catch (e) {
        print('‚ùå Error getting address from coordinates: $e');
        // Keep the coordinates as fallback
      }

      return {
        'type': 'Point',
        'coordinates': [
          position.longitude,
          position.latitude,
        ], // [lng, lat] format
        'address': address,
      };
    } catch (e) {
      print('‚ùå Error getting location for malware report: $e');
      return {
        'type': 'Point',
        'coordinates': [0.0, 0.0], // Fallback coordinates
        'address': 'Location services disabled',
      };
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Report Malware'),
        backgroundColor: const Color(0xFF064FAD),
        foregroundColor: Colors.white,
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Form(
            key: _formKey,
            child: Column(
              children: [
                // Scrollable content area
                Expanded(
                  child: SingleChildScrollView(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text(
                          "Upload infected files",
                          style: TextStyle(fontWeight: FontWeight.bold),
                        ),
                        const SizedBox(height: 8),
                        FileUploadWidget(
                          key: _fileUploadKey,
                          config: FileUploadConfig(
                            reportType: 'malware',
                            reportId:
                                widget.report.id ??
                                FileUploadService.generateObjectId(),
                            autoUpload: true, // Enable auto-upload
                            showProgress: true,
                            allowMultipleFiles: true,
                          ),
                          onFilesUploaded: (files) {
                            setState(() {
                              uploadedFilesData = files;
                              filesUploaded = true;
                            });
                            print(
                              'üöÄ Files auto-uploaded successfully: ${files.length} files',
                            );
                          },
                          onError: (error) {
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                content: Text('File upload error: $error'),
                                backgroundColor: Colors.red,
                              ),
                            );
                          },
                        ),

                        const SizedBox(height: 24),

                        const Text(
                          "Report malware attack details",
                          style: TextStyle(fontWeight: FontWeight.bold),
                        ),
                        const SizedBox(height: 16),

                        CustomTextField(
                          controller: _nameController,
                          hintText: "Enter name",
                          label: 'Name',
                          validator: (val) =>
                              val == null || val.isEmpty ? 'Required' : null,
                        ),
                        const SizedBox(height: 16),

                        CustomTextField(
                          controller: _systemAffectedController,
                          hintText: "Enter system name",
                          label: 'System Affected',
                          validator: (val) =>
                              val == null || val.isEmpty ? 'Required' : null,
                        ),
                        const SizedBox(height: 16),

                        Row(
                          children: [
                            Expanded(
                              child: CustomDropdown(
                                hint: "Select Severity Level",
                                value: _selectedSeverity,
                                items: alertLevelOptions.isNotEmpty
                                    ? alertLevelOptions
                                          .map(
                                            (level) => level['name'] as String,
                                          )
                                          .toList()
                                    : ['Loading...'],
                                onChanged: (val) {
                                  if (val != null &&
                                      alertLevelOptions.isNotEmpty) {
                                    try {
                                      final selectedLevel = alertLevelOptions
                                          .firstWhere(
                                            (level) => level['name'] == val,
                                            orElse: () => <String, dynamic>{},
                                          );
                                      if (selectedLevel.isNotEmpty) {
                                        _selectedSeverityId =
                                            selectedLevel['_id'];
                                        print(
                                          '‚úÖ Selected alert level: $val with ID: $_selectedSeverityId',
                                        );
                                      } else {
                                        print(
                                          '‚ùå Could not find alert level ID for: $val',
                                        );
                                        print(
                                          '‚ùå Available options: ${alertLevelOptions.map((e) => e['name']).toList()}',
                                        );
                                        _selectedSeverityId = null;
                                      }
                                    } catch (e) {
                                      print(
                                        '‚ùå Error finding alert level ID: $e',
                                      );
                                      _selectedSeverityId = null;
                                    }
                                  } else {
                                    _selectedSeverityId = null;
                                    print('üîç Alert level cleared');
                                  }
                                  setState(() {
                                    _selectedSeverity = val;
                                  });
                                },
                                label: 'Alert Severity Levels',
                              ),
                            ),
                          ],
                        ),

                        // Debug info for alert levels
                        if (alertLevelOptions.isEmpty)
                          Container(
                            margin: const EdgeInsets.only(top: 8),
                            padding: const EdgeInsets.all(12),
                            decoration: BoxDecoration(
                              color: Colors.orange[50],
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(color: Colors.orange[200]!),
                            ),
                            child: Row(
                              children: [
                                Icon(
                                  Icons.info_outline,
                                  color: Colors.orange[600],
                                  size: 16,
                                ),
                                const SizedBox(width: 8),
                                Expanded(
                                  child: Text(
                                    'Alert levels not loaded. Tap refresh button to retry.',
                                    style: TextStyle(
                                      color: Colors.orange[700],
                                      fontSize: 12,
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),

                        const SizedBox(height: 24),
                      ],
                    ),
                  ),
                ),

                // Fixed submit button at bottom
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  child: CustomButton(
                    text: 'Submit',
                    onPressed: () async {
                      // Use comprehensive form validation
                      if (!_validateForm()) {
                        return;
                      }

                      try {
                        // Prepare report submission (using already uploaded files)
                        Map<String, dynamic> uploadedFiles = {
                          'screenshots': [],
                          'documents': [],
                          'voiceMessages': [],
                          'videofiles': [],
                        };

                        if (_fileUploadKey.currentState != null) {
                          final state = _fileUploadKey.currentState!;
                          print('üöÄ File upload state found');

                          // Check if files are currently being uploaded
                          if (state.isCurrentlyUploading) {
                            print(
                              '‚ö†Ô∏è Files are currently being uploaded, waiting for completion...',
                            );
                            // Wait a bit for upload to complete
                            await Future.delayed(Duration(seconds: 2));
                          }

                          // Get the already uploaded files from the widget (NO UPLOAD TRIGGER)
                          uploadedFiles = state.getCurrentUploadedFiles();

                          print(
                            'üöÄ Using already uploaded files from auto-upload (NO NEW UPLOAD)',
                          );
                          print('üöÄ Uploaded files: $uploadedFiles');
                          print(
                            'üöÄ Uploaded files keys: ${uploadedFiles.keys.toList()}',
                          );
                          print(
                            'üöÄ Screenshots count: ${uploadedFiles['screenshots']?.length ?? 0}',
                          );
                          print(
                            'üöÄ Documents count: ${uploadedFiles['documents']?.length ?? 0}',
                          );
                          print(
                            'üöÄ Voice messages count: ${uploadedFiles['voiceMessages']?.length ?? 0}',
                          );
                          print(
                            'üöÄ Video files count: ${uploadedFiles['videofiles']?.length ?? 0}',
                          );

                          final totalUploadedFiles =
                              (uploadedFiles['screenshots']?.length ?? 0) +
                              (uploadedFiles['documents']?.length ?? 0) +
                              (uploadedFiles['voiceMessages']?.length ?? 0) +
                              (uploadedFiles['videofiles']?.length ?? 0);

                          if (totalUploadedFiles == 0) {
                            print(
                              '‚ö†Ô∏è No files found in uploaded files. This might indicate files were not auto-uploaded properly.',
                            );
                          } else {
                            print(
                              '‚úÖ Found $totalUploadedFiles uploaded files ready for submission',
                            );
                          }
                        } else {
                          print('üöÄ File upload state not found');
                        }

                        // Extract file objects for backend and URLs for local model
                        final screenshots =
                            (uploadedFiles['screenshots'] as List)
                                .cast<Map<String, dynamic>>();
                        final documents = (uploadedFiles['documents'] as List)
                            .cast<Map<String, dynamic>>();
                        final voiceMessages =
                            (uploadedFiles['voiceMessages'] as List)
                                .cast<Map<String, dynamic>>();
                        final videofiles = (uploadedFiles['videofiles'] as List)
                            .cast<Map<String, dynamic>>();

                        // Extract URLs for local model storage - FIXED LOGIC
                        final screenshotUrls = screenshots
                            .map(
                              (f) =>
                                  f['offlinePath']?.toString() ??
                                  f['url']?.toString() ??
                                  '',
                            )
                            .where((url) => url.isNotEmpty)
                            .toList();
                        final documentUrls = documents
                            .map(
                              (f) =>
                                  f['offlinePath']?.toString() ??
                                  f['url']?.toString() ??
                                  '',
                            )
                            .where((url) => url.isNotEmpty)
                            .toList();
                        final voiceMessageUrls = voiceMessages
                            .map(
                              (f) =>
                                  f['offlinePath']?.toString() ??
                                  f['url']?.toString() ??
                                  '',
                            )
                            .where((url) => url.isNotEmpty)
                            .toList();
                        final videoUrls = videofiles
                            .map(
                              (f) =>
                                  f['offlinePath']?.toString() ??
                                  f['url']?.toString() ??
                                  '',
                            )
                            .where((url) => url.isNotEmpty)
                            .toList();

                        print('üìÅ Extracted file paths for report model:');
                        print(
                          'üìÅ - Screenshots: ${screenshotUrls.length} - $screenshotUrls',
                        );
                        print(
                          'üìÅ - Documents: ${documentUrls.length} - $documentUrls',
                        );
                        print(
                          'üìÅ - Voice Messages: ${voiceMessageUrls.length} - $voiceMessageUrls',
                        );
                        print(
                          'üìÅ - Video Files: ${videoUrls.length} - $videoUrls',
                        );

                        // Debug: Check if we have offline paths
                        print(
                          'üîç Debug: Checking offline paths in uploaded files:',
                        );
                        for (var screenshot in screenshots) {
                          print(
                            'üîç Screenshot: offlinePath=${screenshot['offlinePath']}, url=${screenshot['url']}',
                          );
                        }
                        for (var document in documents) {
                          print(
                            'üîç Document: offlinePath=${document['offlinePath']}, url=${document['url']}',
                          );
                        }
                        for (var voiceMessage in voiceMessages) {
                          print(
                            'üîç Voice Message: offlinePath=${voiceMessage['offlinePath']}, url=${voiceMessage['url']}',
                          );
                        }
                        for (var videoFile in videofiles) {
                          print(
                            'üîç Video File: offlinePath=${videoFile['offlinePath']}, url=${videoFile['url']}',
                          );
                        }

                        // Update the report with final data
                        // Ensure we have the latest file paths after fallback
                        final finalScreenshots = screenshotUrls.isNotEmpty
                            ? screenshotUrls.cast<String>()
                            : <String>[];
                        final finalDocuments = documentUrls.isNotEmpty
                            ? documentUrls.cast<String>()
                            : <String>[];
                        final finalVoiceMessages = voiceMessageUrls.isNotEmpty
                            ? voiceMessageUrls.cast<String>()
                            : <String>[];
                        final finalVideofiles = videoUrls.isNotEmpty
                            ? videoUrls.cast<String>()
                            : <String>[];

                        var updatedReport = widget.report.copyWith(
                          name: _nameController.text,
                          systemAffected: _systemAffectedController.text,
                          alertSeverityLevel: _selectedSeverity!,
                          alertLevels:
                              _selectedSeverityId, // Add the alert level ID for backend
                          fileName:
                              '', // File name will be extracted from uploaded files
                          screenshots: finalScreenshots,
                          voiceMessages: finalVoiceMessages,
                          documents: finalDocuments,
                          videofiles: finalVideofiles,
                        );

                        print('üöÄ Updated report model created');
                        print('üìÅ File paths in updated report:');
                        print('üìÅ - Screenshots: ${updatedReport.screenshots}');
                        print('üìÅ - Documents: ${updatedReport.documents}');
                        print(
                          'üìÅ - Voice Messages: ${updatedReport.voiceMessages}',
                        );
                        print('üìÅ - Video Files: ${updatedReport.videofiles}');

                        // Always attempt fallback to ensure we have the most up-to-date file information
                        print(
                          'üîÑ ALWAYS attempting fallback: Loading files from offline storage to ensure completeness',
                        );

                        // Try to get files from offline storage as a fallback
                        try {
                          final offlineReportId =
                              widget.report.id ??
                              DateTime.now().millisecondsSinceEpoch.toString();
                          print(
                            'üîÑ Attempting fallback: Loading files from offline storage for ID: $offlineReportId',
                          );

                          // Force fallback even if we think we have files
                          print(
                            'üîÑ Force fallback: Checking offline storage for any missing files',
                          );

                          final offlineFiles =
                              await custom
                                  .OfflineFileUploadService.getOfflineFilesByReportId(
                                offlineReportId,
                              );
                          print(
                            'üîÑ Found ${offlineFiles.length} offline files in fallback attempt',
                          );

                          if (offlineFiles.isNotEmpty) {
                            print('üîÑ Offline files found:');
                            for (var file in offlineFiles) {
                              print(
                                'üîÑ - ${file['originalName']}: ${file['offlinePath']} (${file['category']})',
                              );
                            }

                            // Update the report model with offline file paths
                            print(
                              'üìÅ Found ${offlineFiles.length} offline files, updating report model',
                            );

                            // Categorize offline files and update the arrays
                            final offlineScreenshots = <String>[];
                            final offlineDocuments = <String>[];
                            final offlineVoiceMessages = <String>[];
                            final offlineVideofiles = <String>[];

                            for (var file in offlineFiles) {
                              final category = file['category']
                                  ?.toString()
                                  .toLowerCase();
                              final offlinePath = file['offlinePath']
                                  ?.toString();

                              if (offlinePath != null &&
                                  offlinePath.isNotEmpty) {
                                switch (category) {
                                  case 'screenshots':
                                    offlineScreenshots.add(offlinePath);
                                    break;
                                  case 'documents':
                                    offlineDocuments.add(offlinePath);
                                    break;
                                  case 'voicemessages':
                                    offlineVoiceMessages.add(offlinePath);
                                    break;
                                  case 'videofiles':
                                    offlineVideofiles.add(offlinePath);
                                    break;
                                }
                              }
                            }

                            // Update the report model with offline file paths
                            final updatedReportWithOfflineFiles = updatedReport
                                .copyWith(
                                  screenshots: offlineScreenshots,
                                  documents: offlineDocuments,
                                  voiceMessages: offlineVoiceMessages,
                                  videofiles: offlineVideofiles,
                                );

                            print('üìÅ Updated report with offline files:');
                            print(
                              'üìÅ - Screenshots: ${offlineScreenshots.length}',
                            );
                            print('üìÅ - Documents: ${offlineDocuments.length}');
                            print(
                              'üìÅ - Voice Messages: ${offlineVoiceMessages.length}',
                            );
                            print(
                              'üìÅ - Video Files: ${offlineVideofiles.length}',
                            );

                            // Use the updated report with offline files
                            updatedReport = updatedReportWithOfflineFiles;
                          } else {
                            print(
                              '‚ö†Ô∏è No offline files found in fallback attempt',
                            );
                          }
                        } catch (e) {
                          print('‚ùå Error in fallback file loading: $e');
                        }

                        // Save to local database FIRST (offline-first approach)
                        print('üíæ Starting local database save...');
                        final box = Hive.box<MalwareReportModel>(
                          'malware_reports',
                        );
                        print('üíæ Box length before save: ${box.length}');
                        print('üíæ Report to save: ${updatedReport.toJson()}');

                        if (updatedReport.isInBox) {
                          await MalwareReportService.updateReport(
                            updatedReport,
                          );
                          print('‚úÖ Updated existing report in local database');
                        } else {
                          await MalwareReportService.saveReportOffline(
                            updatedReport,
                          );
                          print('‚úÖ Saved new report to local database');
                        }

                        print('üíæ Box length after save: ${box.length}');

                        // Store files offline for offline-first functionality
                        try {
                          print(
                            'üìÅ Storing files offline for malware report...',
                          );

                          // Convert file objects to File objects for offline storage
                          final List<File> screenshotFiles = [];
                          final List<File> documentFiles = [];
                          final List<File> voiceMessageFiles = [];
                          final List<File> videoFiles = [];

                          // Extract file paths and convert to File objects
                          for (final screenshot in screenshots) {
                            final filePath =
                                screenshot['url']?.toString() ??
                                screenshot['offlinePath']?.toString() ??
                                '';
                            if (filePath.isNotEmpty &&
                                File(filePath).existsSync()) {
                              screenshotFiles.add(File(filePath));
                            }
                          }

                          for (final document in documents) {
                            final filePath =
                                document['url']?.toString() ??
                                document['offlinePath']?.toString() ??
                                '';
                            if (filePath.isNotEmpty &&
                                File(filePath).existsSync()) {
                              documentFiles.add(File(filePath));
                            }
                          }

                          for (final voiceMessage in voiceMessages) {
                            final filePath =
                                voiceMessage['url']?.toString() ??
                                voiceMessage['offlinePath']?.toString() ??
                                '';
                            if (filePath.isNotEmpty &&
                                File(filePath).existsSync()) {
                              voiceMessageFiles.add(File(filePath));
                            }
                          }

                          for (final videoFile in videofiles) {
                            final filePath =
                                videoFile['url']?.toString() ??
                                videoFile['offlinePath']?.toString() ??
                                '';
                            if (filePath.isNotEmpty &&
                                File(filePath).existsSync()) {
                              videoFiles.add(File(filePath));
                            }
                          }

                          // Store files offline using the service
                          final offlineResult =
                              await MalwareReportService.storeFilesOffline(
                                reportId:
                                    updatedReport.id ??
                                    DateTime.now().millisecondsSinceEpoch
                                        .toString(),
                                screenshots: screenshotFiles,
                                documents: documentFiles,
                                voiceMessages: voiceMessageFiles,
                                videofiles: videoFiles,
                              );

                          if (offlineResult['success'] == true) {
                            print(
                              '‚úÖ Files stored offline successfully: ${offlineResult['message']}',
                            );

                            // Extract file paths for local model storage (same as scam service)
                            final screenshotPaths = screenshotFiles
                                .map((f) => f.path)
                                .where((path) => path.isNotEmpty)
                                .toList();

                            final documentPaths = documentFiles
                                .map((f) => f.path)
                                .where((path) => path.isNotEmpty)
                                .toList();

                            final voiceMessagePaths = voiceMessageFiles
                                .map((f) => f.path)
                                .where((path) => path.isNotEmpty)
                                .toList();

                            final videoPaths = videoFiles
                                .map((f) => f.path)
                                .where((path) => path.isNotEmpty)
                                .toList();

                            // Update report model with file paths
                            final updatedReportWithFiles = updatedReport
                                .copyWith(
                                  screenshots: screenshotPaths,
                                  documents: documentPaths,
                                  voiceMessages: voiceMessagePaths,
                                  videofiles: videoPaths,
                                );

                            // Save updated report with file paths
                            if (updatedReportWithFiles.isInBox) {
                              await MalwareReportService.updateReport(
                                updatedReportWithFiles,
                              );
                              print(
                                '‚úÖ Updated malware report with file paths in local database',
                              );
                            } else {
                              await MalwareReportService.saveReportOffline(
                                updatedReportWithFiles,
                              );
                              print(
                                '‚úÖ Saved malware report with file paths to local database',
                              );
                            }

                            print('üìÅ Malware report now has evidence files:');
                            print(
                              'üìÅ - Screenshots: ${screenshotPaths.length}',
                            );
                            print('üìÅ - Documents: ${documentPaths.length}');
                            print(
                              'üìÅ - Voice Messages: ${voiceMessagePaths.length}',
                            );
                            print('üìÅ - Video Files: ${videoPaths.length}');
                          } else {
                            print(
                              '‚ö†Ô∏è Warning: Files not stored offline: ${offlineResult['message']}',
                            );
                          }
                        } catch (e) {
                          print('‚ùå Error storing files offline: $e');
                        }

                        // Verify the save by reading back the data
                        final allReports = box.values.toList();
                        print(
                          'üíæ Total reports in database: ${allReports.length}',
                        );
                        if (allReports.isNotEmpty) {
                          final lastReport = allReports.last;
                          print('üíæ Last saved report: ${lastReport.toJson()}');
                        }

                        // Submit to backend if online
                        final connectivity = await Connectivity()
                            .checkConnectivity();
                        final isOnline =
                            connectivity != ConnectivityResult.none;

                        if (isOnline) {
                          try {
                            print('üåê Starting backend submission...');
                            print(
                              'üåê Updated report data: ${updatedReport.toJson()}',
                            );

                            // Get current location with real address
                            final locationData = await _getCurrentLocation();

                            // Prepare the payload for backend submission
                            final malwarePayload = {
                              'reportCategoryId':
                                  updatedReport.reportCategoryId,
                              'reportTypeId': updatedReport.reportTypeId,
                              'alertLevels': updatedReport.alertLevels,
                              'keycloackUserId':
                                  await JwtService.getCurrentUserId() ??
                                  updatedReport.keycloackUserId ??
                                  '',
                              'createdBy':
                                  await JwtService.getCurrentUserEmail() ??
                                  await JwtService.getCurrentUserId() ??
                                  updatedReport.keycloackUserId ??
                                  '',
                              'isActive': true,
                              'location':
                                  locationData, // Use real location data
                              'attackName': updatedReport.name,
                              'attackSystem': updatedReport.systemAffected,
                              'fileName': updatedReport.fileName,
                              'age': {
                                'min': updatedReport.minAge,
                                'max': updatedReport.maxAge,
                              },
                              'screenshots': screenshots,
                              'documents': documents,
                              'voiceMessages': voiceMessages,
                              'videofiles': videofiles,
                              'description': updatedReport.description,
                              'incidentDate':
                                  updatedReport.incidentDate
                                      ?.toUtc()
                                      .toIso8601String() ??
                                  DateTime.now().toUtc().toIso8601String(),
                              'createdAt':
                                  updatedReport.createdAt
                                      ?.toUtc()
                                      .toIso8601String() ??
                                  DateTime.now().toUtc().toIso8601String(),
                              'updatedAt': DateTime.now()
                                  .toUtc()
                                  .toIso8601String(),
                              'reportOutcome': false,
                            };

                            print(
                              'üì§ Malware payload: ${jsonEncode(malwarePayload)}',
                            );
                            print(
                              'üì§ Payload keys: ${malwarePayload.keys.toList()}',
                            );
                            print(
                              'üì§ Screenshots in payload: ${(malwarePayload['screenshots'] as List?)?.length ?? 0}',
                            );
                            print(
                              'üì§ Documents in payload: ${(malwarePayload['documents'] as List?)?.length ?? 0}',
                            );
                            print(
                              'üì§ Voice messages in payload: ${(malwarePayload['voiceMessages'] as List?)?.length ?? 0}',
                            );
                            print(
                              'üì§ Video files in payload: ${(malwarePayload['videofiles'] as List?)?.length ?? 0}',
                            );
                            print(
                              'üì§ Report Category ID: ${malwarePayload['reportCategoryId']}',
                            );
                            print(
                              'üì§ Report Type ID: ${malwarePayload['reportTypeId']}',
                            );
                            print(
                              'üì§ Alert Levels: ${malwarePayload['alertLevels']}',
                            );
                            print(
                              'üì§ Keycloak User ID: ${malwarePayload['keycloackUserId']}',
                            );
                            print(
                              'üì§ Created By: ${malwarePayload['createdBy']}',
                            );
                            print(
                              'üì§ Attack Name: ${malwarePayload['attackName']}',
                            );
                            print(
                              'üì§ Attack System: ${malwarePayload['attackSystem']}',
                            );
                            print(
                              'üì§ Description: ${malwarePayload['description']}',
                            );
                            print('üì§ Age Data: ${malwarePayload['age']}');

                            print(
                              'üöÄ About to submit malware report to backend...',
                            );
                            final success = await ApiService()
                                .createMalwareReport(malwarePayload);

                            if (success) {
                              print(
                                '‚úÖ Malware report submitted to backend successfully',
                              );

                              // Update local report to mark as synced
                              final syncedReport = updatedReport.copyWith(
                                isSynced: true,
                              );
                              if (syncedReport.isInBox) {
                                await MalwareReportService.updateReport(
                                  syncedReport,
                                );
                                print('‚úÖ Updated local report as synced');
                              } else {
                                await MalwareReportService.saveReportOffline(
                                  syncedReport,
                                );
                                print(
                                  '‚úÖ Saved synced report to local database',
                                );
                              }
                            } else {
                              print(
                                '‚ö†Ô∏è Malware report backend submission failed',
                              );
                              print(
                                'üì± Report saved locally, will sync when online',
                              );
                            }
                          } catch (e) {
                            print('‚ùå Error syncing with backend: $e');
                            print('‚ùå Error stack trace: ${StackTrace.current}');
                            print(
                              'üì± Report saved locally, will sync when online',
                            );
                          }
                        } else {
                          print(
                            'üì± Offline mode - report saved locally for later sync',
                          );
                        }

                        // Show success message and navigate
                        if (mounted) {
                          print(
                            'üéâ Malware report submission completed successfully!',
                          );

                          // Debug: Check if report was saved
                          try {
                            final box = Hive.box<MalwareReportModel>(
                              'malware_reports',
                            );
                            final savedReports = box.values.toList();
                            print(
                              'üîç Debug: Total malware reports in database: ${savedReports.length}',
                            );
                            if (savedReports.isNotEmpty) {
                              final latestReport = savedReports.last;
                              print(
                                'üîç Debug: Latest report ID: ${latestReport.id}',
                              );
                              print(
                                'üîç Debug: Latest report name: ${latestReport.name}',
                              );
                              print(
                                'üîç Debug: Latest report synced: ${latestReport.isSynced}',
                              );
                            }
                          } catch (e) {
                            print('‚ùå Debug error: $e');
                          }

                          Navigator.pushAndRemoveUntil(
                            context,
                            MaterialPageRoute(
                              builder: (context) =>
                                  const ReportSuccess(label: 'Malware Report'),
                            ),
                            (route) => false,
                          );

                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text(
                                isOnline
                                    ? 'Report submitted successfully'
                                    : 'Report saved locally. Will sync when online.',
                              ),
                              duration: Duration(seconds: 3),
                              backgroundColor: Colors.green,
                            ),
                          );
                        }
                      } catch (e) {
                        print('Error saving malware report: $e');
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(content: Text('Error saving report: $e')),
                        );
                      }
                    },
                    fontSize: 20,
                    borderCircular: 6,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
